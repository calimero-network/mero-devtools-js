/**
 * Helper functions for emitting generated code
 */
/**
 * Generate a file banner for generated files
 */
export function generateFileBanner() {
    return '/** @generated by @calimero/abi-codegen â€” DO NOT EDIT. */\n';
}
/**
 * Format a TypeScript identifier to be safe for use in code
 * @param name - The name to format
 * @returns A safe TypeScript identifier
 */
export function formatIdentifier(name) {
    // Handle reserved keywords and special characters
    const reservedKeywords = new Set([
        'break',
        'case',
        'catch',
        'class',
        'const',
        'continue',
        'debugger',
        'default',
        'delete',
        'do',
        'else',
        'enum',
        'export',
        'extends',
        'false',
        'finally',
        'for',
        'function',
        'if',
        'import',
        'in',
        'instanceof',
        'let',
        'new',
        'null',
        'return',
        'super',
        'switch',
        'this',
        'throw',
        'true',
        'try',
        'typeof',
        'var',
        'void',
        'while',
        'with',
        'yield',
        'abstract',
        'boolean',
        'byte',
        'char',
        'double',
        'final',
        'float',
        'goto',
        'implements',
        'int',
        'interface',
        'long',
        'native',
        'package',
        'private',
        'protected',
        'public',
        'short',
        'static',
        'synchronized',
        'throws',
        'transient',
        'volatile',
    ]);
    if (reservedKeywords.has(name)) {
        return `${name}_`;
    }
    // Replace invalid characters with underscores
    return name.replace(/[^a-zA-Z0-9_$]/g, '_');
}
/**
 * Convert a string to PascalCase for type names
 * @param str - The string to convert
 * @returns PascalCase string
 */
export function toPascalCase(str) {
    return str
        .split(/[-_\s]+/)
        .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
        .join('');
}
/**
 * Convert a string to camelCase for method names
 * @param str - The string to convert
 * @returns camelCase string
 */
export function toCamelCase(str) {
    const pascal = toPascalCase(str);
    return pascal.charAt(0).toLowerCase() + pascal.slice(1);
}
/**
 * Derive a client class name from a file path
 * @param p - The file path to derive the name from
 * @returns The derived client class name
 */
export function deriveClientNameFromPath(p) {
    const base = (p.split(/[\\/]/).pop() || '').replace(/\.[^.]+$/, ''); // strip extension
    const parts = base.split(/[^A-Za-z0-9]+/).filter(Boolean);
    const word = (s) => s.length <= 2
        ? s.toUpperCase()
        : s[0].toUpperCase() + s.slice(1).toLowerCase();
    const pascal = parts.map(word).join('');
    return pascal + 'Client';
}
//# sourceMappingURL=emit.js.map