/** @generated by @calimero/abi-codegen â€” DO NOT EDIT. */

import type { MeroJs } from '@calimero-network/mero-js';

/**
 * Context for executing methods
 */
export interface AppContext {
  /** Context ID to execute on */
  contextId: string;
  /** Public key of the executor */
  executorPublicKey: string;
}

// Generated types

export interface AbiState {
  counters: Record<string, number>;
  users: UserId32[];
}

export type ActionPayload =
  | { name: 'Ping' }
  | { name: 'SetName'; payload: string }
  | { name: 'Update'; payload: UpdatePayload }

export const Action = {
  Ping: (): ActionPayload => ({ name: 'Ping' }),
  SetName: (setname: string): ActionPayload => ({ name: 'SetName', payload: setname }),
  Update: (update: UpdatePayload): ActionPayload => ({ name: 'Update', payload: update }),
} as const;

export type ConformanceErrorPayload =
  | { name: 'BadInput' }
  | { name: 'NotFound'; payload: string }

export const ConformanceError = {
  BadInput: (): ConformanceErrorPayload => ({ name: 'BadInput' }),
  NotFound: (notfound: string): ConformanceErrorPayload => ({ name: 'NotFound', payload: notfound }),
} as const;

export type Hash64 = CalimeroBytes;

export interface Person {
  id: UserId32;
  name: string;
  age: number;
}

export interface Profile {
  bio: string | null;
  avatar: CalimeroBytes | null;
  nicknames: string[];
}

export interface UpdatePayload {
  age: number;
}

export type UserId32 = CalimeroBytes;


export type NamedPayload = string;

export type DataPayload = CalimeroBytes;



export type AbiEvent =
  | { name: "Ping" }
  | { name: "Named"; payload: string }
  | { name: "Data"; payload: CalimeroBytes }
  | { name: "PersonUpdated"; payload: Person }
  | { name: "ActionTaken"; payload: ActionPayload }
;


/**
 * Utility class for handling byte conversions in Calimero
 */
export class CalimeroBytes {
  private data: Uint8Array;

  constructor(input: string | number[] | Uint8Array) {
    if (typeof input === "string") {
      // Hex string
      this.data = new Uint8Array(
        input.match(/.{1,2}/g)?.map((byte) => parseInt(byte, 16)) || []
      );
    } else if (Array.isArray(input)) {
      // Number array
      this.data = new Uint8Array(input);
    } else {
      // Uint8Array
      this.data = input;
    }
  }

  toArray(): number[] {
    return Array.from(this.data);
  }

  toUint8Array(): Uint8Array {
    return this.data;
  }

  static fromHex(hex: string): CalimeroBytes {
    return new CalimeroBytes(hex);
  }

  static fromArray(arr: number[]): CalimeroBytes {
    return new CalimeroBytes(arr);
  }

  static fromUint8Array(bytes: Uint8Array): CalimeroBytes {
    return new CalimeroBytes(bytes);
  }
}

/**
 * Convert CalimeroBytes instances to arrays for WASM compatibility
 */
function convertCalimeroBytesForWasm(obj: any): any {
  if (obj === null || obj === undefined) {
    return obj;
  }

  if (obj instanceof CalimeroBytes) {
    return obj.toArray();
  }

  if (Array.isArray(obj)) {
    return obj.map(item => convertCalimeroBytesForWasm(item));
  }

  if (typeof obj === "object") {
    const result: any = {};
    for (const [key, value] of Object.entries(obj)) {
      result[key] = convertCalimeroBytesForWasm(value);
    }
    return result;
  }

  return obj;
}

/**
 * Convert arrays back to CalimeroBytes instances from WASM responses
 */
function convertWasmResultToCalimeroBytes(obj: any): any {
  if (obj === null || obj === undefined) {
    return obj;
  }

  if (Array.isArray(obj) && obj.every(item => typeof item === "number")) {
    return new CalimeroBytes(obj);
  }

  if (Array.isArray(obj)) {
    return obj.map(item => convertWasmResultToCalimeroBytes(item));
  }

  if (typeof obj === "object") {
    const result: any = {};
    for (const [key, value] of Object.entries(obj)) {
      result[key] = convertWasmResultToCalimeroBytes(value);
    }
    return result;
  }

  return obj;
}

export class AbiConformanceClient {
  private mero: MeroJs;
  private context: AppContext;

  constructor(mero: MeroJs, context: AppContext) {
    this.mero = mero;
    this.context = context;
  }

  /**
   * init
   */
  public async init(): Promise<AbiState> {
    const result = await this.mero.rpc.execute({
      contextId: this.context.contextId,
      method: 'init',
      args: {},
      executorPublicKey: this.context.executorPublicKey,
    });
    return convertWasmResultToCalimeroBytes(result.output) as AbiState;
  }

  /**
   * noop
   */
  public async noop(): Promise<void> {
    const result = await this.mero.rpc.execute({
      contextId: this.context.contextId,
      method: 'noop',
      args: {},
      executorPublicKey: this.context.executorPublicKey,
    });
    return result.output as void;
  }

  /**
   * echo_bool
   */
  public async echoBool(params: { b: boolean }): Promise<boolean> {
    const result = await this.mero.rpc.execute({
      contextId: this.context.contextId,
      method: 'echo_bool',
      args: params,
      executorPublicKey: this.context.executorPublicKey,
    });
    return result.output as boolean;
  }

  /**
   * echo_i32
   */
  public async echoI32(params: { x: number }): Promise<number> {
    const result = await this.mero.rpc.execute({
      contextId: this.context.contextId,
      method: 'echo_i32',
      args: params,
      executorPublicKey: this.context.executorPublicKey,
    });
    return result.output as number;
  }

  /**
   * echo_i64
   */
  public async echoI64(params: { x: number }): Promise<number> {
    const result = await this.mero.rpc.execute({
      contextId: this.context.contextId,
      method: 'echo_i64',
      args: params,
      executorPublicKey: this.context.executorPublicKey,
    });
    return result.output as number;
  }

  /**
   * echo_u32
   */
  public async echoU32(params: { x: number }): Promise<number> {
    const result = await this.mero.rpc.execute({
      contextId: this.context.contextId,
      method: 'echo_u32',
      args: params,
      executorPublicKey: this.context.executorPublicKey,
    });
    return result.output as number;
  }

  /**
   * echo_u64
   */
  public async echoU64(params: { x: number }): Promise<number> {
    const result = await this.mero.rpc.execute({
      contextId: this.context.contextId,
      method: 'echo_u64',
      args: params,
      executorPublicKey: this.context.executorPublicKey,
    });
    return result.output as number;
  }

  /**
   * echo_f32
   */
  public async echoF32(params: { x: number }): Promise<number> {
    const result = await this.mero.rpc.execute({
      contextId: this.context.contextId,
      method: 'echo_f32',
      args: params,
      executorPublicKey: this.context.executorPublicKey,
    });
    return result.output as number;
  }

  /**
   * echo_f64
   */
  public async echoF64(params: { x: number }): Promise<number> {
    const result = await this.mero.rpc.execute({
      contextId: this.context.contextId,
      method: 'echo_f64',
      args: params,
      executorPublicKey: this.context.executorPublicKey,
    });
    return result.output as number;
  }

  /**
   * echo_string
   */
  public async echoString(params: { s: string }): Promise<string> {
    const result = await this.mero.rpc.execute({
      contextId: this.context.contextId,
      method: 'echo_string',
      args: params,
      executorPublicKey: this.context.executorPublicKey,
    });
    return result.output as string;
  }

  /**
   * echo_bytes
   */
  public async echoBytes(params: { b: CalimeroBytes }): Promise<CalimeroBytes> {
    const result = await this.mero.rpc.execute({
      contextId: this.context.contextId,
      method: 'echo_bytes',
      args: convertCalimeroBytesForWasm(params),
      executorPublicKey: this.context.executorPublicKey,
    });
    return convertWasmResultToCalimeroBytes(result.output) as CalimeroBytes;
  }

  /**
   * opt_u32
   */
  public async optU32(params: { x: number | null }): Promise<number | null> {
    const result = await this.mero.rpc.execute({
      contextId: this.context.contextId,
      method: 'opt_u32',
      args: params,
      executorPublicKey: this.context.executorPublicKey,
    });
    return result.output as number | null;
  }

  /**
   * opt_string
   */
  public async optString(params: { x: string | null }): Promise<string | null> {
    const result = await this.mero.rpc.execute({
      contextId: this.context.contextId,
      method: 'opt_string',
      args: params,
      executorPublicKey: this.context.executorPublicKey,
    });
    return result.output as string | null;
  }

  /**
   * opt_record
   */
  public async optRecord(params: { p: Person | null }): Promise<Person | null> {
    const result = await this.mero.rpc.execute({
      contextId: this.context.contextId,
      method: 'opt_record',
      args: convertCalimeroBytesForWasm(params),
      executorPublicKey: this.context.executorPublicKey,
    });
    return convertWasmResultToCalimeroBytes(result.output) as Person | null;
  }

  /**
   * opt_id
   */
  public async optId(params: { x: UserId32 | null }): Promise<UserId32 | null> {
    const result = await this.mero.rpc.execute({
      contextId: this.context.contextId,
      method: 'opt_id',
      args: convertCalimeroBytesForWasm(params),
      executorPublicKey: this.context.executorPublicKey,
    });
    return convertWasmResultToCalimeroBytes(result.output) as UserId32 | null;
  }

  /**
   * list_u32
   */
  public async listU32(params: { xs: number[] }): Promise<number[]> {
    const result = await this.mero.rpc.execute({
      contextId: this.context.contextId,
      method: 'list_u32',
      args: params,
      executorPublicKey: this.context.executorPublicKey,
    });
    return result.output as number[];
  }

  /**
   * list_strings
   */
  public async listStrings(params: { xs: string[] }): Promise<string[]> {
    const result = await this.mero.rpc.execute({
      contextId: this.context.contextId,
      method: 'list_strings',
      args: params,
      executorPublicKey: this.context.executorPublicKey,
    });
    return result.output as string[];
  }

  /**
   * list_records
   */
  public async listRecords(params: { ps: Person[] }): Promise<Person[]> {
    const result = await this.mero.rpc.execute({
      contextId: this.context.contextId,
      method: 'list_records',
      args: convertCalimeroBytesForWasm(params),
      executorPublicKey: this.context.executorPublicKey,
    });
    return convertWasmResultToCalimeroBytes(result.output) as Person[];
  }

  /**
   * list_ids
   */
  public async listIds(params: { xs: UserId32[] }): Promise<UserId32[]> {
    const result = await this.mero.rpc.execute({
      contextId: this.context.contextId,
      method: 'list_ids',
      args: convertCalimeroBytesForWasm(params),
      executorPublicKey: this.context.executorPublicKey,
    });
    return convertWasmResultToCalimeroBytes(result.output) as UserId32[];
  }

  /**
   * map_u32
   */
  public async mapU32(params: { m: Record<string, number> }): Promise<Record<string, number>> {
    const result = await this.mero.rpc.execute({
      contextId: this.context.contextId,
      method: 'map_u32',
      args: params,
      executorPublicKey: this.context.executorPublicKey,
    });
    return result.output as Record<string, number>;
  }

  /**
   * map_list_u32
   */
  public async mapListU32(params: { m: Record<string, number[]> }): Promise<Record<string, number[]>> {
    const result = await this.mero.rpc.execute({
      contextId: this.context.contextId,
      method: 'map_list_u32',
      args: params,
      executorPublicKey: this.context.executorPublicKey,
    });
    return result.output as Record<string, number[]>;
  }

  /**
   * map_record
   */
  public async mapRecord(params: { m: Record<string, Person> }): Promise<Record<string, Person>> {
    const result = await this.mero.rpc.execute({
      contextId: this.context.contextId,
      method: 'map_record',
      args: convertCalimeroBytesForWasm(params),
      executorPublicKey: this.context.executorPublicKey,
    });
    return convertWasmResultToCalimeroBytes(result.output) as Record<string, Person>;
  }

  /**
   * make_person
   */
  public async makePerson(params: { p: Person }): Promise<Person> {
    const result = await this.mero.rpc.execute({
      contextId: this.context.contextId,
      method: 'make_person',
      args: convertCalimeroBytesForWasm(params),
      executorPublicKey: this.context.executorPublicKey,
    });
    return convertWasmResultToCalimeroBytes(result.output) as Person;
  }

  /**
   * profile_roundtrip
   */
  public async profileRoundtrip(params: { p: Profile }): Promise<Profile> {
    const result = await this.mero.rpc.execute({
      contextId: this.context.contextId,
      method: 'profile_roundtrip',
      args: convertCalimeroBytesForWasm(params),
      executorPublicKey: this.context.executorPublicKey,
    });
    return convertWasmResultToCalimeroBytes(result.output) as Profile;
  }

  /**
   * act
   */
  public async act(params: { a: ActionPayload }): Promise<number> {
    // Convert Action variant to WASM format
    const convertedParams = { ...params } as any;
    if (convertedParams.a && typeof convertedParams.a === 'object' && 'name' in convertedParams.a) {
      if ('payload' in convertedParams.a) {
        convertedParams.a = { [convertedParams.a.name]: convertedParams.a.payload };
      } else {
        convertedParams.a = convertedParams.a.name;
      }
    }
    const result = await this.mero.rpc.execute({
      contextId: this.context.contextId,
      method: 'act',
      args: convertedParams,
      executorPublicKey: this.context.executorPublicKey,
    });
    return result.output as number;
  }

  /**
   * roundtrip_id
   */
  public async roundtripId(params: { x: UserId32 }): Promise<UserId32> {
    const result = await this.mero.rpc.execute({
      contextId: this.context.contextId,
      method: 'roundtrip_id',
      args: convertCalimeroBytesForWasm(params),
      executorPublicKey: this.context.executorPublicKey,
    });
    return convertWasmResultToCalimeroBytes(result.output) as UserId32;
  }

  /**
   * roundtrip_hash
   */
  public async roundtripHash(params: { h: Hash64 }): Promise<Hash64> {
    const result = await this.mero.rpc.execute({
      contextId: this.context.contextId,
      method: 'roundtrip_hash',
      args: convertCalimeroBytesForWasm(params),
      executorPublicKey: this.context.executorPublicKey,
    });
    return convertWasmResultToCalimeroBytes(result.output) as Hash64;
  }

  /**
   * may_fail
   */
  public async mayFail(params: { flag: boolean }): Promise<number> {
    const result = await this.mero.rpc.execute({
      contextId: this.context.contextId,
      method: 'may_fail',
      args: params,
      executorPublicKey: this.context.executorPublicKey,
    });
    return result.output as number;
  }

  /**
   * find_person
   */
  public async findPerson(params: { name: string }): Promise<Person> {
    const result = await this.mero.rpc.execute({
      contextId: this.context.contextId,
      method: 'find_person',
      args: params,
      executorPublicKey: this.context.executorPublicKey,
    });
    return convertWasmResultToCalimeroBytes(result.output) as Person;
  }

}