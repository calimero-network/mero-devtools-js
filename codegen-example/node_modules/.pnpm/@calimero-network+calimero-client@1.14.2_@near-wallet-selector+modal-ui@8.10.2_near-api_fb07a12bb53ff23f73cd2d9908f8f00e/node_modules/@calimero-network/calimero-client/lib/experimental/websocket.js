import { getAccessToken } from '../storage/storage';
const RECONNECT_DELAY = 5000; // 5 seconds
export class ExperimentalWebSocket {
    ws = null;
    url;
    reconnectTimeout = null;
    callbacks = new Map();
    requestId = 0;
    constructor(baseUrl) {
        this.url = this.buildUrl(baseUrl);
        this.connect();
    }
    buildUrl(baseUrl) {
        let wsUrl = '';
        if (baseUrl.startsWith('https://')) {
            wsUrl = baseUrl.replace('https://', 'wss://');
        }
        else if (baseUrl.startsWith('http://')) {
            wsUrl = baseUrl.replace('http://', 'ws://');
        }
        else {
            wsUrl = `wss://${baseUrl}`;
        }
        return `${wsUrl}/ws`;
    }
    connect() {
        const accessToken = getAccessToken();
        if (!accessToken) {
            console.warn('No access token found, WebSocket connection aborted.');
            return;
        }
        const fullUrl = `${this.url}?token=${encodeURIComponent(accessToken)}`;
        this.ws = new WebSocket(fullUrl);
        this.ws.onopen = () => {
            this.clearReconnect();
        };
        this.ws.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
                if (data.result && data.result.contextId) {
                    const nodeEvent = data.result;
                    this.decodeEventData(nodeEvent);
                    const callback = this.callbacks.get(nodeEvent.contextId);
                    if (callback) {
                        callback(nodeEvent);
                    }
                }
            }
            catch (e) {
                console.error('Error parsing WebSocket message:', e);
            }
        };
        this.ws.onclose = () => {
            console.log('Experimental WebSocket disconnected.');
            this.scheduleReconnect();
        };
        this.ws.onerror = (error) => {
            console.error('Experimental WebSocket error:', error);
            this.ws?.close();
        };
    }
    decodeEventData(nodeEvent) {
        if (nodeEvent.type === 'ExecutionEvent' &&
            nodeEvent.data &&
            Array.isArray(nodeEvent.data.events)) {
            nodeEvent.data.events.forEach((executionEvent) => {
                if (Array.isArray(executionEvent.data) &&
                    executionEvent.data.every((item) => typeof item === 'number')) {
                    try {
                        const decodedString = new TextDecoder().decode(new Uint8Array(executionEvent.data));
                        try {
                            executionEvent.data = JSON.parse(decodedString);
                        }
                        catch (jsonError) {
                            executionEvent.data = decodedString;
                        }
                    }
                    catch (decodeError) {
                        console.error('Failed to decode event data byte array', decodeError);
                    }
                }
            });
        }
    }
    scheduleReconnect() {
        this.clearReconnect();
        this.reconnectTimeout = setTimeout(() => {
            console.log('Attempting to reconnect WebSocket...');
            this.connect();
        }, RECONNECT_DELAY);
    }
    clearReconnect() {
        if (this.reconnectTimeout) {
            clearTimeout(this.reconnectTimeout);
        }
    }
    subscribe(contextIds, callback) {
        contextIds.forEach((contextId) => {
            this.callbacks.set(contextId, callback);
        });
        if (this.ws?.readyState === WebSocket.OPEN) {
            this.ws.send(JSON.stringify({
                id: this.requestId++,
                method: 'subscribe',
                params: { contextIds: contextIds },
            }));
        }
    }
    unsubscribe(contextIds) {
        contextIds.forEach((contextId) => {
            this.callbacks.delete(contextId);
        });
        if (this.ws?.readyState === WebSocket.OPEN) {
            this.ws.send(JSON.stringify({
                id: this.requestId++,
                method: 'unsubscribe',
                params: { contextIds: contextIds },
            }));
        }
    }
    close() {
        this.clearReconnect();
        this.ws?.close();
    }
}
