"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all3) => {
  for (var name in all3)
    __defProp(target, name, { get: all3[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  ACCESS_TOKEN: () => ACCESS_TOKEN,
  APPLICATION_ID: () => APPLICATION_ID,
  APP_URL: () => APP_URL,
  AppMode: () => AppMode,
  CONTEXT_ID: () => CONTEXT_ID,
  CONTEXT_IDENTITY: () => CONTEXT_IDENTITY,
  CalimeroConnectButton: () => CalimeroConnectButton_default,
  CalimeroLogo: () => CalimeroLogo_default,
  CalimeroProvider: () => CalimeroProvider,
  ClientLogin: () => ClientLogin,
  ContextModal: () => ContextModal,
  JsonRpcClient: () => JsonRpcClient,
  ProtectedRoutesWrapper: () => ProtectedRoutesWrapper,
  Protocol: () => Protocol,
  REFRESH_TOKEN: () => REFRESH_TOKEN,
  SelectContext: () => SelectContext,
  SelectContextIdentity: () => SelectContextIdentity,
  SetupModal: () => SetupModal,
  Toast: () => Toast_default,
  WsSubscriptionsClient: () => WsSubscriptionsClient,
  adminClient: () => adminClient,
  apiClient: () => apiClient,
  authClient: () => authClient,
  blobClient: () => blobClient,
  clearAccessToken: () => clearAccessToken,
  clearAppEndpoint: () => clearAppEndpoint,
  clearApplicationId: () => clearApplicationId,
  clearContextId: () => clearContextId,
  clearExecutorPublicKey: () => clearExecutorPublicKey,
  clearRefreshToken: () => clearRefreshToken,
  clientLogout: () => clientLogout,
  contractClient: () => contractClient,
  getAccessToken: () => getAccessToken,
  getAppEndpointKey: () => getAppEndpointKey,
  getApplicationId: () => getApplicationId,
  getAuthConfig: () => getAuthConfig,
  getContextId: () => getContextId,
  getExecutorPublicKey: () => getExecutorPublicKey,
  getJWTObject: () => getJWTObject,
  getRefreshToken: () => getRefreshToken,
  rpcClient: () => rpcClient,
  setAccessToken: () => setAccessToken,
  setAppEndpointKey: () => setAppEndpointKey,
  setApplicationId: () => setApplicationId,
  setContextAndIdentityFromJWT: () => setContextAndIdentityFromJWT,
  setContextId: () => setContextId,
  setExecutorPublicKey: () => setExecutorPublicKey,
  setRefreshToken: () => setRefreshToken,
  useCalimero: () => useCalimero
});
module.exports = __toCommonJS(index_exports);

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/helpers/bind.js
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/utils.js
var { toString } = Object.prototype;
var { getPrototypeOf } = Object;
var { iterator, toStringTag } = Symbol;
var kindOf = /* @__PURE__ */ ((cache) => (thing) => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
var kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
var typeOfTest = (type) => (thing) => typeof thing === type;
var { isArray } = Array;
var isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
var isString = typeOfTest("string");
var isFunction = typeOfTest("function");
var isNumber = typeOfTest("number");
var isObject = (thing) => thing !== null && typeof thing === "object";
var isBoolean = (thing) => thing === true || thing === false;
var isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype3 = getPrototypeOf(val);
  return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(toStringTag in val) && !(iterator in val);
};
var isEmptyObject = (val) => {
  if (!isObject(val) || isBuffer(val)) {
    return false;
  }
  try {
    return Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;
  } catch (e) {
    return false;
  }
};
var isDate = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
var isStream = (val) => isObject(val) && isFunction(val.pipe);
var isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
var isURLSearchParams = kindOfTest("URLSearchParams");
var [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    if (isBuffer(obj)) {
      return;
    }
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  if (isBuffer(obj)) {
    return null;
  }
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
var _global = (() => {
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
var isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}
var extend = (a, b, thisArg, { allOwnKeys } = {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
};
var stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
var inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
var toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null) return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
var endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
var toArray = (thing) => {
  if (!thing) return null;
  if (isArray(thing)) return thing;
  let i = thing.length;
  if (!isNumber(i)) return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};
var isTypedArray = /* @__PURE__ */ ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
var forEachEntry = (obj, fn) => {
  const generator = obj && obj[iterator];
  const _iterator = generator.call(obj);
  let result;
  while ((result = _iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
var matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
var isRegExp = kindOfTest("RegExp");
var reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
var freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction(value)) return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
var toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
var noop = () => {
};
var toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[toStringTag] === "FormData" && thing[iterator]);
}
var toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (isBuffer(source)) {
        return source;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
var isAsyncFn = kindOfTest("AsyncFunction");
var isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
var _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }
  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({ source, data }) => {
      if (source === _global && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);
    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    };
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === "function",
  isFunction(_global.postMessage)
);
var asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
var isIterable = (thing) => thing != null && isFunction(thing[iterator]);
var utils_default = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isEmptyObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap,
  isIterable
};

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/core/AxiosError.js
function AxiosError(message, code, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}
utils_default.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils_default.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
var prototype = AxiosError.prototype;
var descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype);
  utils_default.toFlatObject(error, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code, config, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_default = AxiosError;

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/helpers/null.js
var null_default = null;

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/helpers/toFormData.js
function isVisitable(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
function removeBrackets(key) {
  return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token, i) {
    token = removeBrackets(token);
    return !dots && i ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils_default.isArray(arr) && !arr.some(isVisitable);
}
var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils_default.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (null_default || FormData)();
  options = utils_default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils_default.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
  if (!utils_default.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null) return "";
    if (utils_default.isDate(value)) {
      return value.toISOString();
    }
    if (utils_default.isBoolean(value)) {
      return value.toString();
    }
    if (!useBlob && utils_default.isBlob(value)) {
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils_default.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index) {
          !(utils_default.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils_default.isUndefined(value)) return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils_default.forEach(value, function each(el, key) {
      const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils_default.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils_default.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
var toFormData_default = toFormData;

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData_default(params, this, options);
}
var prototype2 = AxiosURLSearchParams.prototype;
prototype2.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype2.toString = function toString2(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode);
  } : encode;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
var AxiosURLSearchParams_default = AxiosURLSearchParams;

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/helpers/buildURL.js
function encode2(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode2;
  if (utils_default.isFunction(options)) {
    options = {
      serialize: options
    };
  }
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/core/InterceptorManager.js
var InterceptorManager = class {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils_default.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
};
var InterceptorManager_default = InterceptorManager;

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/defaults/transitional.js
var transitional_default = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/platform/browser/classes/URLSearchParams.js
var URLSearchParams_default = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams_default;

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/platform/browser/classes/FormData.js
var FormData_default = typeof FormData !== "undefined" ? FormData : null;

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/platform/browser/classes/Blob.js
var Blob_default = typeof Blob !== "undefined" ? Blob : null;

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/platform/browser/index.js
var browser_default = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams_default,
    FormData: FormData_default,
    Blob: Blob_default
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/platform/common/utils.js
var utils_exports = {};
__export(utils_exports, {
  hasBrowserEnv: () => hasBrowserEnv,
  hasStandardBrowserEnv: () => hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv: () => hasStandardBrowserWebWorkerEnv,
  navigator: () => _navigator,
  origin: () => origin
});
var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
var _navigator = typeof navigator === "object" && navigator || void 0;
var hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
var hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
var origin = hasBrowserEnv && window.location.href || "http://localhost";

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/platform/index.js
var platform_default = {
  ...utils_exports,
  ...browser_default
};

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
  return toFormData_default(data, new platform_default.classes.URLSearchParams(), {
    visitor: function(value, key, path, helpers) {
      if (platform_default.isNode && utils_default.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    },
    ...options
  });
}

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/helpers/formDataToJSON.js
function parsePropPath(name) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];
    if (name === "__proto__") return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils_default.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils_default.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils_default.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path, value, target[name], index);
    if (result && utils_default.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    const obj = {};
    utils_default.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
var formDataToJSON_default = formDataToJSON;

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/defaults/index.js
function stringifySafely(rawValue, parser, encoder) {
  if (utils_default.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils_default.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults = {
  transitional: transitional_default,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils_default.isObject(data);
    if (isObjectPayload && utils_default.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils_default.isFormData(data);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
    }
    if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (utils_default.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils_default.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData_default(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils_default.isResponse(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw AxiosError_default.from(e, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform_default.classes.FormData,
    Blob: platform_default.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils_default.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
var defaults_default = defaults;

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/helpers/parseHeaders.js
var ignoreDuplicateOf = utils_default.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var parseHeaders_default = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i = line.indexOf(":");
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/core/AxiosHeaders.js
var $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils_default.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils_default.isString(value)) return;
  if (utils_default.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils_default.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils_default.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
var AxiosHeaders = class {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils_default.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders_default(header), valueOrRewrite);
    } else if (utils_default.isObject(header) && utils_default.isIterable(header)) {
      let obj = {}, dest, key;
      for (const entry of header) {
        if (!utils_default.isArray(entry)) {
          throw TypeError("Object iterator must return a key-value pair");
        }
        obj[key = entry[0]] = (dest = obj[key]) ? utils_default.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
      }
      setHeaders(obj, valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils_default.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils_default.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils_default.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils_default.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;
    while (i--) {
      const key = keys[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils_default.forEach(this, (value, header) => {
      const key = utils_default.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils_default.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype3 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype3, _header);
        accessors[lHeader] = true;
      }
    }
    utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils_default.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils_default.freezeMethods(AxiosHeaders);
var AxiosHeaders_default = AxiosHeaders;

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
  const config = this || defaults_default;
  const context = response || config;
  const headers = AxiosHeaders_default.from(context.headers);
  let data = context.data;
  utils_default.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/cancel/isCancel.js
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/cancel/CanceledError.js
function CanceledError(message, config, request) {
  AxiosError_default.call(this, message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config, request);
  this.name = "CanceledError";
}
utils_default.inherits(CanceledError, AxiosError_default, {
  __CANCEL__: true
});
var CanceledError_default = CanceledError;

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/core/settle.js
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError_default(
      "Request failed with status code " + response.status,
      [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/helpers/parseProtocol.js
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || "";
}

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/helpers/speedometer.js
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
var speedometer_default = speedometer;

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/helpers/throttle.js
function throttle(fn, freq) {
  let timestamp = 0;
  let threshold = 1e3 / freq;
  let lastArgs;
  let timer;
  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn(...args);
  };
  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if (passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };
  const flush = () => lastArgs && invoke(lastArgs);
  return [throttled, flush];
}
var throttle_default = throttle;

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/helpers/progressEventReducer.js
var progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer_default(50, 250);
  return throttle_default((e) => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e,
      lengthComputable: total != null,
      [isDownloadStream ? "download" : "upload"]: true
    };
    listener(data);
  }, freq);
};
var progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;
  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};
var asyncDecorator = (fn) => (...args) => utils_default.asap(() => fn(...args));

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/helpers/isURLSameOrigin.js
var isURLSameOrigin_default = platform_default.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url) => {
  url = new URL(url, platform_default.origin);
  return origin2.protocol === url.protocol && origin2.host === url.host && (isMSIE || origin2.port === url.port);
})(
  new URL(platform_default.origin),
  platform_default.navigator && /(msie|trident)/i.test(platform_default.navigator.userAgent)
) : () => true;

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/helpers/cookies.js
var cookies_default = platform_default.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path, domain, secure) {
      const cookie = [name + "=" + encodeURIComponent(value)];
      utils_default.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils_default.isString(path) && cookie.push("path=" + path);
      utils_default.isString(domain) && cookie.push("domain=" + domain);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
    },
    read(name) {
      const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove(name) {
      this.write(name, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/helpers/isAbsoluteURL.js
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/helpers/combineURLs.js
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !isAbsoluteURL(requestedURL);
  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/core/mergeConfig.js
var headersToObject = (thing) => thing instanceof AxiosHeaders_default ? { ...thing } : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, prop, caseless) {
    if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
      return utils_default.merge.call({ caseless }, target, source);
    } else if (utils_default.isPlainObject(source)) {
      return utils_default.merge({}, source);
    } else if (utils_default.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a, b, prop, caseless) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(a, b, prop, caseless);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a, prop, caseless);
    }
  }
  function valueFromConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    }
  }
  function defaultToConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
  }
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(void 0, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true)
  };
  utils_default.forEach(Object.keys({ ...config1, ...config2 }), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils_default.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/helpers/resolveConfig.js
var resolveConfig_default = (config) => {
  const newConfig = mergeConfig({}, config);
  let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
  newConfig.headers = headers = AxiosHeaders_default.from(headers);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);
  if (auth) {
    headers.set(
      "Authorization",
      "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
    );
  }
  let contentType;
  if (utils_default.isFormData(data)) {
    if (platform_default.hasStandardBrowserEnv || platform_default.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(void 0);
    } else if ((contentType = headers.getContentType()) !== false) {
      const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
      headers.setContentType([type || "multipart/form-data", ...tokens].join("; "));
    }
  }
  if (platform_default.hasStandardBrowserEnv) {
    withXSRFToken && utils_default.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin_default(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies_default.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/adapters/xhr.js
var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhr_default = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = resolveConfig_default(config);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders_default.from(_config.headers).normalize();
    let { responseType, onUploadProgress, onDownloadProgress } = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;
    function done() {
      flushUpload && flushUpload();
      flushDownload && flushDownload();
      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
      _config.signal && _config.signal.removeEventListener("abort", onCanceled);
    }
    let request = new XMLHttpRequest();
    request.open(_config.method.toUpperCase(), _config.url, true);
    request.timeout = _config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders_default.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config, request));
      request = null;
    };
    request.onerror = function handleError() {
      reject(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = _config.transitional || transitional_default;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError_default(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
        config,
        request
      ));
      request = null;
    };
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils_default.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = _config.responseType;
    }
    if (onDownloadProgress) {
      [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
      request.addEventListener("progress", downloadThrottled);
    }
    if (onUploadProgress && request.upload) {
      [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
      request.upload.addEventListener("progress", uploadThrottled);
      request.upload.addEventListener("loadend", flushUpload);
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError_default(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(_config.url);
    if (protocol && platform_default.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/helpers/composeSignals.js
var composeSignals = (signals, timeout) => {
  const { length } = signals = signals ? signals.filter(Boolean) : [];
  if (timeout || length) {
    let controller = new AbortController();
    let aborted;
    const onabort = function(reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof AxiosError_default ? err : new CanceledError_default(err instanceof Error ? err.message : err));
      }
    };
    let timer = timeout && setTimeout(() => {
      timer = null;
      onabort(new AxiosError_default(`timeout ${timeout} of ms exceeded`, AxiosError_default.ETIMEDOUT));
    }, timeout);
    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach((signal2) => {
          signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
        });
        signals = null;
      }
    };
    signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
    const { signal } = controller;
    signal.unsubscribe = () => utils_default.asap(unsubscribe);
    return signal;
  }
};
var composeSignals_default = composeSignals;

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/helpers/trackStream.js
var streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end;
  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};
var readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
};
var readStream = async function* (stream) {
  if (stream[Symbol.asyncIterator]) {
    yield* stream;
    return;
  }
  const reader = stream.getReader();
  try {
    for (; ; ) {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
};
var trackStream = (stream, chunkSize, onProgress, onFinish) => {
  const iterator2 = readBytes(stream, chunkSize);
  let bytes = 0;
  let done;
  let _onFinish = (e) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e);
    }
  };
  return new ReadableStream({
    async pull(controller) {
      try {
        const { done: done2, value } = await iterator2.next();
        if (done2) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator2.return();
    }
  }, {
    highWaterMark: 2
  });
};

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/adapters/fetch.js
var isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
var isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
var encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
var test = (fn, ...args) => {
  try {
    return !!fn(...args);
  } catch (e) {
    return false;
  }
};
var supportsRequestStream = isReadableStreamSupported && test(() => {
  let duplexAccessed = false;
  const hasContentType = new Request(platform_default.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      duplexAccessed = true;
      return "half";
    }
  }).headers.has("Content-Type");
  return duplexAccessed && !hasContentType;
});
var DEFAULT_CHUNK_SIZE = 64 * 1024;
var supportsResponseStream = isReadableStreamSupported && test(() => utils_default.isReadableStream(new Response("").body));
var resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};
isFetchSupported && ((res) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
    !resolvers[type] && (resolvers[type] = utils_default.isFunction(res[type]) ? (res2) => res2[type]() : (_, config) => {
      throw new AxiosError_default(`Response type '${type}' is not supported`, AxiosError_default.ERR_NOT_SUPPORT, config);
    });
  });
})(new Response());
var getBodyLength = async (body) => {
  if (body == null) {
    return 0;
  }
  if (utils_default.isBlob(body)) {
    return body.size;
  }
  if (utils_default.isSpecCompliantForm(body)) {
    const _request = new Request(platform_default.origin, {
      method: "POST",
      body
    });
    return (await _request.arrayBuffer()).byteLength;
  }
  if (utils_default.isArrayBufferView(body) || utils_default.isArrayBuffer(body)) {
    return body.byteLength;
  }
  if (utils_default.isURLSearchParams(body)) {
    body = body + "";
  }
  if (utils_default.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
};
var resolveBodyLength = async (headers, body) => {
  const length = utils_default.toFiniteNumber(headers.getContentLength());
  return length == null ? getBodyLength(body) : length;
};
var fetch_default = isFetchSupported && (async (config) => {
  let {
    url,
    method,
    data,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = "same-origin",
    fetchOptions
  } = resolveConfig_default(config);
  responseType = responseType ? (responseType + "").toLowerCase() : "text";
  let composedSignal = composeSignals_default([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
  let request;
  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
    composedSignal.unsubscribe();
  });
  let requestContentLength;
  try {
    if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
      let _request = new Request(url, {
        method: "POST",
        body: data,
        duplex: "half"
      });
      let contentTypeHeader;
      if (utils_default.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
        headers.setContentType(contentTypeHeader);
      }
      if (_request.body) {
        const [onProgress, flush] = progressEventDecorator(
          requestContentLength,
          progressEventReducer(asyncDecorator(onUploadProgress))
        );
        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
      }
    }
    if (!utils_default.isString(withCredentials)) {
      withCredentials = withCredentials ? "include" : "omit";
    }
    const isCredentialsSupported = "credentials" in Request.prototype;
    request = new Request(url, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data,
      duplex: "half",
      credentials: isCredentialsSupported ? withCredentials : void 0
    });
    let response = await fetch(request, fetchOptions);
    const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
    if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
      const options = {};
      ["status", "statusText", "headers"].forEach((prop) => {
        options[prop] = response[prop];
      });
      const responseContentLength = utils_default.toFiniteNumber(response.headers.get("content-length"));
      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
        responseContentLength,
        progressEventReducer(asyncDecorator(onDownloadProgress), true)
      ) || [];
      response = new Response(
        trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
          flush && flush();
          unsubscribe && unsubscribe();
        }),
        options
      );
    }
    responseType = responseType || "text";
    let responseData = await resolvers[utils_default.findKey(resolvers, responseType) || "text"](response, config);
    !isStreamResponse && unsubscribe && unsubscribe();
    return await new Promise((resolve, reject) => {
      settle(resolve, reject, {
        data: responseData,
        headers: AxiosHeaders_default.from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config,
        request
      });
    });
  } catch (err) {
    unsubscribe && unsubscribe();
    if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
      throw Object.assign(
        new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request),
        {
          cause: err.cause || err
        }
      );
    }
    throw AxiosError_default.from(err, err && err.code, config, request);
  }
});

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/adapters/adapters.js
var knownAdapters = {
  http: null_default,
  xhr: xhr_default,
  fetch: fetch_default
};
utils_default.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
var renderReason = (reason) => `- ${reason}`;
var isResolvedHandle = (adapter) => utils_default.isFunction(adapter) || adapter === null || adapter === false;
var adapters_default = {
  getAdapter: (adapters) => {
    adapters = utils_default.isArray(adapters) ? adapters : [adapters];
    const { length } = adapters;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters[i];
      let id;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError_default(`Unknown adapter '${id}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id || "#" + i] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError_default(
        `There is no suitable adapter to dispatch the request ` + s,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  },
  adapters: knownAdapters
};

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError_default(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders_default.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters_default.getAdapter(config.adapter || defaults_default.adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders_default.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/env/data.js
var VERSION = "1.11.0";

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/helpers/validator.js
var validators = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
  validators[type] = function validator(thing) {
    return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError_default(
        formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
        AxiosError_default.ERR_DEPRECATED
      );
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version + " and will be removed in the near future"
        )
      );
    }
    return validator ? validator(value, opt, opts) : true;
  };
};
validators.spelling = function spelling(correctSpelling) {
  return (value, opt) => {
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === void 0 || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
    }
  }
}
var validator_default = {
  assertOptions,
  validators
};

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/core/Axios.js
var validators2 = validator_default.validators;
var Axios = class {
  constructor(instanceConfig) {
    this.defaults = instanceConfig || {};
    this.interceptors = {
      request: new InterceptorManager_default(),
      response: new InterceptorManager_default()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy = {};
        Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err.stack) {
            err.stack = stack;
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
            err.stack += "\n" + stack;
          }
        } catch (e) {
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== void 0) {
      validator_default.assertOptions(transitional2, {
        silentJSONParsing: validators2.transitional(validators2.boolean),
        forcedJSONParsing: validators2.transitional(validators2.boolean),
        clarifyTimeoutError: validators2.transitional(validators2.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils_default.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator_default.assertOptions(paramsSerializer, {
          encode: validators2.function,
          serialize: validators2.function
        }, true);
      }
    }
    if (config.allowAbsoluteUrls !== void 0) {
    } else if (this.defaults.allowAbsoluteUrls !== void 0) {
      config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
    } else {
      config.allowAbsoluteUrls = true;
    }
    validator_default.assertOptions(config, {
      baseUrl: validators2.spelling("baseURL"),
      withXsrfToken: validators2.spelling("withXSRFToken")
    }, true);
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils_default.merge(
      headers.common,
      headers[config.method]
    );
    headers && utils_default.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config.headers = AxiosHeaders_default.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift(...requestInterceptorChain);
      chain.push(...responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
};
utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_default = Axios;

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/cancel/CancelToken.js
var CancelToken = class _CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners) return;
      let i = token._listeners.length;
      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError_default(message, config, request);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  toAbortSignal() {
    const controller = new AbortController();
    const abort = (err) => {
      controller.abort(err);
    };
    this.subscribe(abort);
    controller.signal.unsubscribe = () => this.unsubscribe(abort);
    return controller.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new _CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
};
var CancelToken_default = CancelToken;

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/helpers/spread.js
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/helpers/isAxiosError.js
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === true;
}

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/helpers/HttpStatusCode.js
var HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
var HttpStatusCode_default = HttpStatusCode;

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/axios.js
function createInstance(defaultConfig) {
  const context = new Axios_default(defaultConfig);
  const instance = bind(Axios_default.prototype.request, context);
  utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
  utils_default.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios = createInstance(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders_default;
axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters_default.getAdapter;
axios.HttpStatusCode = HttpStatusCode_default;
axios.default = axios;
var axios_default = axios;

// node_modules/.pnpm/axios@1.11.0/node_modules/axios/index.js
var {
  Axios: Axios2,
  AxiosError: AxiosError2,
  CanceledError: CanceledError2,
  isCancel: isCancel2,
  CancelToken: CancelToken2,
  VERSION: VERSION2,
  all: all2,
  Cancel,
  isAxiosError: isAxiosError2,
  spread: spread2,
  toFormData: toFormData2,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode: HttpStatusCode2,
  formToJSON,
  getAdapter,
  mergeConfig: mergeConfig2
} = axios_default;

// src/storage/storage.ts
var APP_URL = "app-url";
var CONTEXT_IDENTITY = "context-identity";
var ACCESS_TOKEN = "access-token";
var CONTEXT_ID = "context-id";
var REFRESH_TOKEN = "refresh-token";
var APPLICATION_ID = "application-id";
var setAppEndpointKey = (url) => {
  localStorage.setItem(APP_URL, JSON.stringify(url));
};
var getAppEndpointKey = () => {
  try {
    if (typeof window !== "undefined" && window.localStorage) {
      const urlEndpoint = localStorage.getItem(APP_URL);
      return urlEndpoint ? JSON.parse(urlEndpoint) : null;
    }
  } catch (e) {
    console.error(e);
  }
  return null;
};
var clearAppEndpoint = () => {
  localStorage.removeItem(APP_URL);
};
var setApplicationId = (applicationId) => {
  localStorage.setItem(APPLICATION_ID, JSON.stringify(applicationId));
};
var getApplicationId = () => {
  try {
    if (typeof window !== "undefined" && window.localStorage) {
      const applicationId = localStorage.getItem(APPLICATION_ID);
      return applicationId ? JSON.parse(applicationId) : null;
    }
  } catch (e) {
    console.error(e);
  }
  return null;
};
var clearApplicationId = () => {
  localStorage.removeItem(APPLICATION_ID);
};
var setContextAndIdentityFromJWT = (accessToken) => {
  try {
    const parts = accessToken.split(".");
    if (parts.length !== 3) {
      console.error("Invalid JWT token format received:", accessToken);
      throw new Error("Invalid JWT token format");
    }
    const payloadString = atob(parts[1]);
    const jwt = JSON.parse(payloadString);
    if (jwt.permissions) {
      const contextPermission = jwt.permissions.find(
        (permission) => permission.startsWith("context[") && permission.endsWith("]")
      );
      if (contextPermission) {
        const content = contextPermission.substring(
          contextPermission.indexOf("[") + 1,
          contextPermission.lastIndexOf("]")
        );
        const [contextId, contextIdentity] = content.split(",");
        if (contextId && contextIdentity) {
          setContextId(contextId);
          setExecutorPublicKey(contextIdentity);
        } else {
          console.warn(
            "Failed to extract context_id or context_identity from permissions"
          );
        }
      } else {
        console.warn("No context permission found in JWT token");
      }
    } else {
      console.warn("JWT payload missing permissions field");
    }
  } catch (error) {
    console.error("Failed to set access token or extract JWT info:", error);
  }
};
var setAccessToken = (accessToken) => {
  localStorage.setItem(ACCESS_TOKEN, JSON.stringify(accessToken));
};
var getAccessToken = () => {
  try {
    if (typeof window !== "undefined" && window.localStorage) {
      const accessToken = localStorage.getItem(ACCESS_TOKEN);
      return accessToken ? JSON.parse(accessToken) : null;
    }
  } catch (e) {
    console.error(e);
  }
  return null;
};
var clearAccessToken = () => {
  localStorage.removeItem(ACCESS_TOKEN);
  localStorage.removeItem(REFRESH_TOKEN);
};
var setContextId = (contextId) => {
  localStorage.setItem(CONTEXT_ID, JSON.stringify(contextId));
};
var getContextId = () => {
  try {
    if (typeof window !== "undefined" && window.localStorage) {
      const contextId = localStorage.getItem(CONTEXT_ID);
      return contextId ? JSON.parse(contextId) : null;
    }
  } catch (e) {
    console.error(e);
  }
  return null;
};
var clearContextId = () => {
  localStorage.removeItem(CONTEXT_ID);
};
var setRefreshToken = (refreshToken) => {
  localStorage.setItem(REFRESH_TOKEN, JSON.stringify(refreshToken));
};
var getRefreshToken = () => {
  try {
    if (typeof window !== "undefined" && window.localStorage) {
      const refreshToken = localStorage.getItem(REFRESH_TOKEN);
      return refreshToken ? JSON.parse(refreshToken) : null;
    }
  } catch (e) {
    console.error(e);
  }
  return null;
};
var clearRefreshToken = () => {
  localStorage.removeItem(REFRESH_TOKEN);
};
var setExecutorPublicKey = (publicKey) => {
  localStorage.setItem(CONTEXT_IDENTITY, JSON.stringify(publicKey));
};
var getExecutorPublicKey = () => {
  try {
    if (typeof window !== "undefined" && window.localStorage) {
      let contextIdentity = localStorage.getItem(CONTEXT_IDENTITY);
      return contextIdentity ? JSON.parse(contextIdentity) : null;
    }
    return null;
  } catch (e) {
    console.error(e);
  }
  return null;
};
var clearExecutorPublicKey = () => {
  localStorage.removeItem(CONTEXT_IDENTITY);
};
var getJWTObject = () => {
  try {
    const token = getAccessToken();
    if (!token) return null;
    const parts = token.split(".");
    if (parts.length !== 3) {
      throw new Error("Invalid JWT token");
    }
    const payload = JSON.parse(atob(parts[1]));
    return payload;
  } catch (e) {
    console.error(e);
  }
  return null;
};
var clientLogout = () => {
  clearAccessToken();
  clearApplicationId();
  clearContextId();
  clearExecutorPublicKey();
  window.location.reload();
};
var createErrorResponse = (error) => ({
  appEndpointKey: null,
  contextId: null,
  executorPublicKey: null,
  jwtToken: null,
  error
});
var getAuthConfig = () => {
  const config = {
    appEndpointKey: getAppEndpointKey(),
    contextId: getContextId(),
    executorPublicKey: getExecutorPublicKey(),
    jwtToken: getAccessToken(),
    error: null
  };
  if (!config.appEndpointKey) {
    return createErrorResponse("Missing app endpoint key");
  }
  const hasJwtToken = !!config.jwtToken;
  const hasContextId = !!config.contextId;
  const hasExecutorPublicKey = !!config.executorPublicKey;
  if (!hasJwtToken && !(hasContextId && hasExecutorPublicKey)) {
    return createErrorResponse(
      "Missing authentication information. Either JWT token or both context ID and executor public key must be present."
    );
  }
  return config;
};

// src/api/httpClient.ts
var AxiosHttpClient = class {
  constructor(axios2) {
    __publicField(this, "axios");
    __publicField(this, "isRefreshing", false);
    __publicField(this, "failedQueue", []);
    this.axios = axios2;
  }
  isRefreshRequest(config) {
    const baseUrl = getAppEndpointKey();
    return config?.url === `${baseUrl}/public/refresh`;
  }
  processQueue(error, token = null) {
    const uniqueRequests = this.failedQueue.filter(
      (promise) => !this.isRefreshRequest(promise.config)
    );
    uniqueRequests.forEach((promise) => {
      if (error) {
        promise.reject(error);
      } else {
        if (token) {
          promise.config.headers.Authorization = `Bearer ${token}`;
        }
        promise.resolve(this.request(this.axios.request(promise.config)));
      }
    });
    this.failedQueue = [];
  }
  async handleTokenRefresh(originalRequest) {
    if (this.isRefreshing) {
      if (this.isRefreshRequest(originalRequest)) {
        return Promise.reject(new Error("Token refresh already in progress"));
      }
      return new Promise((resolve, reject) => {
        this.failedQueue.push({
          resolve,
          reject,
          config: originalRequest
        });
      });
    }
    try {
      this.isRefreshing = true;
      const refreshToken = getRefreshToken();
      const accessToken = getAccessToken();
      if (!refreshToken || !accessToken) {
        throw new Error("Missing tokens for refresh");
      }
      const response = await authClient.refreshToken({
        access_token: accessToken,
        refresh_token: refreshToken
      });
      if (response.error || !response.data) {
        throw new Error("Failed to refresh token");
      }
      setAccessToken(response.data.access_token);
      setRefreshToken(response.data.refresh_token);
      originalRequest.headers.Authorization = `Bearer ${response.data.access_token}`;
      this.processQueue(null, response.data.access_token);
      this.isRefreshing = false;
      return this.request(this.axios.request(originalRequest));
    } catch (error) {
      this.isRefreshing = false;
      this.processQueue(new Error("Failed to refresh token"));
      clearAccessToken();
      throw error;
    }
  }
  async request(promise, isJsonRpc = false, responseType) {
    try {
      const response = await promise;
      if (response?.config?.method?.toUpperCase() === "HEAD") {
        const headers = {};
        if (response.headers) {
          Object.entries(response.headers).forEach(([key, value]) => {
            if (value !== void 0) {
              headers[key] = Array.isArray(value) ? value.join(", ") : String(value);
            }
          });
        }
        const headResponse = {
          headers,
          status: response.status
        };
        return {
          data: headResponse,
          error: null
        };
      }
      if (responseType === "arraybuffer" || responseType === "blob") {
        return {
          data: response.data,
          error: null
        };
      }
      const responseData = isJsonRpc ? response.data : response.data.data;
      return {
        data: responseData,
        error: null
      };
    } catch (e) {
      if (e instanceof AxiosError2) {
        const status = e.response?.status;
        const headers = e.response?.headers;
        const body = e.response?.data;
        if (status === 401) {
          const authError = headers?.["x-auth-error"];
          switch (authError) {
            case "missing_token":
              return {
                data: null,
                error: {
                  code: 401,
                  message: "No access token found."
                }
              };
            case "token_expired":
              try {
                return await this.handleTokenRefresh(e.config);
              } catch (refreshError) {
                clearAccessToken();
                return {
                  data: null,
                  error: {
                    code: 401,
                    message: "Session expired. Please log in again."
                  }
                };
              }
            case "token_revoked":
              clientLogout();
              return {
                data: null,
                error: {
                  code: 401,
                  message: "Session was revoked. Please log in again."
                }
              };
            case "invalid_token":
              clientLogout();
              return {
                data: null,
                error: {
                  code: 401,
                  message: "Invalid authentication. Please log in again."
                }
              };
            default:
              return {
                data: null,
                error: {
                  code: 401,
                  message: body.error
                }
              };
          }
        }
        if (e?.config?.method?.toUpperCase() === "HEAD") {
          return {
            data: null,
            error: {
              code: e.request.status,
              message: e.message
            }
          };
        }
        const error = e.response?.data.error ?? e.response?.data;
        if (!error) {
          return {
            data: null,
            error: {
              code: status ?? 500,
              message: e.message || "Something went wrong"
            }
          };
        }
        if (typeof error === "string") {
          return {
            data: null,
            error: {
              code: status ?? 500,
              message: error
            }
          };
        }
        return {
          data: null,
          error: {
            code: status ?? error.code ?? 500,
            message: error.message
          }
        };
      }
      return {
        data: null,
        error: GENERIC_ERROR
      };
    }
  }
  getAuthHeaders() {
    const token = getAccessToken();
    return token ? { Authorization: `Bearer ${token}` } : {};
  }
  async get(url, headers, isJsonRpc = false, options) {
    const authHeaders = this.getAuthHeaders();
    const mergedHeaders = headers?.reduce(
      (acc, curr) => ({ ...acc, ...curr }),
      {}
    );
    return this.request(
      this.axios.get(url, {
        headers: { ...authHeaders, ...mergedHeaders },
        responseType: options?.responseType
      }),
      isJsonRpc,
      options?.responseType
    );
  }
  async post(url, body, headers, isJsonRpc = false) {
    const authHeaders = this.getAuthHeaders();
    const mergedHeaders = headers?.reduce(
      (acc, curr) => ({ ...acc, ...curr }),
      {}
    );
    return this.request(
      this.axios.post(url, body, {
        headers: { ...authHeaders, ...mergedHeaders }
      }),
      isJsonRpc
    );
  }
  async put(url, body, headers, isJsonRpc = false, onUploadProgress) {
    const authHeaders = this.getAuthHeaders();
    const mergedHeaders = headers?.reduce(
      (acc, curr) => ({ ...acc, ...curr }),
      {}
    );
    const config = {
      headers: { ...authHeaders, ...mergedHeaders }
    };
    if (onUploadProgress) {
      config.onUploadProgress = (progressEvent) => {
        if (progressEvent.lengthComputable) {
          const progress = progressEvent.loaded / progressEvent.total * 100;
          onUploadProgress(progress);
        }
      };
    }
    return this.request(this.axios.put(url, body, config), isJsonRpc);
  }
  async delete(url, headers, isJsonRpc = false) {
    const authHeaders = this.getAuthHeaders();
    const mergedHeaders = headers?.reduce(
      (acc, curr) => ({ ...acc, ...curr }),
      {}
    );
    return this.request(
      this.axios.delete(url, {
        headers: { ...authHeaders, ...mergedHeaders }
      }),
      isJsonRpc
    );
  }
  async patch(url, body, headers, isJsonRpc = false) {
    const authHeaders = this.getAuthHeaders();
    const mergedHeaders = headers?.reduce(
      (acc, curr) => ({ ...acc, ...curr }),
      {}
    );
    return this.request(
      this.axios.patch(url, body, {
        headers: { ...authHeaders, ...mergedHeaders }
      }),
      isJsonRpc
    );
  }
  async head(url, headers) {
    const authHeaders = this.getAuthHeaders();
    const mergedHeaders = headers?.reduce(
      (acc, curr) => ({ ...acc, ...curr }),
      {}
    );
    return this.request(
      this.axios.head(url, {
        headers: { ...authHeaders, ...mergedHeaders }
      })
    );
  }
  // Expose refresh mechanism for RPC error handling
  async refreshTokens() {
    const refreshToken = getRefreshToken();
    const accessToken = getAccessToken();
    if (!refreshToken || !accessToken) {
      return { error: { code: 401, message: "Missing tokens for refresh" } };
    }
    const response = await authClient.refreshToken({
      access_token: accessToken,
      refresh_token: refreshToken
    });
    if (response.data) {
      setAccessToken(response.data.access_token);
      setRefreshToken(response.data.refresh_token);
    }
    return response;
  }
};
var GENERIC_ERROR = {
  code: 500,
  message: "Something went wrong"
};

// src/api/dataSource/NodeApiDataSource.ts
var NodeApiDataSource = class {
  constructor(client) {
    this.client = client;
  }
  get baseUrl() {
    return getAppEndpointKey();
  }
  async health(request) {
    return await this.client.get(
      `${request.url}/admin-api/health`
    );
  }
  async getContext(contextId) {
    try {
      return this.client.get(
        `${this.baseUrl}/admin-api/contexts/${contextId}`
      );
    } catch (error) {
      console.error("Error fetching context:", error);
      return {
        data: null,
        error: { code: 500, message: "Failed to fetch context data." }
      };
    }
  }
  async getContexts() {
    try {
      const response = await this.client.get(
        `${this.baseUrl}/admin-api/contexts`
      );
      return response;
    } catch (error) {
      console.error("Error fetching contexts:", error);
      return { error: { code: 500, message: "Failed to fetch context data." } };
    }
  }
  async createContext(applicationId, jsonParams, protocol) {
    const initializationParams = jsonParams === "" ? [] : Array.from(new TextEncoder().encode(jsonParams));
    try {
      const response = await this.client.post(
        `${this.baseUrl}/admin-api/contexts`,
        {
          applicationId,
          initializationParams,
          protocol
        }
      );
      return response;
    } catch (error) {
      console.error("Error starting contexts:", error);
      return { error: { code: 500, message: "Failed to start context." } };
    }
  }
  async deleteContext(contextId) {
    try {
      const response = await this.client.delete(
        `${this.baseUrl}/admin-api/contexts/${contextId}`
      );
      return response;
    } catch (error) {
      console.error("Error deleting context:", error);
      return { error: { code: 500, message: "Failed to delete context." } };
    }
  }
  async fetchContextIdentities(contextId) {
    try {
      const response = await this.client.get(
        `${this.baseUrl}/admin-api/contexts/${contextId}/identities-owned`
      );
      return response;
    } catch (error) {
      console.error("Error deleting context:", error);
      return { error: { code: 500, message: "Failed to delete context." } };
    }
  }
  async createNewIdentity() {
    try {
      const response = await this.client.post(
        `${this.baseUrl}/admin-api/identity/context`
      );
      return response;
    } catch (error) {
      console.error("Error creating new identity:", error);
      return {
        error: { code: 500, message: "Failed to create new identity." }
      };
    }
  }
  async contextInvite(contextId, inviterPublicKey, inviteePublicKey) {
    try {
      const response = await this.client.post(
        `${this.baseUrl}/admin-api/contexts/invite`,
        {
          contextId,
          inviterId: inviterPublicKey,
          inviteeId: inviteePublicKey
        }
      );
      return response;
    } catch (error) {
      console.error("Error inviting to context:", error);
      return { error: { code: 500, message: "Failed to invite to context." } };
    }
  }
  async joinContext(invitationPayload) {
    try {
      const response = await this.client.post(
        `${this.baseUrl}/admin-api/contexts/join`,
        {
          invitationPayload
        }
      );
      return response;
    } catch (error) {
      console.error("Error joining context:", error);
      return { error: { code: 500, message: "Failed to join context." } };
    }
  }
  // Application Management
  async getInstalledApplications() {
    try {
      const response = await this.client.get(
        `${this.baseUrl}/admin-api/applications`
      );
      return response;
    } catch (error) {
      console.error("Error fetching installed applications:", error);
      return {
        error: {
          code: 500,
          message: "Failed to fetch installed applications."
        }
      };
    }
  }
  async getInstalledApplicationDetails(appId) {
    try {
      const response = await this.client.get(
        `${this.baseUrl}/admin-api/applications/${appId}`
      );
      return response;
    } catch (error) {
      console.error("Error fetching application details:", error);
      return {
        error: { code: 500, message: "Failed to fetch application details." }
      };
    }
  }
  async installApplication(url, metadata, hash) {
    try {
      const requestBody = {
        url,
        metadata: metadata ? Array.from(metadata) : [],
        ...hash ? { hash } : {}
      };
      const response = await this.client.post(
        `${this.baseUrl}/admin-api/install-application`,
        requestBody
      );
      return response;
    } catch (error) {
      console.error("Error installing application:", error);
      return {
        error: { code: 500, message: "Failed to install application." }
      };
    }
  }
  async uninstallApplication(applicationId) {
    try {
      const response = await this.client.delete(
        `${this.baseUrl}/admin-api/applications/${applicationId}`
      );
      return response;
    } catch (error) {
      console.error("Error uninstalling application:", error);
      return {
        error: { code: 500, message: "Failed to uninstall application." }
      };
    }
  }
  // Context Management Extended
  async getContextClientKeys(contextId) {
    try {
      const response = await this.client.get(
        `${this.baseUrl}/admin-api/contexts/${contextId}/client-keys`
      );
      return response;
    } catch (error) {
      console.error("Error fetching context client keys:", error);
      return {
        error: { code: 500, message: "Failed to fetch context client keys." }
      };
    }
  }
  async getContextUsers(contextId) {
    try {
      const response = await this.client.get(
        `${this.baseUrl}/admin-api/contexts/${contextId}/identities`
      );
      return response;
    } catch (error) {
      console.error("Error fetching context users:", error);
      return {
        error: { code: 500, message: "Failed to fetch context users." }
      };
    }
  }
  async getContextStorageUsage(contextId) {
    try {
      const response = await this.client.get(
        `${this.baseUrl}/admin-api/contexts/${contextId}/storage`
      );
      return response;
    } catch (error) {
      console.error("Error fetching context storage usage:", error);
      return {
        error: { code: 500, message: "Failed to fetch context storage usage." }
      };
    }
  }
  async grantCapabilities(contextId, request) {
    try {
      const response = await this.client.post(
        `${this.baseUrl}/admin-api/contexts/${contextId}/capabilities/grant`,
        request
      );
      return response;
    } catch (error) {
      console.error("Error granting capabilities:", error);
      return { error: { code: 500, message: "Failed to grant capabilities." } };
    }
  }
  async revokeCapabilities(contextId, request) {
    try {
      const response = await this.client.post(
        `${this.baseUrl}/admin-api/contexts/${contextId}/capabilities/revoke`,
        request
      );
      return response;
    } catch (error) {
      console.error("Error revoking capabilities:", error);
      return {
        error: { code: 500, message: "Failed to revoke capabilities." }
      };
    }
  }
  async checkAuth() {
    const response = await this.client.get(
      `${this.baseUrl}/admin-api/is-authed`
    );
    return response;
  }
};

// src/api/dataSource/AuthApiDataSource.ts
var AuthApiDataSource = class {
  constructor(client) {
    this.client = client;
  }
  get baseUrl() {
    return getAppEndpointKey();
  }
  async login(request) {
    try {
      window.location.href = `${request.url}/auth/login?callback-url=${encodeURIComponent(request.callbackUrl)}&permissions=${encodeURIComponent(request.permissions.join(","))}&${APPLICATION_ID}=${encodeURIComponent(request.applicationId)}&application-path=${encodeURIComponent(request.applicationPath)}&${APP_URL}=${encodeURIComponent(this.baseUrl)}`;
      return { data: null };
    } catch (error) {
      console.error("Error during login redirect:", error);
      return {
        error: {
          code: 500,
          message: "Login redirect failed. Please try again."
        }
      };
    }
  }
  async refreshToken(request) {
    try {
      const response = await this.client.post(
        `${this.baseUrl}/auth/refresh`,
        request
      );
      return response;
    } catch (error) {
      console.error("Error refreshing token:", error);
      return {
        error: {
          code: 500,
          message: "Token refresh failed. Please try again."
        }
      };
    }
  }
  async getProviders() {
    try {
      const response = await this.client.get(
        `${this.baseUrl}/auth/providers`
      );
      return response;
    } catch (error) {
      console.error("Error getting providers:", error);
      return { error: { code: 500, message: "Failed to get providers." } };
    }
  }
  async requestToken(requestBody) {
    try {
      const response = await this.client.post(
        `${this.baseUrl}/auth/token`,
        requestBody
      );
      return response;
    } catch (error) {
      console.error("Error requesting token:", error);
      return {
        error: {
          code: 500,
          message: "Token request failed. Please try again."
        }
      };
    }
  }
  async getChallenge() {
    try {
      const response = await this.client.get(
        `${this.baseUrl}/auth/challenge`
      );
      return response;
    } catch (error) {
      console.error("Error getting challenge:", error);
      return { error: { code: 500, message: "Failed to get challenge." } };
    }
  }
  async generateClientKey(request) {
    try {
      const response = await this.client.post(
        `${this.baseUrl}/admin/client-key`,
        request
      );
      return response;
    } catch (error) {
      console.error("Error generating client key:", error);
      return {
        error: { code: 500, message: "Failed to generate client key." }
      };
    }
  }
};

// src/api/dataSource/ContractApiDataSource.ts
var ContractApiDataSource = class {
  constructor(client) {
    this.client = client;
  }
  get baseUrl() {
    return getAppEndpointKey();
  }
  get contextId() {
    const id = getContextId();
    if (!id) {
      throw new Error(
        "Context ID not available. Make sure you are properly authenticated."
      );
    }
    return id;
  }
  async getProposals(request) {
    try {
      return await this.client.post(
        `${this.baseUrl}/admin-api/contexts/${this.contextId}/proposals`,
        request
      );
    } catch (error) {
      return {
        data: null,
        error
      };
    }
  }
  async getProposalApprovers(proposalId) {
    try {
      return await this.client.get(
        `${this.baseUrl}/admin-api/contexts/${this.contextId}/proposals/${proposalId}/approvals/users`
      );
    } catch (error) {
      return {
        data: null,
        error
      };
    }
  }
  async getProposalApprovalCount(proposalId) {
    try {
      return await this.client.get(
        `${this.baseUrl}/admin-api/contexts/${this.contextId}/proposals/${proposalId}/approvals/count`
      );
    } catch (error) {
      return {
        data: null,
        error
      };
    }
  }
  async getNumOfProposals() {
    try {
      return await this.client.get(
        `${this.baseUrl}/admin-api/contexts/${this.contextId}/proposals/count`
      );
    } catch (error) {
      return {
        data: null,
        error
      };
    }
  }
  async getProposalDetails(proposalId) {
    try {
      return await this.client.get(
        `${this.baseUrl}/admin-api/contexts/${this.contextId}/proposals/${proposalId}`
      );
    } catch (error) {
      return {
        data: null,
        error
      };
    }
  }
  async getContextValue(key) {
    try {
      return await this.client.post(
        `${this.baseUrl}/admin-api/contexts/${this.contextId}`,
        {
          key
        }
      );
    } catch (error) {
      return {
        data: null,
        error
      };
    }
  }
  async getContextStorageEntries(offset, limit) {
    try {
      return await this.client.post(
        `${this.baseUrl}/admin-api/contexts/${this.contextId}/proposals/context-storage-entries`,
        {
          offset,
          limit
        }
      );
    } catch (error) {
      return {
        data: null,
        error
      };
    }
  }
};

// src/rpc/jsonrpc.ts
var errorTypes = [
  "UnknownServerError",
  "RpcExecutionError",
  "FunctionCallError",
  "CallError",
  "MissmatchedRequestIdError",
  "InvalidRequestError",
  "ParseError"
];
var JsonRpcClient = class {
  constructor(httpClient) {
    __publicField(this, "path", "/jsonrpc");
    __publicField(this, "httpClient");
    this.httpClient = httpClient;
  }
  handleRpcError(error) {
    if (error.code === 401) {
      const authError = error.headers?.["x-auth-error"];
      switch (authError) {
        case "token_expired":
          return {
            ...error,
            error: {
              name: "AuthenticationError",
              cause: {
                name: "AuthenticationError",
                info: {
                  message: "Token expired. Please try again."
                }
              }
            }
          };
        case "token_revoked":
          return {
            ...error,
            error: {
              name: "AuthenticationError",
              cause: {
                name: "AuthenticationError",
                info: {
                  message: "Your session was revoked. Please log in again."
                }
              }
            }
          };
        case "invalid_token":
          return {
            ...error,
            error: {
              name: "AuthenticationError",
              cause: {
                name: "AuthenticationError",
                info: {
                  message: "Invalid authentication. Please log in again."
                }
              }
            }
          };
        default:
          return {
            ...error,
            error: {
              name: "AuthenticationError",
              cause: {
                name: "AuthenticationError",
                info: {
                  message: "Authentication required. Please log in."
                }
              }
            }
          };
      }
    }
    const errorType = error?.error?.name;
    if (errorTypes.includes(errorType)) {
      return error;
    }
    return {
      ...error,
      error: {
        name: "UnknownServerError",
        cause: {
          name: "UnknownServerError",
          info: {
            message: "Server Error: Something went wrong. Please try again."
          }
        }
      }
    };
  }
  /**
   * @function execute
   * @description Executes a JSON RPC request - query or mutate.
   * @param {RpcQueryParams<Args>} params - The parameters for the JSON RPC request.
   * @param {RequestConfig} config - The configuration for the JSON RPC request.
   * @returns {Promise<RpcResult<RpcQueryResponse<Output>>>} The result of the JSON RPC request.
   */
  async execute(params, config) {
    return await this.request(
      "execute",
      params,
      config
    );
  }
  async request(method, params, config) {
    const requestId = this.getRandomRequestId();
    const data = {
      jsonrpc: "2.0",
      id: requestId,
      method,
      params
    };
    const baseUrl = getAppEndpointKey();
    try {
      const response = await this.httpClient.post(
        `${baseUrl}${this.path}`,
        data,
        config?.headers ? [config.headers] : void 0,
        true
        // Set isJsonRpc flag to true
      );
      if (!response.error) {
        const jsonRpcResponse = response.data;
        if (jsonRpcResponse.id !== requestId) {
          const error = {
            code: 400,
            id: jsonRpcResponse.id,
            jsonrpc: jsonRpcResponse.jsonrpc,
            headers: {},
            error: {
              name: "MissmatchedRequestIdError",
              cause: {
                name: "MissmatchedRequestIdError",
                info: {
                  message: `Missmatched RequestId expected ${requestId}, got ${jsonRpcResponse.id}`
                }
              }
            }
          };
          return { error: this.handleRpcError(error) };
        }
        if (jsonRpcResponse.error) {
          let messageData = jsonRpcResponse.error.data;
          let errorMessage = "";
          if (typeof messageData === "string") {
            errorMessage = messageData;
          } else {
            errorMessage = messageData.type;
          }
          const error = {
            code: 400,
            id: jsonRpcResponse.id,
            jsonrpc: jsonRpcResponse.jsonrpc,
            headers: {},
            error: {
              name: jsonRpcResponse.error.type,
              cause: {
                name: jsonRpcResponse.error.data?.type ?? jsonRpcResponse.error.type,
                info: {
                  message: errorMessage
                }
              }
            }
          };
          return { error: this.handleRpcError(error) };
        }
        return {
          result: jsonRpcResponse.result
        };
      } else {
        const rpcError = {
          id: requestId,
          jsonrpc: "2.0",
          code: response.error.code ?? 500,
          headers: {},
          error: {
            name: "UnknownServerError",
            cause: {
              name: "UnknownServerError",
              info: {
                message: response.error.message ?? "Server Error: Something went wrong. Please try again."
              }
            }
          }
        };
        return { error: this.handleRpcError(rpcError) };
      }
    } catch (error) {
      const rpcError = {
        id: requestId,
        jsonrpc: "2.0",
        code: error?.response?.status ?? 500,
        headers: Object.fromEntries(
          Object.entries(error?.response?.headers || {}).map(([key, value]) => [
            key,
            String(value)
          ])
        ),
        error: {
          name: "UnknownServerError",
          cause: {
            name: "UnknownServerError",
            info: {
              message: `${error.message ?? error?.response?.data}.
 Verify that the node server is running.`
            }
          }
        }
      };
      return { error: this.handleRpcError(rpcError) };
    }
  }
  getRandomRequestId() {
    return Math.floor(Math.random() * Math.pow(2, 32));
  }
};

// src/api/dataSource/AdminApiDataSource.ts
var AdminApiDataSource = class {
  constructor(client) {
    this.client = client;
  }
  get baseUrl() {
    return getAppEndpointKey();
  }
  async getRootKeys() {
    try {
      const response = await this.client.get(
        `${this.baseUrl}/admin/keys`
      );
      return response;
    } catch (error) {
      console.error("Error fetching root keys:", error);
      return { error: { code: 500, message: "Failed to fetch root keys." } };
    }
  }
  async getClientKeys() {
    try {
      const response = await this.client.get(
        `${this.baseUrl}/admin/keys/clients`
      );
      return response;
    } catch (error) {
      console.error("Error fetching client keys:", error);
      return { error: { code: 500, message: "Failed to fetch client keys." } };
    }
  }
  async addRootKey(rootKeyRequest) {
    try {
      const response = await this.client.post(
        `${this.baseUrl}/admin/keys`,
        rootKeyRequest
      );
      return response;
    } catch (error) {
      console.error("Error adding root key:", error);
      return { error: { code: 500, message: "Failed to add root key." } };
    }
  }
  async revokeRootKey(keyId) {
    try {
      const response = await this.client.delete(
        `${this.baseUrl}/admin/keys/${keyId}`
      );
      return response;
    } catch (error) {
      console.error("Error deleting root key:", error);
      return { error: { code: 500, message: "Failed to delete root key." } };
    }
  }
  async revokeClientKey(rootKeyId, clientId) {
    try {
      const response = await this.client.delete(
        `${this.baseUrl}/admin/keys/${rootKeyId}/clients/${clientId}`
      );
      return response;
    } catch (error) {
      console.error("Error revoking client key:", error);
      return { error: { code: 500, message: "Failed to revoke client key." } };
    }
  }
  async setKeyPermissions(keyId, request) {
    try {
      const response = await this.client.put(
        `${this.baseUrl}/admin/keys/${keyId}/permissions`,
        request
      );
      return response;
    } catch (error) {
      console.error("Error updating key permissions:", error);
      return {
        error: { code: 500, message: "Failed to update key permissions." }
      };
    }
  }
};

// src/api/dataSource/BlobApiDataSource.ts
var BlobApiDataSource = class {
  constructor(client) {
    this.client = client;
  }
  get baseUrl() {
    return getAppEndpointKey();
  }
  async uploadBlob(file, onProgress, expectedHash) {
    try {
      const fileArrayBuffer = await file.arrayBuffer();
      let url = `${this.baseUrl}/admin-api/blobs`;
      const params = new URLSearchParams();
      if (expectedHash) {
        params.append("hash", expectedHash);
      }
      if (params.toString()) {
        url += `?${params.toString()}`;
      }
      const response = await this.client.put(
        url,
        fileArrayBuffer,
        [{ "Content-Type": "application/octet-stream" }],
        false,
        onProgress
      );
      if (response.error) {
        return {
          data: null,
          error: response.error
        };
      }
      const transformedResponse = {
        blobId: response.data.blob_id,
        size: response.data.size
      };
      return {
        data: transformedResponse,
        error: null
      };
    } catch (error) {
      return {
        data: null,
        error: {
          code: 500,
          message: error instanceof Error ? error.message : "Failed to upload blob"
        }
      };
    }
  }
  async downloadBlob(blobId, contextId) {
    let url = `${this.baseUrl}/admin-api/blobs/${blobId}`;
    const params = new URLSearchParams();
    params.append("context_id", contextId);
    if (params.toString()) {
      url += `?${params.toString()}`;
    }
    const response = await this.client.get(url, void 0, false, {
      responseType: "arraybuffer"
    });
    if (response.error) {
      throw new Error(
        `Failed to download blob: ${response.error.code} ${response.error.message}`
      );
    }
    return new Blob([response.data]);
  }
  async getBlobMetadata(blobId) {
    try {
      const response = await this.client.head(
        `${this.baseUrl}/admin-api/blobs/${blobId}`
      );
      if (response.error) {
        return {
          data: null,
          error: response.error
        };
      }
      const headers = response.data.headers;
      const contentLength = headers["content-length"];
      const size = contentLength ? parseInt(contentLength, 10) : 0;
      const fileType = headers["x-blob-mime-type"] || headers["content-type"] || "unknown";
      const responseBlobId = headers["x-blob-id"];
      return {
        data: {
          blobId: responseBlobId || blobId,
          size,
          fileType
        },
        error: null
      };
    } catch (error) {
      console.error("getBlobMetadata failed:", error);
      return {
        data: null,
        error: {
          code: 500,
          message: error instanceof Error ? error.message : "An unexpected error occurred"
        }
      };
    }
  }
  async listBlobs() {
    try {
      const response = await this.client.get(
        `${this.baseUrl}/admin-api/blobs`
      );
      if (response.data) {
        const transformedData = {
          blobs: response.data.blobs.map((blob) => ({
            blobId: blob.blob_id,
            size: blob.size
          }))
        };
        return {
          data: transformedData,
          error: null
        };
      }
      return {
        data: null,
        error: response.error
      };
    } catch (error) {
      console.error("listBlobs failed:", error);
      return {
        data: null,
        error: {
          code: 500,
          message: error instanceof Error ? error.message : "An unexpected error occurred"
        }
      };
    }
  }
  async deleteBlob(blobId) {
    try {
      const response = await this.client.delete(
        `${this.baseUrl}/admin-api/blobs/${blobId}`
      );
      return response;
    } catch (error) {
      console.error("deleteBlob failed:", error);
      return {
        data: null,
        error: {
          code: 500,
          message: error instanceof Error ? error.message : "An unexpected error occurred"
        }
      };
    }
  }
};

// src/api/index.ts
var ApiClient = class {
  constructor(httpClient) {
    __publicField(this, "nodeApi");
    __publicField(this, "authApi");
    __publicField(this, "contractApi");
    __publicField(this, "adminApi");
    __publicField(this, "blobApi");
    __publicField(this, "jsonRpcClient");
    this.nodeApi = new NodeApiDataSource(httpClient);
    this.authApi = new AuthApiDataSource(httpClient);
    this.contractApi = new ContractApiDataSource(httpClient);
    this.adminApi = new AdminApiDataSource(httpClient);
    this.blobApi = new BlobApiDataSource(httpClient);
    this.jsonRpcClient = new JsonRpcClient(httpClient);
  }
  node() {
    return this.nodeApi;
  }
  auth() {
    return this.authApi;
  }
  contract() {
    return this.contractApi;
  }
  admin() {
    return this.adminApi;
  }
  blob() {
    return this.blobApi;
  }
  rpc() {
    return this.jsonRpcClient;
  }
};
var apiClient = new ApiClient(new AxiosHttpClient(axios_default));
var authClient = new AuthApiDataSource(new AxiosHttpClient(axios_default));
var contractClient = new ContractApiDataSource(new AxiosHttpClient(axios_default));
var adminClient = new AdminApiDataSource(new AxiosHttpClient(axios_default));
var blobClient = new BlobApiDataSource(new AxiosHttpClient(axios_default));
var rpcClient = new JsonRpcClient(new AxiosHttpClient(axios_default));

// src/context/ContextModal.tsx
var import_react7 = __toESM(require("react"), 1);

// src/context/JoinContext.tsx
var import_react2 = __toESM(require("react"), 1);

// src/components/loader/Spinner.tsx
var import_react = __toESM(require("react"), 1);
var import_styled_components = require("styled-components");
var SpinnerContainer = import_styled_components.styled.div`
  display: flex;
  width: 100%;
  justify-content: center;
  align-items: center;
`;
var spin = import_styled_components.keyframes`
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
`;
var Svg = import_styled_components.styled.svg`
  width: 2.5rem; // equivalent to w-10
  height: 2.5rem; // equivalent to h-10
  color: #b67352;
  animation: ${spin} 1s linear infinite;
  fill: #ecb159;

  @media (prefers-color-scheme: dark) {
    color: #4b5563; // dark:text-gray-600
  }
`;
function Spinner() {
  return /* @__PURE__ */ import_react.default.createElement(SpinnerContainer, { role: "status" }, /* @__PURE__ */ import_react.default.createElement(
    Svg,
    {
      "aria-hidden": "true",
      viewBox: "0 0 100 101",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    },
    /* @__PURE__ */ import_react.default.createElement(
      "path",
      {
        d: "M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z",
        fill: "currentColor"
      }
    ),
    /* @__PURE__ */ import_react.default.createElement(
      "path",
      {
        d: "M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z",
        fill: "currentFill"
      }
    )
  ));
}

// src/context/Components.ts
var import_styled_components2 = __toESM(require("styled-components"), 1);
var ContextModalWrapper = import_styled_components2.default.div`
  width: 600px;
  max-width: 100%;
  background: #1c1c1c;
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  overflow: hidden;
`;
var Tabs = import_styled_components2.default.div`
  display: flex;
  border-bottom: 1px solid #ddd;
`;
var TabButton = import_styled_components2.default.button`
  flex: 1;
  padding: 0.75rem;
  border: none;
  background: none;
  cursor: pointer;
  font-weight: 500;
  transition: all 0.3s;

  &.active {
    border-bottom: 2px solid #ff7a00;
  }
`;
var TabContent = import_styled_components2.default.div`
  padding: 1.25rem;
`;
var FormGroup = import_styled_components2.default.div`
  margin-bottom: 1rem;
`;
var FormInput = import_styled_components2.default.input`
  width: 100%;
  padding: 0.625rem 1rem;
  border: 1px solid #ddd;
  border-radius: 0.375rem;
  font-size: 1rem;
  height: 46px;
`;
var ProtocolSelection = import_styled_components2.default.div`
  padding: 0.625rem 1rem;
  border: 1px solid #ddd;
  border-radius: 0.375rem;
  font-size: 1rem;
  height: 46px;
`;
var ErrorMessage = import_styled_components2.default.div`
  color: #ef4444;
  font-size: 0.875rem;
  margin-top: 0.5rem;
  padding: 0;
  margin: 0;
`;
var Button = import_styled_components2.default.button`
  background: #ff7a00;
  color: white;
  border: none;
  padding: 0.625rem 1rem;
  cursor: pointer;
  font-size: 1rem;
  font-weight: 500;
  transition: background 0.3s;
  height: 46px;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 0.5rem;

  &.button-rounded {
    border-radius: 0.375rem;
  }

  &.button-tab:hover {
    color: #e56e00;
  }

  &:disabled {
    background-color: #6b7280;
    cursor: not-allowed;
  }

  &.button-size-md {
    width: 150px;
  }

  &.button-static {
    width: !important 177px;
  }
`;
var ScrollableList = import_styled_components2.default.div`
  max-height: 200px;
  overflow-y: auto;
  border-radius: 4px;
  margin-top: 15px;
`;
var ListItem = import_styled_components2.default.div`
  padding: 10px;
  border-bottom: 1px solid #eee;
  font-size: 0.875rem;
  display: flex;
  align-items: center;
  justify-content: space-between;

  &:last-child {
    border-bottom: none;
  }
`;
var Heading2 = import_styled_components2.default.h2`
  margin-top: 0;
  margin-bottom: 10px;
  font-size: 18px;
`;
var Heading3 = import_styled_components2.default.h3`
  margin-top: 20px;
  margin-bottom: 10px;
`;
var Paragraph = import_styled_components2.default.p`
  margin-top: 0;
  color: #666;
  font-size: 14px;

  &.text-sm {
    font-size: 12px;
  }
`;
var FlexContainer = import_styled_components2.default.div`
  display: flex;
  align-items: center;
  gap: 2rem;
  width: 100%;
`;
var BtnStatic = import_styled_components2.default.div`
  width: 177px;
`;
var CursorPointer = import_styled_components2.default.div`
  cursor: pointer;
`;
var ContextSelector = import_styled_components2.default.div`
  display: flex;
  flex-direction: column;
  gap: 10px;
  margin-bottom: 10px;
  margin-top: 10px;
`;
var DropdownSelector = import_styled_components2.default.select`
  padding: 0.625rem 1rem;
`;
var TextSm = import_styled_components2.default.div`
  font-size: 12px;
`;
var IdentityContainer = import_styled_components2.default.div`
  position: relative;
`;
var DeleteIcon = import_styled_components2.default.div`
  position: absolute;
  right: -10px;
  top: -10px;
  cursor: pointer;
  font-size: 18px;

  &:hover {
    color: #ef4444;
  }
`;
var SuccessMessage = import_styled_components2.default.div`
  padding-right: 10px;
  white-space: pre-wrap;
  display: flex;
  flex-direction: column;
  overflow-wrap: break-word;
  padding-bottom: 10px;
`;
var Payload = import_styled_components2.default.div`
  font-size: 12px;
  color: #666;
`;

// src/context/JoinContext.tsx
var JoinContext = () => {
  const [identityPrivateKey, setIdentityPrivateKey] = (0, import_react2.useState)("");
  const [joinPayload, setJoinPayload] = (0, import_react2.useState)("");
  const [joinError, setJoinError] = (0, import_react2.useState)("");
  const [isLoading, setIsLoading] = (0, import_react2.useState)(false);
  const [isSuccess, setIsSuccess] = (0, import_react2.useState)(false);
  const handleJoinSubmit = async (e) => {
    e.preventDefault();
    setIsLoading(true);
    setJoinError("");
    setIsSuccess(false);
    const response = await apiClient.node().joinContext(joinPayload);
    if (response.error) {
      setJoinError(response.error.message);
    } else {
      if (response.data.contextId && response.data.memberPublicKey) {
        setIsSuccess(true);
        setJoinError("");
      }
    }
    setIsLoading(false);
  };
  return /* @__PURE__ */ import_react2.default.createElement("div", { className: "join-tab" }, /* @__PURE__ */ import_react2.default.createElement(Heading2, null, "Join Existing Context"), /* @__PURE__ */ import_react2.default.createElement(Paragraph, null, "To join context you need to have invitation payload."), /* @__PURE__ */ import_react2.default.createElement("form", { onSubmit: handleJoinSubmit }, /* @__PURE__ */ import_react2.default.createElement(FormGroup, null, /* @__PURE__ */ import_react2.default.createElement(
    FormInput,
    {
      type: "text",
      value: identityPrivateKey,
      onChange: (e) => setIdentityPrivateKey(e.target.value),
      placeholder: "Enter your identity private key"
    }
  )), /* @__PURE__ */ import_react2.default.createElement(FormGroup, null, /* @__PURE__ */ import_react2.default.createElement(
    FormInput,
    {
      type: "text",
      value: joinPayload,
      onChange: (e) => setJoinPayload(e.target.value),
      placeholder: "Paste invitation payload"
    }
  )), joinError && /* @__PURE__ */ import_react2.default.createElement(ErrorMessage, null, joinError), isSuccess && /* @__PURE__ */ import_react2.default.createElement(SuccessMessage, null, "Successfully joined context"), /* @__PURE__ */ import_react2.default.createElement(
    Button,
    {
      type: "submit",
      className: "button-rounded button-size-md",
      disabled: isLoading || !identityPrivateKey || !joinPayload
    },
    isLoading ? /* @__PURE__ */ import_react2.default.createElement(Spinner, null) : "Join"
  )));
};

// src/context/InviteContext.tsx
var import_react3 = __toESM(require("react"), 1);
var InviteContext = () => {
  const applicationId = getApplicationId();
  const [contextId, setContextId2] = (0, import_react3.useState)("");
  const [invitatorKey, setInvitatorKey] = (0, import_react3.useState)("");
  const [inviteeKey, setInviteeKey] = (0, import_react3.useState)("");
  const [isLoading, setIsLoading] = (0, import_react3.useState)(false);
  const [error, setError] = (0, import_react3.useState)(null);
  const [invitation, setInvitation] = (0, import_react3.useState)(null);
  const [contexts, setContexts] = (0, import_react3.useState)([]);
  const [contextLoading, setContextLoading] = (0, import_react3.useState)(false);
  const fetchAvailableContexts = async () => {
    setContextLoading(true);
    const fetchContextsResponse = await apiClient.node().getContexts();
    const contexts2 = fetchContextsResponse.data?.contexts.filter(
      (context) => context.applicationId === applicationId
    ) ?? [];
    setContexts(contexts2);
    setContextId2(contexts2[0].id);
    setContextLoading(false);
  };
  (0, import_react3.useEffect)(() => {
    fetchAvailableContexts();
  }, [applicationId]);
  const handleInviteSubmit = async (e) => {
    e.preventDefault();
    setError(null);
    setInvitation(null);
    setIsLoading(true);
    const response = await apiClient.node().contextInvite(contextId, invitatorKey, inviteeKey);
    if (response.error) {
      setError(response.error.message);
    } else {
      if (response.data == null) {
        setError("Failed to invite to context.");
        setIsLoading(false);
        return;
      }
      setInvitation(response.data);
    }
    setIsLoading(false);
  };
  return /* @__PURE__ */ import_react3.default.createElement("div", { className: "invite-tab" }, /* @__PURE__ */ import_react3.default.createElement(Heading2, null, "Invite to Context"), /* @__PURE__ */ import_react3.default.createElement(Paragraph, null, "Fill in the details to create an invitation"), /* @__PURE__ */ import_react3.default.createElement("form", { onSubmit: handleInviteSubmit }, /* @__PURE__ */ import_react3.default.createElement(FormGroup, null, /* @__PURE__ */ import_react3.default.createElement(ContextSelector, null, /* @__PURE__ */ import_react3.default.createElement("label", null, "Select Context:"), contextLoading ? /* @__PURE__ */ import_react3.default.createElement("div", null, "Loading contexts...") : /* @__PURE__ */ import_react3.default.createElement(
    DropdownSelector,
    {
      id: "context-select",
      value: contextId || "",
      onChange: (e) => {
        const selected = contexts?.find(
          (context) => context.id === e.target.value
        );
        setContextId2(selected.id || "");
      }
    },
    contexts?.map((context) => /* @__PURE__ */ import_react3.default.createElement("option", { key: context.id, value: context.id }, context.id))
  ))), /* @__PURE__ */ import_react3.default.createElement(FormGroup, null, /* @__PURE__ */ import_react3.default.createElement(
    FormInput,
    {
      type: "text",
      value: invitatorKey,
      onChange: (e) => setInvitatorKey(e.target.value),
      placeholder: "Inviter Public Key"
    }
  )), /* @__PURE__ */ import_react3.default.createElement(FormGroup, null, /* @__PURE__ */ import_react3.default.createElement(
    FormInput,
    {
      type: "text",
      value: inviteeKey,
      onChange: (e) => setInviteeKey(e.target.value),
      placeholder: "Invitee Public Key"
    }
  )), error && /* @__PURE__ */ import_react3.default.createElement(ErrorMessage, null, error), invitation && /* @__PURE__ */ import_react3.default.createElement(SuccessMessage, null, /* @__PURE__ */ import_react3.default.createElement(Paragraph, null, "Invitation created successfully"), /* @__PURE__ */ import_react3.default.createElement("div", null, "invitation payload: ", /* @__PURE__ */ import_react3.default.createElement("span", { className: "payload" }, invitation))), /* @__PURE__ */ import_react3.default.createElement(
    Button,
    {
      type: "submit",
      className: "button-rounded button-size-md",
      disabled: isLoading || !invitatorKey || !inviteeKey
    },
    isLoading ? /* @__PURE__ */ import_react3.default.createElement(Spinner, null) : "Create Invitation"
  )));
};

// src/context/CreateContext.tsx
var import_react5 = __toESM(require("react"), 1);

// src/components/icons/DeleteIcon.tsx
var import_react4 = __toESM(require("react"), 1);
function DeleteIcon2({ onClick }) {
  return /* @__PURE__ */ import_react4.default.createElement(
    "svg",
    {
      width: "18px",
      height: "18px",
      fill: "white",
      viewBox: "0 0 485 485",
      onClick,
      style: { cursor: "pointer" }
    },
    /* @__PURE__ */ import_react4.default.createElement("g", null, /* @__PURE__ */ import_react4.default.createElement("g", null, /* @__PURE__ */ import_react4.default.createElement("rect", { x: "67.224", width: "350.535", height: "71.81" }), /* @__PURE__ */ import_react4.default.createElement(
      "path",
      {
        d: "M417.776,92.829H67.237V485h350.537V92.829H417.776z M165.402,431.447h-28.362V146.383h28.362V431.447z M256.689,431.447\n        h-28.363V146.383h28.363V431.447z M347.97,431.447h-28.361V146.383h28.361V431.447z"
      }
    )))
  );
}

// src/context/CreateContext.tsx
var CreateContext = () => {
  const applicationId = getApplicationId();
  const [contexts, setContexts] = (0, import_react5.useState)([]);
  const [selectedProtocol, setSelectedProtocol] = (0, import_react5.useState)("near");
  const [error, setError] = (0, import_react5.useState)(null);
  const [isLoading, setIsLoading] = (0, import_react5.useState)(false);
  const [isDeleting, setIsDeleting] = (0, import_react5.useState)(false);
  const fetchAvailableContexts = (0, import_react5.useCallback)(async () => {
    const fetchContextsResponse = await apiClient.node().getContexts();
    const contexts2 = fetchContextsResponse.data?.contexts.filter(
      (context) => context.applicationId === applicationId
    ) ?? [];
    setContexts(contexts2);
  }, [applicationId]);
  (0, import_react5.useEffect)(() => {
    fetchAvailableContexts();
  }, [applicationId, fetchAvailableContexts]);
  const handleCreateContext = async () => {
    setError(null);
    setIsLoading(true);
    const fetchData = await apiClient.node().createContext(applicationId, "", selectedProtocol);
    if (fetchData.error) {
      setError(fetchData.error.message);
    } else {
      await fetchAvailableContexts();
    }
    setIsLoading(false);
  };
  const handleDeleteContext = async (contextId) => {
    setIsDeleting(true);
    const fetchData = await apiClient.node().deleteContext(contextId);
    if (fetchData.error) {
      setError(fetchData.error.message);
    } else {
      await fetchAvailableContexts();
    }
    setIsDeleting(false);
  };
  return /* @__PURE__ */ import_react5.default.createElement("div", { className: "create-tab" }, /* @__PURE__ */ import_react5.default.createElement(Heading2, null, "Create Context"), /* @__PURE__ */ import_react5.default.createElement(Paragraph, null, "Application ID: ", applicationId), /* @__PURE__ */ import_react5.default.createElement("label", null, "Choose Protocol:"), /* @__PURE__ */ import_react5.default.createElement(FlexContainer, null, /* @__PURE__ */ import_react5.default.createElement("div", null, /* @__PURE__ */ import_react5.default.createElement(
    DropdownSelector,
    {
      value: selectedProtocol,
      onChange: (e) => setSelectedProtocol(e.target.value)
    },
    /* @__PURE__ */ import_react5.default.createElement("option", { value: "near" }, "NEAR"),
    /* @__PURE__ */ import_react5.default.createElement("option", { value: "ethereum" }, "Ethereum"),
    /* @__PURE__ */ import_react5.default.createElement("option", { value: "starknet" }, "Starknet"),
    /* @__PURE__ */ import_react5.default.createElement("option", { value: "stellar" }, "Stellar"),
    /* @__PURE__ */ import_react5.default.createElement("option", { value: "icp" }, "ICP")
  )), /* @__PURE__ */ import_react5.default.createElement(
    Button,
    {
      disabled: isLoading,
      onClick: handleCreateContext,
      className: "button-rounded",
      style: { width: "177px" }
    },
    isLoading ? /* @__PURE__ */ import_react5.default.createElement(Spinner, null) : "Create New Context"
  )), error && /* @__PURE__ */ import_react5.default.createElement(ErrorMessage, null, error), /* @__PURE__ */ import_react5.default.createElement(Heading3, null, "Existing Contexts"), /* @__PURE__ */ import_react5.default.createElement(ScrollableList, null, contexts.map((context, index) => /* @__PURE__ */ import_react5.default.createElement(ListItem, { key: index }, /* @__PURE__ */ import_react5.default.createElement("span", null, index + 1, ". ", context.id), isDeleting ? /* @__PURE__ */ import_react5.default.createElement(Spinner, null) : /* @__PURE__ */ import_react5.default.createElement(DeleteIcon2, { onClick: () => handleDeleteContext(context.id) })))));
};

// src/context/Identity.tsx
var import_react6 = __toESM(require("react"), 1);
var NEW_IDENTITY_KEY = "new-identity";
var Identity = () => {
  const applicationId = getApplicationId();
  const [identities, setIdentities] = (0, import_react6.useState)([]);
  const [contexts, setContexts] = (0, import_react6.useState)([]);
  const [selectedContext, setSelectedContext] = (0, import_react6.useState)(null);
  const [contextLoading, setContextLoading] = (0, import_react6.useState)(true);
  const [identityLoading, setIdentityLoading] = (0, import_react6.useState)(true);
  const [error, setError] = (0, import_react6.useState)(null);
  const [isLoading, setIsLoading] = (0, import_react6.useState)(false);
  const [newIdentity, setNewIdentity] = (0, import_react6.useState)(null);
  const fetchAvailableContexts = async () => {
    setContextLoading(true);
    const fetchContextsResponse = await apiClient.node().getContexts();
    const contexts2 = fetchContextsResponse.data?.contexts.filter(
      (context) => context.applicationId === applicationId
    ) ?? [];
    setContexts(contexts2);
    setSelectedContext(contexts2[0]);
    setContextLoading(false);
  };
  (0, import_react6.useEffect)(() => {
    fetchAvailableContexts();
  }, [applicationId]);
  const fetchContextIdentities = async () => {
    if (!selectedContext?.id) return;
    setIdentityLoading(true);
    const fetchContextIdentitiesResponse = await apiClient.node().fetchContextIdentities(selectedContext.id);
    if (fetchContextIdentitiesResponse.error) {
      setError(fetchContextIdentitiesResponse.error.message);
    } else {
      setIdentities(fetchContextIdentitiesResponse.data.identities);
    }
    setIdentityLoading(false);
  };
  (0, import_react6.useEffect)(() => {
    if (selectedContext) {
      fetchContextIdentities();
    }
  }, [selectedContext]);
  const handleCreateIdentity = async () => {
    setError(null);
    setIsLoading(true);
    const fetchData = await apiClient.node().createNewIdentity();
    if (fetchData.error) {
      setError(fetchData.error.message);
    } else {
      setNewIdentity(fetchData.data);
    }
    setIsLoading(false);
  };
  (0, import_react6.useEffect)(() => {
    if (newIdentity) {
      localStorage.setItem(NEW_IDENTITY_KEY, JSON.stringify(newIdentity));
    } else {
      const newIdentity2 = localStorage.getItem(NEW_IDENTITY_KEY);
      if (newIdentity2) {
        setNewIdentity(JSON.parse(newIdentity2));
      }
    }
  }, [newIdentity]);
  const deleteIdentity = () => {
    localStorage.removeItem(NEW_IDENTITY_KEY);
    setNewIdentity(null);
  };
  return /* @__PURE__ */ import_react6.default.createElement("div", { className: "identity-tab" }, /* @__PURE__ */ import_react6.default.createElement(FlexContainer, null, /* @__PURE__ */ import_react6.default.createElement("div", null, /* @__PURE__ */ import_react6.default.createElement(Heading2, null, "Identities"), /* @__PURE__ */ import_react6.default.createElement(
    Button,
    {
      onClick: handleCreateIdentity,
      className: "button-rounded",
      disabled: isLoading
    },
    isLoading ? /* @__PURE__ */ import_react6.default.createElement(Spinner, null) : "Create New Identity"
  )), newIdentity && /* @__PURE__ */ import_react6.default.createElement(IdentityContainer, null, /* @__PURE__ */ import_react6.default.createElement("label", null, "New Identity"), /* @__PURE__ */ import_react6.default.createElement(Paragraph, { className: "text-sm" }, "Public Key: ", /* @__PURE__ */ import_react6.default.createElement("br", null), newIdentity?.publicKey), /* @__PURE__ */ import_react6.default.createElement(Paragraph, { className: "text-sm" }, "Private Key: ", /* @__PURE__ */ import_react6.default.createElement("br", null), newIdentity?.privateKey), /* @__PURE__ */ import_react6.default.createElement(DeleteIcon, { onClick: deleteIdentity }, "x"))), error && /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, null, error), /* @__PURE__ */ import_react6.default.createElement(ContextSelector, null, /* @__PURE__ */ import_react6.default.createElement("label", null, "Select Context:"), contextLoading ? /* @__PURE__ */ import_react6.default.createElement("div", null, "Loading contexts...") : /* @__PURE__ */ import_react6.default.createElement(
    DropdownSelector,
    {
      id: "context-select",
      className: "dropdown-selector",
      value: selectedContext?.id || "",
      onChange: (e) => {
        const selected = contexts?.find(
          (context) => context.id === e.target.value
        );
        setSelectedContext(selected || null);
      }
    },
    contexts?.map((context) => /* @__PURE__ */ import_react6.default.createElement("option", { key: context.id, value: context.id }, context.id))
  )), /* @__PURE__ */ import_react6.default.createElement("label", null, "Available Identities:"), /* @__PURE__ */ import_react6.default.createElement(ScrollableList, null, identityLoading ? /* @__PURE__ */ import_react6.default.createElement("div", null, "Loading identities...") : identities.length > 0 && identities.map((identity, index) => /* @__PURE__ */ import_react6.default.createElement(ListItem, { key: index }, /* @__PURE__ */ import_react6.default.createElement("span", null, index + 1, ". ", identity)))));
};

// src/context/ContextModal.tsx
var contextActions = [
  {
    label: "Join Context",
    id: "join"
  },
  {
    label: "Invite to Context",
    id: "invite"
  },
  {
    label: "Create Context",
    id: "create"
  },
  {
    label: "Identity",
    id: "identity"
  }
];
var ContextModal = () => {
  const [activeTab, setActiveTab] = (0, import_react7.useState)("join");
  return /* @__PURE__ */ import_react7.default.createElement(ContextModalWrapper, null, /* @__PURE__ */ import_react7.default.createElement(Tabs, null, contextActions.map((item, i) => /* @__PURE__ */ import_react7.default.createElement(
    TabButton,
    {
      key: i,
      onClick: () => setActiveTab(item.id),
      className: activeTab === item.id ? "active" : ""
    },
    item.label
  ))), /* @__PURE__ */ import_react7.default.createElement(TabContent, null, activeTab === "join" && /* @__PURE__ */ import_react7.default.createElement(JoinContext, null), activeTab === "invite" && /* @__PURE__ */ import_react7.default.createElement(InviteContext, null), activeTab === "create" && /* @__PURE__ */ import_react7.default.createElement(CreateContext, null), activeTab === "identity" && /* @__PURE__ */ import_react7.default.createElement(Identity, null)));
};

// src/experimental/CalimeroProvider.tsx
var import_react11 = __toESM(require("react"), 1);

// src/experimental/CalimeroLoginModal.tsx
var import_react9 = __toESM(require("react"), 1);
var import_styled_components3 = __toESM(require("styled-components"), 1);

// src/experimental/CalimeroLogo.tsx
var import_react8 = __toESM(require("react"), 1);
var CalimeroLogo = (props) => /* @__PURE__ */ import_react8.default.createElement(
  "svg",
  {
    version: "1.0",
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 400 400",
    preserveAspectRatio: "xMidYMid meet",
    ...props
  },
  /* @__PURE__ */ import_react8.default.createElement(
    "g",
    {
      transform: "translate(0.000000,400.000000) scale(0.100000,-0.100000)",
      fill: "currentColor",
      stroke: "none"
    },
    /* @__PURE__ */ import_react8.default.createElement("path", { d: "M1795 3589 c-185 -9 -341 -31 -505 -71 -69 -16 -141 -34 -160 -38 -117 -26 -408 -148 -533 -223 -64 -38 -101 -75 -137 -133 -51 -85 -61 -155 -44 -332 23 -250 57 -411 145 -682 35 -110 48 -144 90 -236 11 -23 19 -44 19 -48 0 -8 106 -220 136 -271 13 -22 27 -47 31 -55 15 -33 186 -285 226 -332 114 -136 189 -219 256 -283 41 -38 82 -77 92 -87 81 -77 311 -243 449 -324 105 -62 164 -79 223 -63 101 27 147 83 147 180 0 83 -31 134 -105 175 -70 38 -107 61 -243 153 -19 13 -59 43 -89 67 -30 25 -60 49 -66 54 -45 36 -139 124 -186 174 -31 33 -63 67 -72 76 -73 77 -252 325 -282 390 -4 8 -16 29 -27 45 -18 28 -102 195 -137 275 -9 19 -20 43 -25 54 -5 10 -16 37 -23 60 -7 22 -24 73 -38 111 -76 221 -144 552 -135 663 3 41 6 45 58 72 30 15 71 35 90 43 19 8 55 24 78 36 24 11 50 21 57 21 7 0 26 7 41 15 16 8 36 15 46 15 9 0 40 9 70 19 70 25 207 56 343 78 161 26 681 26 845 0 105 -17 228 -43 321 -67 103 -28 188 5 242 92 23 37 23 139 0 176 -22 36 -84 91 -104 92 -8 0 -35 6 -60 14 -71 22 -226 54 -344 70 -96 14 -471 39 -522 35 -10 -1 -85 -5 -168 -10z" }),
    /* @__PURE__ */ import_react8.default.createElement("path", { d: "M3345 3268 c-56 -15 -89 -41 -119 -92 -25 -44 -26 -48 -26 -233 0 -250 -25 -426 -90 -643 -34 -112 -59 -188 -76 -227 -9 -21 -24 -54 -32 -73 -35 -82 -123 -249 -160 -304 -18 -26 -32 -49 -32 -51 0 -21 -170 -235 -260 -328 l-75 -78 -40 21 c-62 31 -172 106 -207 139 -9 9 -30 27 -47 40 -44 33 -183 172 -267 266 -66 75 -240 294 -274 345 -8 12 -25 35 -37 50 -13 15 -23 31 -23 34 0 3 -16 28 -35 55 -19 26 -35 52 -35 57 0 18 -66 81 -105 99 -124 59 -275 -35 -275 -171 0 -55 15 -88 91 -202 27 -41 49 -78 49 -83 0 -5 4 -9 8 -9 5 0 24 -24 42 -52 19 -29 37 -55 40 -58 3 -3 31 -39 62 -80 49 -67 123 -157 213 -259 92 -104 290 -291 388 -366 107 -81 274 -174 359 -200 106 -31 225 -8 320 63 53 40 183 171 248 251 19 23 40 48 45 54 18 20 137 189 160 226 116 188 205 366 268 536 55 150 54 147 101 330 74 286 94 776 37 869 -37 60 -138 95 -216 74z" }),
    /* @__PURE__ */ import_react8.default.createElement("path", { d: "M1830 3015 c-230 -18 -478 -67 -635 -125 -27 -10 -61 -22 -75 -26 -39 -11 -71 -35 -101 -78 -25 -34 -29 -48 -29 -106 0 -59 4 -72 30 -108 16 -23 48 -51 69 -62 47 -23 125 -26 173 -6 86 35 214 70 403 107 109 21 146 23 405 23 303 0 281 3 508 -56 48 -12 48 -13 27 -106 -34 -145 -98 -307 -159 -395 -14 -21 -26 -41 -26 -45 0 -4 -50 -74 -110 -157 l-109 -150 -1 -59 c0 -79 32 -136 94 -166 101 -49 187 -32 258 51 50 58 170 225 212 296 158 260 246 519 246 722 0 98 -17 153 -67 220 -64 86 -142 130 -298 169 -139 36 -186 43 -355 58 -193 16 -251 16 -460 -1z" })
  )
);
var CalimeroLogo_default = CalimeroLogo;

// src/experimental/CalimeroLoginModal.tsx
var fadeIn = import_styled_components3.keyframes`
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
`;
var slideIn = import_styled_components3.keyframes`
  from {
    transform: translateY(-20px);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
`;
var OverlayBackdrop = import_styled_components3.default.div`
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.7);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
  animation: ${fadeIn} 0.3s ease-out;
`;
var OverlayContent = import_styled_components3.default.div`
  position: relative;
  background: var(--background-color);
  padding: 40px;
  border-radius: 12px;
  text-align: center;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
  width: 90%;
  max-width: 500px;
  animation: ${slideIn} 0.4s ease-out;
  display: flex;
  flex-direction: column;
  align-items: center;
`;
var OverlayHeader = import_styled_components3.default.div`
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 15px;
  margin-bottom: 10px;

  h1 {
    margin: 0;
    font-size: 24px;
    color: var(--text-color);
  }
`;
var StyledCalimeroLogo = (0, import_styled_components3.default)(CalimeroLogo_default)`
  width: 40px;
  height: 40px;
  margin-bottom: 0;
  color: var(--text-color);
`;
var InfoText = import_styled_components3.default.p`
  margin-bottom: 20px;
  color: var(--text-secondary-color);
`;
var LocalNodeInfo = import_styled_components3.default.p`
  color: var(--text-secondary-color);
  margin: 12px 0;
`;
var ErrorMessage2 = import_styled_components3.default.p`
  color: #ff4d4d;
  margin-bottom: 20px;
`;
var RadioGroup = import_styled_components3.default.div`
  display: flex;
  justify-content: center;
  gap: 20px;
  margin-bottom: 20px;

  label {
    display: flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
    color: var(--text-color);
  }
`;
var InputContainer = import_styled_components3.default.div`
  min-height: 60px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  gap: 15px;
  margin-bottom: 20px;
  width: 100%;

  input {
    padding: 12px;
    width: 100%;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    box-sizing: border-box;
    background-color: var(--background-input);
    color: var(--text-color-input);
    transition:
      border-color 0.3s,
      box-shadow 0.3s;

    &:focus {
      border-color: var(--success-color);
      box-shadow: 0 0 0 2px rgba(168, 230, 64, 0.2);
      outline: none;
    }
  }
`;
var SpinnerContainer2 = import_styled_components3.default.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 200px;
`;
var ButtonGroup = import_styled_components3.default.div`
  display: flex;
  gap: 10px;
  justify-content: center;
`;
var StyledButton = import_styled_components3.default.button`
  padding: 12px 24px;
  border: 1px solid var(--primary-color);
  border-radius: 8px;
  cursor: pointer;
  font-size: 16px;
  transition:
    background-color 0.3s,
    color 0.3s;

  &.connect-button {
    background-color: var(--success-color);
    color: var(--background-color);
    border-color: var(--success-color);

    &:hover {
      background-color: var(--success-hover-color);
      border-color: var(--success-hover-color);
    }

    &:disabled {
      background-color: var(--disabled-color);
      border-color: var(--disabled-color);
      cursor: not-allowed;
    }
  }

  &.help-button {
    background-color: var(--background-color);
    color: var(--text-color);
    border-color: var(--border-color);

    &:hover {
      background-color: var(--primary-color);
      color: var(--background-color);
      border-color: var(--primary-color);
    }
  }
`;
var CloseIconButton = import_styled_components3.default.button`
  position: absolute;
  top: 15px;
  right: 15px;
  background: none;
  border: none;
  font-size: 24px;
  color: var(--text-secondary-color);
  cursor: pointer;
  line-height: 1;

  &:hover {
    color: var(--text-color);
  }
`;
var URL_REGEX = /^(https?:\/\/)?((([a-z\d]([a-z\d-]*[a-z\d])*)\.)+[a-z]{2,}|localhost|((\d{1,3}\.){3}\d{1,3}))(:\d+)?(\/[-a-z\d%_.~+]*)*(\?[;&a-z\d%_.~+=-]*)?(#[-a-z\d_]*)?$/i;
var CalimeroLoginModal = ({
  onConnect,
  onClose
}) => {
  const [nodeType, setNodeType] = (0, import_react9.useState)("local");
  const [nodeUrl, setNodeUrl] = (0, import_react9.useState)("");
  const [isValid, setIsValid] = (0, import_react9.useState)(true);
  const [loading, setLoading] = (0, import_react9.useState)(false);
  const [error, setError] = (0, import_react9.useState)(null);
  (0, import_react9.useEffect)(() => {
    if (nodeType === "remote") {
      setIsValid(URL_REGEX.test(nodeUrl));
    } else {
      setIsValid(true);
    }
  }, [nodeUrl, nodeType]);
  const handleConnect = (0, import_react9.useCallback)(async () => {
    if (isValid) {
      setLoading(true);
      setError(null);
      const finalUrl = nodeType === "local" ? `http://localhost` : nodeUrl;
      try {
        const response = await fetch(`${finalUrl}/admin-api/is-authed`);
        if (response.ok || response.status === 401) {
          setLoading(false);
          onConnect(finalUrl);
        } else {
          throw new Error(
            `Network response was not ok: ${response.statusText}`
          );
        }
      } catch (err) {
        console.error("Connection failed:", err);
        setError("Failed to connect. Please check the URL and try again.");
        setLoading(false);
      }
    }
  }, [isValid, nodeType, nodeUrl, onConnect]);
  return /* @__PURE__ */ import_react9.default.createElement(OverlayBackdrop, { onClick: onClose }, /* @__PURE__ */ import_react9.default.createElement(OverlayContent, { onClick: (e) => e.stopPropagation() }, /* @__PURE__ */ import_react9.default.createElement(CloseIconButton, { onClick: onClose }, "\xD7"), /* @__PURE__ */ import_react9.default.createElement(OverlayHeader, null, /* @__PURE__ */ import_react9.default.createElement(StyledCalimeroLogo, null), /* @__PURE__ */ import_react9.default.createElement("h1", null, "Calimero Connect")), loading ? /* @__PURE__ */ import_react9.default.createElement(SpinnerContainer2, null, /* @__PURE__ */ import_react9.default.createElement("p", null, "Connecting to node..."), /* @__PURE__ */ import_react9.default.createElement(Spinner, null)) : /* @__PURE__ */ import_react9.default.createElement(import_react9.default.Fragment, null, /* @__PURE__ */ import_react9.default.createElement(InfoText, null, "Select your Calimero node type to continue."), error && /* @__PURE__ */ import_react9.default.createElement(ErrorMessage2, null, error), /* @__PURE__ */ import_react9.default.createElement(RadioGroup, null, /* @__PURE__ */ import_react9.default.createElement("label", null, /* @__PURE__ */ import_react9.default.createElement(
    "input",
    {
      type: "radio",
      value: "local",
      checked: nodeType === "local",
      onChange: () => setNodeType("local")
    }
  ), "Local"), /* @__PURE__ */ import_react9.default.createElement("label", null, /* @__PURE__ */ import_react9.default.createElement(
    "input",
    {
      type: "radio",
      value: "remote",
      checked: nodeType === "remote",
      onChange: () => setNodeType("remote")
    }
  ), "Remote")), /* @__PURE__ */ import_react9.default.createElement(InputContainer, null, nodeType === "remote" ? /* @__PURE__ */ import_react9.default.createElement(
    "input",
    {
      type: "text",
      value: nodeUrl,
      onChange: (e) => setNodeUrl(e.target.value),
      placeholder: "https://your-node-url.calimero.network"
    }
  ) : /* @__PURE__ */ import_react9.default.createElement(LocalNodeInfo, null, "Using default local node: http://localhost")), /* @__PURE__ */ import_react9.default.createElement(ButtonGroup, null, /* @__PURE__ */ import_react9.default.createElement(
    StyledButton,
    {
      onClick: handleConnect,
      disabled: !isValid || loading,
      className: "connect-button"
    },
    "Connect"
  )))));
};
var CalimeroLoginModal_default = CalimeroLoginModal;

// src/experimental/Toast.tsx
var import_react10 = __toESM(require("react"), 1);
var import_styled_components4 = __toESM(require("styled-components"), 1);
var slideInUp = import_styled_components4.keyframes`
  from {
    transform: translateY(100px);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
`;
var fadeOut = import_styled_components4.keyframes`
  from {
    opacity: 1;
  }
  to {
    opacity: 0;
  }
`;
var ToastContainer = import_styled_components4.default.div`
  position: fixed;
  bottom: 20px;
  right: 20px;
  background-color: ${({ toastType }) => toastType === "success" ? "var(--success-color)" : "#ff4d4d"};
  color: ${({ toastType }) => toastType === "success" ? "var(--background-color)" : "white"};
  padding: 15px 20px;
  border-radius: 8px;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
  display: flex;
  align-items: center;
  justify-content: space-between;
  z-index: 2000;
  animation:
    ${slideInUp} 0.5s ease-out,
    ${fadeOut} 0.5s ease-out 4.5s forwards;
`;
var ToastMessage = import_styled_components4.default.div`
  margin-right: 15px;
`;
var ToastCloseButton = import_styled_components4.default.button`
  background: none;
  border: none;
  color: inherit;
  font-size: 20px;
  cursor: pointer;
`;
var Toast = ({ message, onClose, type = "error" }) => {
  return /* @__PURE__ */ import_react10.default.createElement(ToastContainer, { toastType: type }, /* @__PURE__ */ import_react10.default.createElement(ToastMessage, null, message), /* @__PURE__ */ import_react10.default.createElement(ToastCloseButton, { onClick: onClose }, "\xD7"));
};
var Toast_default = Toast;

// src/experimental/websocket.ts
var RECONNECT_DELAY = 5e3;
var ExperimentalWebSocket = class {
  constructor(baseUrl) {
    __publicField(this, "ws", null);
    __publicField(this, "url");
    __publicField(this, "reconnectTimeout", null);
    __publicField(this, "callbacks", /* @__PURE__ */ new Map());
    __publicField(this, "requestId", 0);
    this.url = this.buildUrl(baseUrl);
    this.connect();
  }
  buildUrl(baseUrl) {
    let wsUrl = "";
    if (baseUrl.startsWith("https://")) {
      wsUrl = baseUrl.replace("https://", "wss://");
    } else if (baseUrl.startsWith("http://")) {
      wsUrl = baseUrl.replace("http://", "ws://");
    } else {
      wsUrl = `wss://${baseUrl}`;
    }
    return `${wsUrl}/ws`;
  }
  connect() {
    const accessToken = getAccessToken();
    if (!accessToken) {
      console.warn("No access token found, WebSocket connection aborted.");
      return;
    }
    const fullUrl = `${this.url}?token=${encodeURIComponent(accessToken)}`;
    this.ws = new WebSocket(fullUrl);
    this.ws.onopen = () => {
      this.clearReconnect();
    };
    this.ws.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        if (data.result && data.result.contextId) {
          const nodeEvent = data.result;
          this.decodeEventData(nodeEvent);
          const callback = this.callbacks.get(nodeEvent.contextId);
          if (callback) {
            callback(nodeEvent);
          }
        }
      } catch (e) {
        console.error("Error parsing WebSocket message:", e);
      }
    };
    this.ws.onclose = () => {
      console.log("Experimental WebSocket disconnected.");
      this.scheduleReconnect();
    };
    this.ws.onerror = (error) => {
      console.error("Experimental WebSocket error:", error);
      this.ws?.close();
    };
  }
  decodeEventData(nodeEvent) {
    if (nodeEvent.type === "ExecutionEvent" && nodeEvent.data && Array.isArray(nodeEvent.data.events)) {
      nodeEvent.data.events.forEach((executionEvent) => {
        if (Array.isArray(executionEvent.data) && executionEvent.data.every((item) => typeof item === "number")) {
          try {
            const decodedString = new TextDecoder().decode(
              new Uint8Array(executionEvent.data)
            );
            try {
              executionEvent.data = JSON.parse(decodedString);
            } catch (jsonError) {
              executionEvent.data = decodedString;
            }
          } catch (decodeError) {
            console.error(
              "Failed to decode event data byte array",
              decodeError
            );
          }
        }
      });
    }
  }
  scheduleReconnect() {
    this.clearReconnect();
    this.reconnectTimeout = setTimeout(() => {
      console.log("Attempting to reconnect WebSocket...");
      this.connect();
    }, RECONNECT_DELAY);
  }
  clearReconnect() {
    if (this.reconnectTimeout) {
      clearTimeout(this.reconnectTimeout);
    }
  }
  subscribe(contextIds, callback) {
    contextIds.forEach((contextId) => {
      this.callbacks.set(contextId, callback);
    });
    if (this.ws?.readyState === WebSocket.OPEN) {
      this.ws.send(
        JSON.stringify({
          id: this.requestId++,
          method: "subscribe",
          params: { contextIds }
        })
      );
    }
  }
  unsubscribe(contextIds) {
    contextIds.forEach((contextId) => {
      this.callbacks.delete(contextId);
    });
    if (this.ws?.readyState === WebSocket.OPEN) {
      this.ws.send(
        JSON.stringify({
          id: this.requestId++,
          method: "unsubscribe",
          params: { contextIds }
        })
      );
    }
  }
  close() {
    this.clearReconnect();
    this.ws?.close();
  }
};

// src/experimental/types.ts
var Protocol = /* @__PURE__ */ ((Protocol2) => {
  Protocol2["ETHEREUM"] = "ethereum";
  Protocol2["ICP"] = "icp";
  Protocol2["NEAR"] = "near";
  Protocol2["STARKNET"] = "starknet";
  Protocol2["STELLAR"] = "stellar";
  return Protocol2;
})(Protocol || {});
var AppMode = /* @__PURE__ */ ((AppMode2) => {
  AppMode2["MultiContext"] = "multi-context";
  return AppMode2;
})(AppMode || {});

// src/experimental/app.ts
var CalimeroApplication = class {
  constructor(apiClient2, clientApplicationId) {
    __publicField(this, "apiClient");
    __publicField(this, "clientApplicationId");
    __publicField(this, "websocket");
    this.apiClient = apiClient2;
    this.clientApplicationId = clientApplicationId;
    const baseUrl = getAppEndpointKey();
    this.websocket = new ExperimentalWebSocket(baseUrl);
  }
  async fetchContexts() {
    const contextsResponse = await this.apiClient.node().getContexts();
    if (contextsResponse.error) {
      throw new Error(
        `Error fetching contexts: ${contextsResponse.error.message}`
      );
    }
    const filteredApiContexts = contextsResponse.data ? contextsResponse.data.contexts.filter(
      (apiContext) => apiContext.applicationId === this.clientApplicationId
    ) : [];
    const contexts = await Promise.all(
      filteredApiContexts.map(async (apiContext) => {
        const identitiesResponse = await this.apiClient.node().fetchContextIdentities(apiContext.id);
        if (identitiesResponse.error || !identitiesResponse.data) {
          throw new Error(
            `Could not fetch identity for context ${apiContext.id}, or no identities found.`
          );
        }
        return {
          contextId: apiContext.id,
          executorId: identitiesResponse.data.identities[0],
          // Assuming the first identity is the executor
          applicationId: apiContext.applicationId
        };
      })
    );
    return contexts;
  }
  async execute(context, method, params = {}) {
    const response = await this.apiClient.rpc().execute({
      contextId: context.contextId,
      method,
      argsJson: params || {},
      executorPublicKey: context.executorId
    });
    if (response.error) {
      return {
        success: false,
        error: response.error.error?.cause?.info?.message
      };
    }
    return { success: true, result: response.result?.output };
  }
  async createContext(protocol = "near" /* NEAR */, initParams) {
    const response = await this.apiClient.node().createContext(
      this.clientApplicationId,
      JSON.stringify(initParams || {}),
      protocol
    );
    if (response.error) {
      throw new Error(`Error creating context: ${response.error.message}`);
    }
    return {
      contextId: response.data.contextId,
      executorId: response.data.memberPublicKey,
      applicationId: this.clientApplicationId
    };
  }
  async deleteContext(context) {
    const response = await this.apiClient.node().deleteContext(context.contextId);
    if (response.error) {
      throw new Error(`Error deleting context: ${response.error.message}`);
    }
  }
  subscribeToEvents(contextIds, callback) {
    this.websocket.subscribe(contextIds, callback);
  }
  unsubscribeFromEvents(contextIds) {
    this.websocket.unsubscribe(contextIds);
  }
  close() {
    this.websocket.close();
  }
};

// src/styles/global.ts
var import_styled_components5 = require("styled-components");
var GlobalStyle = import_styled_components5.createGlobalStyle`
  :root {
    --background-color: #000000;
    --background-input: #ffffff;
    --text-color: #ffffff;
    --text-color-input: #000000;
    --text-secondary-color: #a0a0a0;
    --primary-color: #000000;
    --accent-color: #f97316;
    --accent-hover-color: #e85d04;
    --disabled-color: #444444;
    --success-color: #a8e640;
    --success-hover-color: #97cf2c;
    --border-color: #a0a0a0;
  }
`;

// src/experimental/CalimeroProvider.tsx
var CalimeroContext = (0, import_react11.createContext)({
  app: null,
  isAuthenticated: false,
  login: () => {
  },
  logout: () => {
  },
  appUrl: null,
  isOnline: true
});
var useCalimero = () => (0, import_react11.useContext)(CalimeroContext);
var getPermissionsForMode = (mode) => {
  switch (mode) {
    case "multi-context" /* MultiContext */:
      return ["context:execute", "application"];
    default:
      throw new Error(`Unsupported application mode: ${mode}`);
  }
};
var CalimeroProvider = ({
  children,
  clientApplicationId,
  mode,
  applicationPath
}) => {
  const [isAuthenticated, setIsAuthenticated] = (0, import_react11.useState)(false);
  const [isLoginOpen, setIsLoginOpen] = (0, import_react11.useState)(false);
  const [isLoading, setIsLoading] = (0, import_react11.useState)(true);
  const [toast, setToast] = (0, import_react11.useState)(null);
  const [isOnline, setIsOnline] = (0, import_react11.useState)(true);
  const [appUrl, setAppUrl] = (0, import_react11.useState)(getAppEndpointKey());
  const performLogin = (0, import_react11.useCallback)(
    (url) => {
      const permissions = getPermissionsForMode(mode);
      apiClient.auth().login({
        url,
        callbackUrl: window.location.href,
        applicationId: clientApplicationId,
        permissions,
        applicationPath
      });
    },
    [clientApplicationId, mode, applicationPath]
  );
  const logout = (0, import_react11.useCallback)(() => {
    clientLogout();
    setIsAuthenticated(false);
    setIsOnline(true);
    setAppUrl(null);
  }, []);
  (0, import_react11.useEffect)(() => {
    const fragment = window.location.hash.substring(1);
    const fragmentParams = new URLSearchParams(fragment);
    const encodedAccessToken = fragmentParams.get("access_token");
    const encodedRefreshToken = fragmentParams.get("refresh_token");
    if (encodedAccessToken && encodedRefreshToken) {
      window.history.replaceState({}, document.title, window.location.pathname);
      const accessToken = decodeURIComponent(encodedAccessToken);
      const refreshToken = decodeURIComponent(encodedRefreshToken);
      setAccessToken(accessToken);
      setRefreshToken(refreshToken);
      const newAppUrl = getAppEndpointKey();
      setAppUrl(newAppUrl);
      if (!newAppUrl) return;
      const verify = async () => {
        const response = await apiClient.node().checkAuth();
        if (!response.error) {
          setIsAuthenticated(true);
        }
      };
      verify();
    }
  }, []);
  (0, import_react11.useEffect)(() => {
    const checkSession = async () => {
      const savedUrl = getAppEndpointKey();
      const savedToken = getAccessToken();
      if (savedUrl && savedToken) {
        try {
          const response = await apiClient.node().checkAuth();
          if (!response.error) {
            setIsAuthenticated(true);
            setIsOnline(true);
          } else if (response.error.code === 401) {
            performLogin(savedUrl);
          }
        } catch (error) {
          logout();
        }
      }
      setIsLoading(false);
    };
    checkSession();
  }, [performLogin, logout]);
  (0, import_react11.useEffect)(() => {
    const intervalId = setInterval(async () => {
      if (!isAuthenticated) return;
      const savedUrl = getAppEndpointKey();
      if (savedUrl) {
        try {
          const response = await apiClient.node().checkAuth();
          if (response.error && response.error.code === 401) {
            logout();
            setToast({
              message: "Session expired. Please connect again.",
              type: "error"
            });
            return;
          }
          if (response.error && isOnline) {
            setToast({
              message: "Connection lost. Trying to reconnect...",
              type: "error"
            });
            setIsOnline(false);
          } else if (!response.error && !isOnline) {
            setToast({ message: "Connection restored.", type: "success" });
            setIsOnline(true);
            setTimeout(() => setToast(null), 5e3);
          }
        } catch (error) {
          if (isOnline) {
            setToast({
              message: "Connection lost. Trying to reconnect...",
              type: "error"
            });
            setIsOnline(false);
          }
        }
      }
    }, 5e3);
    return () => clearInterval(intervalId);
  }, [isAuthenticated, isOnline, logout]);
  const handleConnect = (url) => {
    setAppEndpointKey(url);
    setAppUrl(url);
    performLogin(url);
  };
  const login = () => setIsLoginOpen(true);
  const app = (0, import_react11.useMemo)(
    () => isAuthenticated ? new CalimeroApplication(apiClient, clientApplicationId) : null,
    [isAuthenticated, clientApplicationId]
  );
  (0, import_react11.useEffect)(() => {
    return () => {
      app?.close();
    };
  }, [app]);
  return /* @__PURE__ */ import_react11.default.createElement(
    CalimeroContext.Provider,
    {
      value: { app, isAuthenticated, login, logout, appUrl, isOnline }
    },
    isLoading ? /* @__PURE__ */ import_react11.default.createElement("div", null, "Loading...") : /* @__PURE__ */ import_react11.default.createElement(import_react11.default.Fragment, null, /* @__PURE__ */ import_react11.default.createElement(GlobalStyle, null), children, isLoginOpen && /* @__PURE__ */ import_react11.default.createElement(
      CalimeroLoginModal_default,
      {
        onConnect: handleConnect,
        onClose: () => setIsLoginOpen(false)
      }
    ), toast && /* @__PURE__ */ import_react11.default.createElement(
      Toast_default,
      {
        message: toast.message,
        type: toast.type,
        onClose: () => setToast(null)
      }
    ))
  );
};

// src/experimental/CalimeroConnectButton.tsx
var import_react12 = __toESM(require("react"), 1);
var import_styled_components6 = __toESM(require("styled-components"), 1);
var StyledButton2 = import_styled_components6.default.button`
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px 20px;
  background-color: var(--background-color);
  border: 1px solid var(--accent-color);
  border-radius: 8px;
  cursor: pointer;
  font-size: 16px;
  color: var(--text-color);
  transition: background-color 0.3s;
  width: 180px;
  justify-content: center;
  box-sizing: border-box;

  .calimero-logo {
    width: 24px;
    height: 24px;
    color: var(--text-color);
  }

  &:hover:not(.connected) {
    background-color: var(--accent-hover-color);
    border-color: var(--accent-hover-color);
  }

  &.connected {
    background-color: var(--success-color);
    color: var(--background-color);
    border-color: var(--success-color);

    .calimero-logo {
      color: var(--background-color);
    }
  }

  &.reconnecting {
    background-color: var(--accent-color);
    color: var(--text-color);
    border-color: var(--accent-color);
    cursor: not-allowed;
  }
`;
var ConnectedContainer = import_styled_components6.default.div`
  position: relative;
  display: inline-block;
`;
var DropdownMenu = import_styled_components6.default.div`
  position: absolute;
  top: 100%;
  left: 0;
  background-color: var(--background-color);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  margin-top: 0;
  padding: 0;
  z-index: 1001;
  width: 100%;
  overflow: hidden;
  box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
`;
var DropdownItem = import_styled_components6.default.a`
  display: block;
  width: 100%;
  padding: 10px 20px;
  background: none;
  border: none;
  color: var(--text-color);
  text-align: left;
  cursor: pointer;
  font-size: 16px;
  text-decoration: none;

  &:hover,
  &:active {
    background-color: var(--success-color);
    color: var(--background-color);
  }
`;
var DropdownInfoItem = import_styled_components6.default.div`
  padding: 10px 20px;
  color: var(--text-secondary-color);
  font-size: 14px;
  border-bottom: 1px solid var(--border-color);
  cursor: default;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 150px;
`;
var CalimeroConnectButton = () => {
  const { isAuthenticated, login, logout, appUrl, isOnline } = useCalimero();
  const [isDropdownOpen, setIsDropdownOpen] = (0, import_react12.useState)(false);
  const dropdownRef = (0, import_react12.useRef)(null);
  (0, import_react12.useEffect)(() => {
    const handleClickOutside = (event) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target)) {
        setIsDropdownOpen(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [dropdownRef]);
  const dashboardUrl = (0, import_react12.useMemo)(() => {
    if (!isAuthenticated || !appUrl) return "#";
    const baseUrl = appUrl.endsWith("/") ? appUrl : `${appUrl}/`;
    return `${baseUrl}admin-dashboard/`;
  }, [isAuthenticated, appUrl]);
  if (isAuthenticated) {
    if (!isOnline) {
      return /* @__PURE__ */ import_react12.default.createElement(StyledButton2, { className: "reconnecting", disabled: true }, /* @__PURE__ */ import_react12.default.createElement(CalimeroLogo_default, { className: "calimero-logo" }), "Reconnecting...");
    }
    return /* @__PURE__ */ import_react12.default.createElement(ConnectedContainer, { ref: dropdownRef }, /* @__PURE__ */ import_react12.default.createElement(
      StyledButton2,
      {
        className: "connected",
        onClick: () => setIsDropdownOpen((prev) => !prev)
      },
      /* @__PURE__ */ import_react12.default.createElement(CalimeroLogo_default, { className: "calimero-logo" }),
      "Connected"
    ), isDropdownOpen && /* @__PURE__ */ import_react12.default.createElement(DropdownMenu, null, /* @__PURE__ */ import_react12.default.createElement(DropdownInfoItem, { title: appUrl || "" }, appUrl), /* @__PURE__ */ import_react12.default.createElement(
      DropdownItem,
      {
        href: dashboardUrl,
        target: "_blank",
        rel: "noopener noreferrer"
      },
      "Dashboard"
    ), /* @__PURE__ */ import_react12.default.createElement(DropdownItem, { as: "button", onClick: logout }, "Log out")));
  }
  return /* @__PURE__ */ import_react12.default.createElement(StyledButton2, { onClick: login }, /* @__PURE__ */ import_react12.default.createElement(CalimeroLogo_default, { className: "calimero-logo" }), "Connect");
};
var CalimeroConnectButton_default = CalimeroConnectButton;

// src/login/ClientLogin.tsx
var import_react16 = __toESM(require("react"), 1);

// src/login/Components.ts
var import_styled_components7 = __toESM(require("styled-components"), 1);
var LoginContainer = import_styled_components7.default.div`
  display: flex;
  flex-direction: column;
  align-items: center;
`;
var LoginHeader = import_styled_components7.default.div`
  margin-top: 1.5rem;
  display: grid;
  color: white;
  font-size: 1.25rem;
  font-weight: 500;
  text-align: center;
`;
var LoginHeaderSpan = import_styled_components7.default.span`
  margin-bottom: 0.5rem;
  color: #fff;
`;
var LoginButton = import_styled_components7.default.button`
  background-color: #ff7a00;
  color: white;
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 0.5rem;
  height: 46px;
  cursor: pointer;
  font-size: 1rem;
  font-weight: 500;
  border-radius: 0.375rem;
  border: none;
  outline: none;
  padding-left: 0.5rem;
  padding-right: 0.5rem;

  &:hover {
    background-color: #ff7a00;
  }

  &:disabled {
    background-color: #6b7280;
  }
`;
var ErrorMessage3 = import_styled_components7.default.div`
  color: #ef4444;
  font-size: 1.25rem;
  text-align: center;
  margin-bottom: 2rem;
`;
var ContextModal2 = import_styled_components7.default.div`
  display: flex;
  position: relative;
  flex-direction: column;
  justify-content: center;
  border-radius: 0.375rem;
  align-items: center;
  background-color: #17191b;
`;
var ContextTitle = import_styled_components7.default.div`
  font-size: 1.25rem;
  font-weight: 700;
  line-height: 2rem;
  color: #fff;
  text-align: center;
`;
var ContextWrapper = import_styled_components7.default.div`
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  margin-top: 1.25rem;
  color: #fff;
  width: 100%;
`;
var ContextSubtitle = import_styled_components7.default.div`
  color: ${(props) => props.color || "#6b7280"};
  font-weight: 500;
  font-size: 0.875rem;
  word-break: break-all;
  display: flex;
  gap: 0.5rem;
  ${({ separator }) => separator && `
    border-bottom: 1px solid #23262d;
  `}
`;
var AppIdContainer = import_styled_components7.default.div`
  color: #fff;
  display: flex;
  align-items: center;
  gap: 0.5rem;
`;
var ContextListContainer = import_styled_components7.default.div`
  display: flex;
  flex-direction: column;
  max-height: 200px;
  overflow-y: auto;
`;
var NoContextWrapper = import_styled_components7.default.div`
  margin-top: 1rem;
  display: flex;
  flex-direction: column;
  gap: 1rem;
`;
var NoContextMessage = import_styled_components7.default.div`
  text-align: center;
  font-size: 0.875rem;
  color: #6b7280;
`;
var ModalOverlay = import_styled_components7.default.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.7);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
`;
var ModalContent = import_styled_components7.default.div`
  background-color: #17191b;
  padding: 2rem;
  border-radius: 8px;
  width: 90%;
  max-width: 500px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
`;
var Button2 = import_styled_components7.default.button`
  color: white;
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 0.5rem;
  height: 46px;
  font-size: 1rem;
  font-weight: 500;
  border-radius: 0.375rem;
  border: none;
  outline: none;
  padding: 0.5rem;
  cursor: pointer;
  background-color: #6b7280;
  transition: background-color 0.2s ease;

  &:disabled {
    background-color: #6b7280;
    cursor: not-allowed;
  }
`;

// src/setup/Components.ts
var import_styled_components8 = __toESM(require("styled-components"), 1);
var SetupModalOverlay = import_styled_components8.default.div`
  display: flex;
  justify-content: center;
  background-color: #111111;
`;
var SetupModalContainer = import_styled_components8.default.div`
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
`;
var SetupModalContent = import_styled_components8.default.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  background-color: #1c1c1c;
  padding: 1rem;
  border-radius: 0.5rem;
  color: white;
`;
var SetupFormContainer = import_styled_components8.default.div`
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  gap: 2rem;
  padding: 0 2rem;
`;
var SetupTitle = import_styled_components8.default.h1`
  font-size: 1.5rem;
  font-weight: 500;
  margin-bottom: 1rem;
  color: white;
`;
var SetupInputGroup = import_styled_components8.default.div`
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  width: 100%;
`;
var SetupInputField = import_styled_components8.default.input`
  width: 400px;
  padding: 0.8rem;
  border-radius: 0.375rem;
  border: none;
  background-color: #333;
  color: white;
  font-size: 16px;

  &::placeholder {
    color: #888;
  }
`;
var SetupErrorText = import_styled_components8.default.span`
  color: #ef4444;
  font-size: 0.875rem;
  min-height: 1.2em;
`;
var SetupSubmitButton = import_styled_components8.default.button`
  color: white;
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 0.5rem;
  height: 46px;
  font-size: 1rem;
  font-weight: 500;
  border-radius: 0.375rem;
  border: none;
  outline: none;
  padding: 0.5rem;
  cursor: pointer;
  background-color: #ff7a00;
  transition: background-color 0.2s ease;

  &:disabled {
    background-color: #6b7280;
    cursor: not-allowed;
  }

  &:hover {
    background-color: #ff8c00;
  }
`;
var SetupSpinnerContainer = import_styled_components8.default.div`
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 200px;
`;

// src/login/noAuth/SelectContext.tsx
var import_react14 = __toESM(require("react"), 1);

// src/login/noAuth/ListItem.tsx
var import_react13 = __toESM(require("react"), 1);
var import_styled_components9 = __toESM(require("styled-components"), 1);
var RowItem = import_styled_components9.default.div`
  display: flex;
  width: 100%;
  align-items: center;
  gap: 1px;
  font-size: 0.875rem;
  text-align: left;
  padding-right: 1.5rem;
  border-top: 1px solid #23262d;
  ${(props) => props.$hasBorders && `border-bottom: 1px solid #23262D;`}

  .row-item {
    padding: 0.75rem 0rem;
    display: flex;
    align-items: center;
    width: 25%;
  }
  .name {
    text-align: left;
    &:hover {
      color: #4cfafc;
      cursor: pointer;
    }
  }
`;
function ListItem2({
  item,
  id,
  count,
  onRowItemClick
}) {
  return /* @__PURE__ */ import_react13.default.createElement(RowItem, { key: id, $hasBorders: id === count }, /* @__PURE__ */ import_react13.default.createElement(
    "div",
    {
      className: "row-item name",
      onClick: () => onRowItemClick && onRowItemClick(item)
    },
    item
  ));
}

// src/login/noAuth/SelectContext.tsx
var SelectContext = ({
  contextList,
  setSelectedContextId,
  backStep
}) => {
  const handleContextSelection = (selectedContextId) => {
    setSelectedContextId(selectedContextId);
  };
  return /* @__PURE__ */ import_react14.default.createElement(ContextModal2, null, /* @__PURE__ */ import_react14.default.createElement(ContextWrapper, null, /* @__PURE__ */ import_react14.default.createElement(ContextSubtitle, { color: "#fff" }, /* @__PURE__ */ import_react14.default.createElement("span", null, "Select a context:")), contextList.length > 0 ? /* @__PURE__ */ import_react14.default.createElement(import_react14.default.Fragment, null, /* @__PURE__ */ import_react14.default.createElement(ContextListContainer, null, contextList.map((context, i) => /* @__PURE__ */ import_react14.default.createElement(
    ListItem2,
    {
      key: context.id,
      item: context.id,
      id: i,
      count: contextList.length,
      onRowItemClick: handleContextSelection
    }
  ))), backStep && /* @__PURE__ */ import_react14.default.createElement(Button2, { onClick: backStep }, "Back")) : /* @__PURE__ */ import_react14.default.createElement(NoContextWrapper, null, /* @__PURE__ */ import_react14.default.createElement(NoContextMessage, null, "No contexts found"))));
};

// src/login/noAuth/SelectContextIdentity.tsx
var import_react15 = __toESM(require("react"), 1);
var SelectContextIdentity = ({
  contextIdentities,
  selectedContextId,
  onSelectIdentity,
  backStep
}) => {
  const truncateText = (text) => {
    return `${text.substring(0, 4)}...${text.substring(
      text.length - 4,
      text.length
    )}`;
  };
  return /* @__PURE__ */ import_react15.default.createElement(ContextModal2, null, /* @__PURE__ */ import_react15.default.createElement(ContextTitle, null, "Select Context Identity"), /* @__PURE__ */ import_react15.default.createElement(ContextWrapper, null, /* @__PURE__ */ import_react15.default.createElement(ContextSubtitle, { separator: true, color: "#fff" }, /* @__PURE__ */ import_react15.default.createElement("span", null, "Currently selected:")), /* @__PURE__ */ import_react15.default.createElement(ContextSubtitle, null, /* @__PURE__ */ import_react15.default.createElement("span", null, "Context ID"), /* @__PURE__ */ import_react15.default.createElement(AppIdContainer, null, /* @__PURE__ */ import_react15.default.createElement("span", null, truncateText(selectedContextId))))), /* @__PURE__ */ import_react15.default.createElement(ContextWrapper, null, /* @__PURE__ */ import_react15.default.createElement(ContextSubtitle, { color: "#fff" }, /* @__PURE__ */ import_react15.default.createElement("span", null, "Select an identity to login:")), contextIdentities.length > 0 ? /* @__PURE__ */ import_react15.default.createElement(ContextListContainer, null, contextIdentities.map((identity, i) => /* @__PURE__ */ import_react15.default.createElement(
    ListItem2,
    {
      key: i,
      item: identity,
      id: i,
      count: contextIdentities.length,
      onRowItemClick: () => onSelectIdentity(selectedContextId, identity)
    }
  ))) : /* @__PURE__ */ import_react15.default.createElement(NoContextWrapper, null, /* @__PURE__ */ import_react15.default.createElement(NoContextMessage, null, "No identities found"))), /* @__PURE__ */ import_react15.default.createElement(ContextWrapper, null, backStep && /* @__PURE__ */ import_react15.default.createElement(Button2, { onClick: backStep }, "Back to context selection")));
};

// src/login/ClientLogin.tsx
var initialState = {
  nodeServerUrl: "",
  applicationId: "",
  selectedContextId: "",
  contexts: [],
  contextIdentities: [],
  errorMessage: "",
  isLoading: false
};
var ClientLogin = ({
  permissions,
  authMode,
  setIsAuthenticated,
  clientApplicationId,
  clientApplicationPath,
  fetchContextApplication,
  onReset
}) => {
  const [state, setState] = (0, import_react16.useState)({
    ...initialState,
    nodeServerUrl: getAppEndpointKey() ?? "",
    applicationId: getApplicationId() ?? ""
  });
  const {
    nodeServerUrl,
    selectedContextId,
    contexts,
    contextIdentities,
    errorMessage,
    isLoading
  } = state;
  const updateState = (newState) => {
    setState((prev) => ({ ...prev, ...newState }));
  };
  const resetSetup = () => {
    clearAppEndpoint();
    clearAccessToken();
    clearContextId();
    clearExecutorPublicKey();
    clearApplicationId();
    onReset();
  };
  const fetchAvailableContexts = (0, import_react16.useCallback)(async () => {
    if (errorMessage) return;
    try {
      const response = await apiClient.node().getContexts();
      if (response.error) {
        updateState({ errorMessage: response.error.message, isLoading: false });
        return;
      }
      updateState({ contexts: response.data?.contexts, isLoading: false });
    } catch (error) {
      updateState({
        errorMessage: "Failed to fetch contexts",
        isLoading: false
      });
    }
  }, [errorMessage]);
  const fetchContextIdentities = (0, import_react16.useCallback)(async () => {
    if (!selectedContextId) return;
    try {
      const response = await apiClient.node().fetchContextIdentities(selectedContextId);
      if (response.error) {
        updateState({ errorMessage: response.error.message });
        return;
      }
      updateState({ contextIdentities: response.data.identities });
    } catch (error) {
      updateState({ errorMessage: "Failed to fetch context identities" });
    }
  }, [selectedContextId]);
  const handleIdentitySelection = (contextId, identity) => {
    setContextId(contextId);
    setExecutorPublicKey(identity);
    fetchContextApplication();
  };
  const login = (0, import_react16.useCallback)(async () => {
    apiClient.auth().login({
      url: nodeServerUrl,
      callbackUrl: window.location.href,
      permissions,
      applicationId: clientApplicationId,
      applicationPath: clientApplicationPath
    });
  }, [nodeServerUrl, permissions, clientApplicationId, clientApplicationPath]);
  (0, import_react16.useEffect)(() => {
    if (authMode === false) {
      updateState({ isLoading: true });
      fetchAvailableContexts();
    }
  }, [nodeServerUrl, fetchAvailableContexts, authMode]);
  (0, import_react16.useEffect)(() => {
    if (selectedContextId) {
      fetchContextIdentities();
    }
  }, [selectedContextId, fetchContextIdentities]);
  const renderLoginContent = () => {
    if (isLoading) {
      return /* @__PURE__ */ import_react16.default.createElement(SetupSpinnerContainer, null, /* @__PURE__ */ import_react16.default.createElement(Spinner, null));
    }
    if (authMode === true) {
      return /* @__PURE__ */ import_react16.default.createElement(import_react16.default.Fragment, null, /* @__PURE__ */ import_react16.default.createElement(LoginButton, { onClick: login }, "Login"), /* @__PURE__ */ import_react16.default.createElement(Button2, { onClick: resetSetup, style: { marginTop: "1rem" } }, "Back to Setup"));
    }
    return /* @__PURE__ */ import_react16.default.createElement(import_react16.default.Fragment, null, /* @__PURE__ */ import_react16.default.createElement(LoginHeader, null, /* @__PURE__ */ import_react16.default.createElement(LoginHeaderSpan, null, "Select Context ID and Identity")), !selectedContextId ? /* @__PURE__ */ import_react16.default.createElement(
      SelectContext,
      {
        contextList: contexts,
        setSelectedContextId: (id) => updateState({ selectedContextId: id })
      }
    ) : /* @__PURE__ */ import_react16.default.createElement(
      SelectContextIdentity,
      {
        selectedContextId,
        contextIdentities,
        onSelectIdentity: handleIdentitySelection,
        backStep: () => updateState({ selectedContextId: "" })
      }
    ), /* @__PURE__ */ import_react16.default.createElement(Button2, { onClick: resetSetup, style: { marginTop: "1rem" } }, "Back to Setup"));
  };
  return /* @__PURE__ */ import_react16.default.createElement(ModalOverlay, null, /* @__PURE__ */ import_react16.default.createElement(ModalContent, null, errorMessage && /* @__PURE__ */ import_react16.default.createElement(import_react16.default.Fragment, null, /* @__PURE__ */ import_react16.default.createElement(ErrorMessage3, null, errorMessage), /* @__PURE__ */ import_react16.default.createElement(Button2, { onClick: resetSetup, style: { marginTop: "1rem" } }, "Back to Setup")), renderLoginContent()));
};

// src/login/ProtectedRoutesWrapper.tsx
var import_react19 = __toESM(require("react"), 1);

// src/setup/SetupModal.tsx
var import_react17 = __toESM(require("react"), 1);
var import_react18 = require("react");
var initialState2 = {
  url: "",
  errors: {
    url: "",
    applicationId: ""
  },
  isLoading: false
};
var validateUrl = (url) => {
  try {
    new URL(url);
    return true;
  } catch {
    return false;
  }
};
var SetupModal = ({ setNodeServerUrl }) => {
  const [state, setState] = (0, import_react18.useState)(initialState2);
  const { url, errors, isLoading } = state;
  const updateState = (newState) => {
    setState((prev) => ({ ...prev, ...newState }));
  };
  const updateError = (field, message) => {
    setState((prev) => ({
      ...prev,
      errors: {
        ...prev.errors,
        [field]: message
      }
    }));
  };
  const handleUrlChange = (value) => {
    updateState({
      url: value,
      errors: {
        ...state.errors,
        url: ""
      }
    });
  };
  const handleSubmit = (0, import_react18.useCallback)(async () => {
    if (!url) return;
    if (!validateUrl(url)) {
      updateError(
        "url",
        "Connection failed. Please check if node url is correct."
      );
      return;
    }
    updateState({ isLoading: true });
    setAppEndpointKey(url);
    setNodeServerUrl(url);
  }, [url, setNodeServerUrl]);
  const onFormSubmit = (e) => {
    e.preventDefault();
    if (!isSubmitDisabled) {
      handleSubmit();
    }
  };
  const isSubmitDisabled = !url || Boolean(errors.url);
  (0, import_react17.useEffect)(() => {
    const fragment = window.location.hash.substring(1);
    const fragmentParams = new URLSearchParams(fragment);
    const nodeUrl = fragmentParams.get("node_url");
    if (nodeUrl) {
      handleUrlChange(decodeURIComponent(nodeUrl));
      fragmentParams.delete("node_url");
      const newFragment = fragmentParams.toString();
      const newUrl = window.location.pathname + window.location.search + (newFragment ? `#${newFragment}` : "");
      window.history.replaceState({}, "", newUrl);
    }
  }, []);
  return /* @__PURE__ */ import_react17.default.createElement(SetupModalOverlay, null, /* @__PURE__ */ import_react17.default.createElement(SetupModalContainer, null, /* @__PURE__ */ import_react17.default.createElement(SetupModalContent, null, /* @__PURE__ */ import_react17.default.createElement(SetupFormContainer, null, /* @__PURE__ */ import_react17.default.createElement(SetupTitle, null, "Connect to Calimero Node"), isLoading ? /* @__PURE__ */ import_react17.default.createElement(SetupSpinnerContainer, null, /* @__PURE__ */ import_react17.default.createElement(Spinner, null)) : /* @__PURE__ */ import_react17.default.createElement("form", { onSubmit: onFormSubmit }, /* @__PURE__ */ import_react17.default.createElement(SetupInputGroup, null, /* @__PURE__ */ import_react17.default.createElement(
    SetupInputField,
    {
      type: "text",
      placeholder: "Node URL",
      inputMode: "url",
      value: url,
      onChange: (e) => handleUrlChange(e.target.value),
      "aria-invalid": !!errors.url,
      "aria-describedby": "urlError"
    }
  ), /* @__PURE__ */ import_react17.default.createElement(SetupErrorText, null, errors.url), /* @__PURE__ */ import_react17.default.createElement(SetupSubmitButton, { type: "submit", disabled: isSubmitDisabled }, /* @__PURE__ */ import_react17.default.createElement("span", null, "Continue"))))))));
};

// src/login/ProtectedRoutesWrapper.tsx
var ProtectedRoutesWrapper = ({
  children,
  permissions = [],
  applicationId = "",
  clientApplicationPath = ""
}) => {
  const [isAuthenticated, setIsAuthenticated] = (0, import_react19.useState)(false);
  const [isInitialized, setIsInitialized] = (0, import_react19.useState)(false);
  const [isLoading, setIsLoading] = (0, import_react19.useState)(true);
  const [authMode, setAuthMode] = (0, import_react19.useState)(null);
  const [error, setError] = (0, import_react19.useState)(null);
  const isAdminDashboardUrl = () => {
    const nodeUrl = getAppEndpointKey();
    const currentUrl = window.location.href;
    if (!nodeUrl) return false;
    return currentUrl.includes("/admin-dashboard");
  };
  const handleReset = () => {
    setAuthMode(null);
    setIsAuthenticated(false);
    setIsInitialized(false);
    setError(null);
    clearAppEndpoint();
    clearAccessToken();
    clearRefreshToken();
    clearApplicationId();
    clearContextId();
    clearExecutorPublicKey();
    checkAuth();
  };
  const initializeApplication = async (accessToken, refreshToken, appId) => {
    try {
      setIsLoading(true);
      setAccessToken(accessToken);
      setRefreshToken(refreshToken);
      setContextAndIdentityFromJWT(accessToken);
      if (appId) {
        setApplicationId(appId);
        setIsInitialized(true);
        setIsAuthenticated(true);
      } else {
        const contextId = getContextId();
        if (contextId) {
          const response = await apiClient.node().getContext(contextId);
          if (response.error) {
            setError(response.error.message);
            return;
          }
          setApplicationId(response.data.applicationId);
        }
        setIsInitialized(true);
        setIsAuthenticated(true);
      }
    } catch (error2) {
      setError("Failed to initialize application");
      setIsInitialized(false);
      setIsAuthenticated(false);
    } finally {
      setIsLoading(false);
    }
  };
  const fetchContextApplication = async () => {
    try {
      const contextId = getContextId();
      const response = await apiClient.node().getContext(contextId);
      if (response.error) {
        setError(response.error.message);
        return;
      }
      setApplicationId(response.data.applicationId);
      setAuthMode(false);
      if (getAccessToken()) {
        setAuthMode(true);
      }
      setIsInitialized(true);
      setIsAuthenticated(true);
    } catch (error2) {
      setError("Failed to fetch context application");
      setIsInitialized(false);
    }
    setIsLoading(false);
  };
  const updateState = (newState) => {
    setAppEndpointKey(newState.nodeServerUrl);
    setError(null);
    checkAuth();
  };
  const checkAuthMode = async () => {
    const nodeUrl = getAppEndpointKey();
    if (!nodeUrl) {
      setError("Missing node URL configuration");
      setAuthMode(null);
      setIsLoading(false);
      return;
    }
    try {
      const response = await apiClient.node().checkAuth();
      if (response.error?.code === 401) {
        setAuthMode(true);
      } else if (response.error) {
        setError(response.error.message);
      } else {
        setAuthMode(false);
      }
    } catch (error2) {
      setError("Failed to check auth mode");
    }
    setIsLoading(false);
  };
  const checkAuth = (0, import_react19.useCallback)(async () => {
    setIsLoading(true);
    const storedApplicationId = getApplicationId();
    const storedContextId = getContextId();
    const storedExecutorPublicKey = getExecutorPublicKey();
    const storedAccessToken = getAccessToken();
    const storedRefreshToken = getRefreshToken();
    if (storedAccessToken && storedRefreshToken && storedApplicationId && storedContextId && storedExecutorPublicKey) {
      setAuthMode(true);
      setIsAuthenticated(true);
      setIsInitialized(true);
      setIsLoading(false);
      return;
    }
    if (storedApplicationId && storedContextId && storedExecutorPublicKey && !storedAccessToken) {
      setAuthMode(false);
      setIsAuthenticated(true);
      setIsInitialized(true);
      setIsLoading(false);
      return;
    }
    const token = getAccessToken();
    const jwt = getJWTObject();
    if (token && jwt) {
      await checkAuthMode();
      if (!error) {
        const contextId = getContextId();
        const executorPublicKey = getExecutorPublicKey();
        console.log("contextId", contextId);
        console.log("executorPublicKey", executorPublicKey);
        if (contextId && executorPublicKey) {
          await fetchContextApplication();
        }
      }
    } else {
      await checkAuthMode();
      if (authMode === false && !error) {
        const contextId = getContextId();
        const executorPublicKey = getExecutorPublicKey();
        console.log("contextId", contextId);
        console.log("executorPublicKey", executorPublicKey);
        if (contextId && executorPublicKey) {
          await fetchContextApplication();
        }
      }
    }
    setIsLoading(false);
  }, [authMode, error]);
  (0, import_react19.useEffect)(() => {
    const fragment = window.location.hash.substring(1);
    const fragmentParams = new URLSearchParams(fragment);
    const encodedAccessToken = fragmentParams.get("access_token");
    const encodedRefreshToken = fragmentParams.get("refresh_token");
    if (encodedAccessToken && encodedRefreshToken) {
      const accessToken = decodeURIComponent(encodedAccessToken);
      const refreshToken = decodeURIComponent(encodedRefreshToken);
      setContextAndIdentityFromJWT(accessToken);
      initializeApplication(
        accessToken,
        refreshToken,
        applicationId || void 0
      );
      fragmentParams.delete("access_token");
      fragmentParams.delete("refresh_token");
      const newFragment = fragmentParams.toString();
      const newUrl = window.location.pathname + window.location.search + (newFragment ? `#${newFragment}` : "");
      window.history.replaceState({}, "", newUrl);
      setIsAuthenticated(true);
      setIsInitialized(true);
    } else {
      checkAuth();
    }
  }, [applicationId, checkAuth]);
  if (isLoading) {
    return /* @__PURE__ */ import_react19.default.createElement(ModalOverlay, null, /* @__PURE__ */ import_react19.default.createElement(ModalContent, null, /* @__PURE__ */ import_react19.default.createElement(SetupSpinnerContainer, null, /* @__PURE__ */ import_react19.default.createElement(Spinner, null))));
  }
  if (!getAppEndpointKey()) {
    return /* @__PURE__ */ import_react19.default.createElement(ModalOverlay, null, /* @__PURE__ */ import_react19.default.createElement(ModalContent, null, /* @__PURE__ */ import_react19.default.createElement(
      SetupModal,
      {
        setNodeServerUrl: (url) => {
          setError(null);
          updateState({ nodeServerUrl: url });
          checkAuth();
        }
      }
    )));
  }
  if (error) {
    return /* @__PURE__ */ import_react19.default.createElement(ModalOverlay, null, /* @__PURE__ */ import_react19.default.createElement(ModalContent, null, /* @__PURE__ */ import_react19.default.createElement(ErrorMessage3, null, error), /* @__PURE__ */ import_react19.default.createElement(Button2, { onClick: handleReset }, "Reset")));
  }
  if (authMode === false && isAdminDashboardUrl()) {
    return /* @__PURE__ */ import_react19.default.createElement(import_react19.default.Fragment, null, children);
  }
  if (authMode !== null && (!isAuthenticated || !isInitialized)) {
    return /* @__PURE__ */ import_react19.default.createElement(
      ClientLogin,
      {
        permissions,
        authMode,
        setIsAuthenticated,
        clientApplicationId: applicationId,
        clientApplicationPath,
        fetchContextApplication,
        onReset: handleReset
      }
    );
  }
  return isAuthenticated && isInitialized ? /* @__PURE__ */ import_react19.default.createElement(import_react19.default.Fragment, null, children) : null;
};

// src/subscriptions/ws.ts
var DEFAULT_CONNECTION_ID = "DEFAULT";
var WsSubscriptionsClient = class {
  constructor(baseUrl, path) {
    __publicField(this, "url");
    __publicField(this, "connections");
    __publicField(this, "callbacks");
    this.url = `${baseUrl}${path}`;
    this.connections = /* @__PURE__ */ new Map();
    this.callbacks = /* @__PURE__ */ new Map();
  }
  connect(connectionId = DEFAULT_CONNECTION_ID) {
    return new Promise((resolve, reject) => {
      const websocket = new WebSocket(this.url);
      this.connections.set(connectionId, websocket);
      this.callbacks.set(connectionId, []);
      websocket.onopen = () => {
        resolve();
      };
      websocket.onerror = (error) => {
        reject(error);
      };
      websocket.onmessage = (event) => this.handleMessage(connectionId, event);
    });
  }
  disconnect(connectionId = DEFAULT_CONNECTION_ID) {
    const websocket = this.connections.get(connectionId);
    if (websocket) {
      websocket.close();
      this.connections.delete(connectionId);
      this.callbacks.delete(connectionId);
    }
  }
  subscribe(contextIds, connectionId = DEFAULT_CONNECTION_ID) {
    const websocket = this.connections.get(connectionId);
    if (websocket && websocket.readyState === websocket.OPEN) {
      const requestId = this.getRandomRequestId();
      const request = {
        id: requestId,
        method: "subscribe",
        params: {
          contextIds
        }
      };
      websocket.send(JSON.stringify(request));
    }
  }
  unsubscribe(contextIds, connectionId = DEFAULT_CONNECTION_ID) {
    const websocket = this.connections.get(connectionId);
    if (websocket && websocket.readyState === websocket.OPEN) {
      const requestId = this.getRandomRequestId();
      const request = {
        id: requestId,
        method: "unsubscribe",
        params: {
          contextIds
        }
      };
      websocket.send(JSON.stringify(request));
    }
  }
  addCallback(callback, connectionId = DEFAULT_CONNECTION_ID) {
    if (!this.callbacks.has(connectionId)) {
      this.callbacks.set(connectionId, [callback]);
    } else {
      this.callbacks.get(connectionId).push(callback);
    }
  }
  removeCallback(callback, connectionId = DEFAULT_CONNECTION_ID) {
    const callbacks = this.callbacks.get(connectionId);
    if (callbacks) {
      const index = callbacks.indexOf(callback);
      if (index !== -1) {
        callbacks.splice(index, 1);
      }
    }
  }
  handleMessage(connectionId, event) {
    const response = JSON.parse(event.data.toString());
    if (response.id !== null) {
      return;
    }
    if (response.error !== void 0) {
      return;
    }
    const callbacks = this.callbacks.get(connectionId);
    if (callbacks) {
      for (const callback of callbacks) {
        const nodeEvent = response.result;
        callback(nodeEvent);
      }
    }
  }
  getRandomRequestId() {
    return Math.floor(Math.random() * Math.pow(2, 32));
  }
};
