#!/usr/bin/env node
import fs from 'fs';
import path from 'path';
const getArgs = () => {
    const args = {};
    process.argv.slice(2).forEach((arg) => {
        if (arg.startsWith('--')) {
            const [key, value] = arg.split('=');
            args[key.substring(2)] = value;
        }
    });
    return args;
};
const args = getArgs();
const abiPath = args.abi || 'abi.json';
const outputPath = args.out || 'src/generated-client.ts';
const abiFilePath = path.resolve(process.cwd(), abiPath);
const outputFilePath = path.resolve(process.cwd(), outputPath);
if (!fs.existsSync(abiFilePath)) {
    console.error(`Error: ABI file not found at ${abiFilePath}`);
    process.exit(1);
}
const abi = JSON.parse(fs.readFileSync(abiFilePath, 'utf-8'));
const mapAbiTypeToTs = (abiType) => {
    let typeStr = abiType.type.trim();
    // Extract content from Result<T> if present, e.g., "app :: Result <T>" -> "T"
    const resultMatch = typeStr.match(/Result < (.*) >/);
    if (resultMatch) {
        typeStr = resultMatch[1].trim();
    }
    // Handle Option<T> -> T | null
    const optionMatch = typeStr.match(/Option < (.*) >/);
    if (optionMatch) {
        const innerType = mapAbiTypeToTs({ type: optionMatch[1] });
        return `${innerType} | null`;
    }
    // Handle BTreeMap<K, V> -> Map<K, V>
    const mapMatch = typeStr.match(/BTreeMap < (.*), (.*) >/);
    if (mapMatch) {
        const keyType = mapAbiTypeToTs({ type: mapMatch[1] });
        const valueType = mapAbiTypeToTs({ type: mapMatch[2] });
        return `Map<${keyType}, ${valueType}>`;
    }
    // Handle unit type "()" -> void
    if (typeStr === '()') {
        return 'void';
    }
    const lowerTypeStr = typeStr.toLowerCase();
    if (lowerTypeStr.includes('string') || lowerTypeStr.includes('str')) {
        return 'string';
    }
    if (['usize', 'u64', 'u32', 'u16', 'u8'].some((numType) => lowerTypeStr.includes(numType))) {
        return 'number';
    }
    return 'any';
};
const generateMethod = (method) => {
    const argsName = 'params';
    const hasArgs = method.args.length > 0;
    const argsType = hasArgs
        ? `{ ${method.args.map((arg) => `${arg.name}: ${mapAbiTypeToTs(arg.type)}`).join('; ')} }`
        : '';
    const params = hasArgs ? `${argsName}: ${argsType}` : '';
    const returnType = mapAbiTypeToTs(method.result);
    const returnStatement = returnType === 'void'
        ? 'return;'
        : `return response.result as ${returnType};`;
    return `
  public async ${method.name}(${params}): Promise<${returnType}> {
    const response = await this.app.execute(this.context, '${method.name}', ${hasArgs ? argsName : '{}'});
    if (response.success) {
      ${returnStatement}
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }
`;
};
const classString = `/* eslint-disable */
// Auto-generated by calimero-sdk-codegen. Do not edit.

import { CalimeroApp, Context } from '@calimero-network/calimero-client';

export class ContractClient {
  private app: CalimeroApp;
  private context: Context;

  constructor(app: CalimeroApp, context: Context) {
    this.app = app;
    this.context = context;
  }
${abi.methods.map(generateMethod).join('')}
}
`;
const outputDir = path.dirname(outputFilePath);
if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
}
fs.writeFileSync(outputFilePath, classString, 'utf-8');
console.log(`âœ… Contract client generated successfully at ${outputFilePath}`);
