#!/usr/bin/env node
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// src/cli.ts
var import_fs = __toESM(require("fs"), 1);
var import_path = __toESM(require("path"), 1);
var getArgs = () => {
  const args2 = {};
  process.argv.slice(2).forEach((arg) => {
    if (arg.startsWith("--")) {
      const [key, value] = arg.split("=");
      args2[key.substring(2)] = value;
    }
  });
  return args2;
};
var args = getArgs();
var abiPath = args.abi || "abi.json";
var outputPath = args.out || "src/generated-client.ts";
var abiFilePath = import_path.default.resolve(process.cwd(), abiPath);
var outputFilePath = import_path.default.resolve(process.cwd(), outputPath);
if (!import_fs.default.existsSync(abiFilePath)) {
  console.error(`Error: ABI file not found at ${abiFilePath}`);
  process.exit(1);
}
var abi = JSON.parse(import_fs.default.readFileSync(abiFilePath, "utf-8"));
var mapAbiTypeToTs = (abiType) => {
  let typeStr = abiType.type.trim();
  const resultMatch = typeStr.match(/Result < (.*) >/);
  if (resultMatch) {
    typeStr = resultMatch[1].trim();
  }
  const optionMatch = typeStr.match(/Option < (.*) >/);
  if (optionMatch) {
    const innerType = mapAbiTypeToTs({ type: optionMatch[1] });
    return `${innerType} | null`;
  }
  const mapMatch = typeStr.match(/BTreeMap < (.*), (.*) >/);
  if (mapMatch) {
    const keyType = mapAbiTypeToTs({ type: mapMatch[1] });
    const valueType = mapAbiTypeToTs({ type: mapMatch[2] });
    return `Map<${keyType}, ${valueType}>`;
  }
  if (typeStr === "()") {
    return "void";
  }
  const lowerTypeStr = typeStr.toLowerCase();
  if (lowerTypeStr.includes("string") || lowerTypeStr.includes("str")) {
    return "string";
  }
  if (["usize", "u64", "u32", "u16", "u8"].some(
    (numType) => lowerTypeStr.includes(numType)
  )) {
    return "number";
  }
  return "any";
};
var generateMethod = (method) => {
  const argsName = "params";
  const hasArgs = method.args.length > 0;
  const argsType = hasArgs ? `{ ${method.args.map((arg) => `${arg.name}: ${mapAbiTypeToTs(arg.type)}`).join("; ")} }` : "";
  const params = hasArgs ? `${argsName}: ${argsType}` : "";
  const returnType = mapAbiTypeToTs(method.result);
  const returnStatement = returnType === "void" ? "return;" : `return response.result as ${returnType};`;
  return `
  public async ${method.name}(${params}): Promise<${returnType}> {
    const response = await this.app.execute(this.context, '${method.name}', ${hasArgs ? argsName : "{}"});
    if (response.success) {
      ${returnStatement}
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }
`;
};
var classString = `/* eslint-disable */
// Auto-generated by calimero-sdk-codegen. Do not edit.

import { CalimeroApp, Context } from '@calimero-network/calimero-client';

export class ContractClient {
  private app: CalimeroApp;
  private context: Context;

  constructor(app: CalimeroApp, context: Context) {
    this.app = app;
    this.context = context;
  }
${abi.methods.map(generateMethod).join("")}
}
`;
var outputDir = import_path.default.dirname(outputFilePath);
if (!import_fs.default.existsSync(outputDir)) {
  import_fs.default.mkdirSync(outputDir, { recursive: true });
}
import_fs.default.writeFileSync(outputFilePath, classString, "utf-8");
console.log(`\u2705 Contract client generated successfully at ${outputFilePath}`);
