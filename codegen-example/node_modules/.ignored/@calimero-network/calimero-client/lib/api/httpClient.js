import { AxiosError } from 'axios';
import { getAccessToken, getRefreshToken, clearAccessToken, setAccessToken, setRefreshToken, clientLogout, } from '../storage';
import { getAppEndpointKey } from '../storage';
import { authClient } from './index';
export class AxiosHttpClient {
    axios;
    isRefreshing = false;
    failedQueue = [];
    constructor(axios) {
        this.axios = axios;
    }
    isRefreshRequest(config) {
        const baseUrl = getAppEndpointKey();
        return config?.url === `${baseUrl}/public/refresh`;
    }
    processQueue(error, token = null) {
        // Filter out duplicate refresh requests from the queue
        const uniqueRequests = this.failedQueue.filter((promise) => !this.isRefreshRequest(promise.config));
        uniqueRequests.forEach((promise) => {
            if (error) {
                promise.reject(error);
            }
            else {
                // Retry the request with new token
                if (token) {
                    promise.config.headers.Authorization = `Bearer ${token}`;
                }
                promise.resolve(this.request(this.axios.request(promise.config)));
            }
        });
        this.failedQueue = [];
    }
    async handleTokenRefresh(originalRequest) {
        // If refresh is already in progress, queue this request
        if (this.isRefreshing) {
            // If this is another refresh request while one is in progress, just reject it
            if (this.isRefreshRequest(originalRequest)) {
                return Promise.reject(new Error('Token refresh already in progress'));
            }
            return new Promise((resolve, reject) => {
                this.failedQueue.push({
                    resolve,
                    reject,
                    config: originalRequest,
                });
            });
        }
        try {
            this.isRefreshing = true;
            const refreshToken = getRefreshToken();
            const accessToken = getAccessToken();
            if (!refreshToken || !accessToken) {
                throw new Error('Missing tokens for refresh');
            }
            const response = await authClient.refreshToken({
                access_token: accessToken,
                refresh_token: refreshToken,
            });
            if (response.error || !response.data) {
                throw new Error('Failed to refresh token');
            }
            // Update stored tokens
            setAccessToken(response.data.access_token);
            setRefreshToken(response.data.refresh_token);
            // Update the original request with new token
            originalRequest.headers.Authorization = `Bearer ${response.data.access_token}`;
            // Process queue with new token
            this.processQueue(null, response.data.access_token);
            // Reset refreshing state
            this.isRefreshing = false;
            // Retry original request
            return this.request(this.axios.request(originalRequest));
        }
        catch (error) {
            this.isRefreshing = false;
            this.processQueue(new Error('Failed to refresh token'));
            clearAccessToken();
            throw error;
        }
    }
    async request(promise, isJsonRpc = false, responseType) {
        try {
            const response = await promise;
            if (response?.config?.method?.toUpperCase() === 'HEAD') {
                // For HEAD requests, return headers and status
                // Convert axios headers to string record
                const headers = {};
                if (response.headers) {
                    Object.entries(response.headers).forEach(([key, value]) => {
                        if (value !== undefined) {
                            headers[key] = Array.isArray(value)
                                ? value.join(', ')
                                : String(value);
                        }
                    });
                }
                const headResponse = {
                    headers,
                    status: response.status,
                };
                return {
                    data: headResponse,
                    error: null,
                };
            }
            // For binary responses, return the raw data
            if (responseType === 'arraybuffer' || responseType === 'blob') {
                return {
                    data: response.data,
                    error: null,
                };
            }
            // For JSON-RPC requests, treat the entire response as the data
            // For regular API requests, expect and unwrap the data field
            const responseData = isJsonRpc
                ? response.data
                : response.data.data;
            return {
                data: responseData,
                error: null,
            };
        }
        catch (e) {
            if (e instanceof AxiosError) {
                const status = e.response?.status;
                const headers = e.response?.headers;
                const body = e.response?.data;
                // Handle 401 responses
                if (status === 401) {
                    // Check specific error type from X-Auth-Error header
                    const authError = headers?.['x-auth-error'];
                    switch (authError) {
                        case 'missing_token':
                            return {
                                data: null,
                                error: {
                                    code: 401,
                                    message: 'No access token found.',
                                },
                            };
                        case 'token_expired':
                            try {
                                // Attempt token refresh and retry original request
                                return await this.handleTokenRefresh(e.config);
                            }
                            catch (refreshError) {
                                clearAccessToken();
                                return {
                                    data: null,
                                    error: {
                                        code: 401,
                                        message: 'Session expired. Please log in again.',
                                    },
                                };
                            }
                        case 'token_revoked':
                            clientLogout();
                            return {
                                data: null,
                                error: {
                                    code: 401,
                                    message: 'Session was revoked. Please log in again.',
                                },
                            };
                        case 'invalid_token':
                            clientLogout();
                            return {
                                data: null,
                                error: {
                                    code: 401,
                                    message: 'Invalid authentication. Please log in again.',
                                },
                            };
                        default:
                            return {
                                data: null,
                                error: {
                                    code: 401,
                                    message: body.error,
                                },
                            };
                    }
                }
                // Handle other error cases
                if (e?.config?.method?.toUpperCase() === 'HEAD') {
                    return {
                        data: null,
                        error: {
                            code: e.request.status,
                            message: e.message,
                        },
                    };
                }
                const error = e.response?.data.error ?? e.response?.data;
                if (!error) {
                    return {
                        data: null,
                        error: {
                            code: status ?? 500,
                            message: e.message || 'Something went wrong',
                        },
                    };
                }
                if (typeof error === 'string') {
                    return {
                        data: null,
                        error: {
                            code: status ?? 500,
                            message: error,
                        },
                    };
                }
                return {
                    data: null,
                    error: {
                        code: status ?? error.code ?? 500,
                        message: error.message,
                    },
                };
            }
            return {
                data: null,
                error: GENERIC_ERROR,
            };
        }
    }
    getAuthHeaders() {
        const token = getAccessToken();
        return token ? { Authorization: `Bearer ${token}` } : {};
    }
    async get(url, headers, isJsonRpc = false, options) {
        const authHeaders = this.getAuthHeaders();
        const mergedHeaders = headers?.reduce((acc, curr) => ({ ...acc, ...curr }), {});
        return this.request(this.axios.get(url, {
            headers: { ...authHeaders, ...mergedHeaders },
            responseType: options?.responseType,
        }), isJsonRpc, options?.responseType);
    }
    async post(url, body, headers, isJsonRpc = false) {
        const authHeaders = this.getAuthHeaders();
        const mergedHeaders = headers?.reduce((acc, curr) => ({ ...acc, ...curr }), {});
        return this.request(this.axios.post(url, body, {
            headers: { ...authHeaders, ...mergedHeaders },
        }), isJsonRpc);
    }
    async put(url, body, headers, isJsonRpc = false, onUploadProgress) {
        const authHeaders = this.getAuthHeaders();
        const mergedHeaders = headers?.reduce((acc, curr) => ({ ...acc, ...curr }), {});
        const config = {
            headers: { ...authHeaders, ...mergedHeaders },
        };
        // Add upload progress callback if provided
        if (onUploadProgress) {
            config.onUploadProgress = (progressEvent) => {
                if (progressEvent.lengthComputable) {
                    const progress = (progressEvent.loaded / progressEvent.total) * 100;
                    onUploadProgress(progress);
                }
            };
        }
        return this.request(this.axios.put(url, body, config), isJsonRpc);
    }
    async delete(url, headers, isJsonRpc = false) {
        const authHeaders = this.getAuthHeaders();
        const mergedHeaders = headers?.reduce((acc, curr) => ({ ...acc, ...curr }), {});
        return this.request(this.axios.delete(url, {
            headers: { ...authHeaders, ...mergedHeaders },
        }), isJsonRpc);
    }
    async patch(url, body, headers, isJsonRpc = false) {
        const authHeaders = this.getAuthHeaders();
        const mergedHeaders = headers?.reduce((acc, curr) => ({ ...acc, ...curr }), {});
        return this.request(this.axios.patch(url, body, {
            headers: { ...authHeaders, ...mergedHeaders },
        }), isJsonRpc);
    }
    async head(url, headers) {
        const authHeaders = this.getAuthHeaders();
        const mergedHeaders = headers?.reduce((acc, curr) => ({ ...acc, ...curr }), {});
        return this.request(this.axios.head(url, {
            headers: { ...authHeaders, ...mergedHeaders },
        }));
    }
    // Expose refresh mechanism for RPC error handling
    async refreshTokens() {
        const refreshToken = getRefreshToken();
        const accessToken = getAccessToken();
        if (!refreshToken || !accessToken) {
            return { error: { code: 401, message: 'Missing tokens for refresh' } };
        }
        const response = await authClient.refreshToken({
            access_token: accessToken,
            refresh_token: refreshToken,
        });
        if (response.data) {
            setAccessToken(response.data.access_token);
            setRefreshToken(response.data.refresh_token);
        }
        return response;
    }
}
const GENERIC_ERROR = {
    code: 500,
    message: 'Something went wrong',
};
