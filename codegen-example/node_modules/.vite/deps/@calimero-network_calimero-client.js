import {
  __commonJS,
  __toESM,
  require_react
} from "./chunk-JTR2U2B6.js";

// node_modules/.pnpm/styled-components@6.1.19_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/shallowequal/index.js
var require_shallowequal = __commonJS({
  "node_modules/.pnpm/styled-components@6.1.19_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/shallowequal/index.js"(exports, module) {
    module.exports = function shallowEqual(objA, objB, compare, compareContext) {
      var ret = compare ? compare.call(compareContext, objA, objB) : void 0;
      if (ret !== void 0) {
        return !!ret;
      }
      if (objA === objB) {
        return true;
      }
      if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
        return false;
      }
      var keysA = Object.keys(objA);
      var keysB = Object.keys(objB);
      if (keysA.length !== keysB.length) {
        return false;
      }
      var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
      for (var idx = 0; idx < keysA.length; idx++) {
        var key = keysA[idx];
        if (!bHasOwnProperty(key)) {
          return false;
        }
        var valueA = objA[key];
        var valueB = objB[key];
        ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;
        if (ret === false || ret === void 0 && valueA !== valueB) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/.pnpm/@calimero-network+calimero-client@1.14.2_@near-wallet-selector+modal-ui@8.10.2_near-api_fb07a12bb53ff23f73cd2d9908f8f00e/node_modules/@calimero-network/calimero-client/lib/index.mjs
var import_react2 = __toESM(require_react(), 1);
var import_react3 = __toESM(require_react(), 1);
var import_react4 = __toESM(require_react(), 1);

// node_modules/.pnpm/styled-components@6.1.19_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/tslib/tslib.es6.mjs
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t[p2] = s2[p2];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __spreadArray(to, from2, pack) {
  if (pack || arguments.length === 2) for (var i2 = 0, l2 = from2.length, ar; i2 < l2; i2++) {
    if (ar || !(i2 in from2)) {
      if (!ar) ar = Array.prototype.slice.call(from2, 0, i2);
      ar[i2] = from2[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from2));
}

// node_modules/.pnpm/node_modules/@emotion/memoize/dist/emotion-memoize.esm.js
function memoize(fn) {
  var cache = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    if (cache[arg] === void 0) cache[arg] = fn(arg);
    return cache[arg];
  };
}

// node_modules/.pnpm/styled-components@6.1.19_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var isPropValid = memoize(
  function(prop) {
    return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
  }
  /* Z+1 */
);

// node_modules/.pnpm/styled-components@6.1.19_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/styled-components/dist/styled-components.browser.esm.js
var import_react = __toESM(require_react());
var import_shallowequal = __toESM(require_shallowequal());

// node_modules/.pnpm/styled-components@6.1.19_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/stylis/src/Enum.js
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";

// node_modules/.pnpm/styled-components@6.1.19_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/stylis/src/Utility.js
var abs = Math.abs;
var from = String.fromCharCode;
var assign = Object.assign;
function hash(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
function trim(value) {
  return value.trim();
}
function match(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search, position2) {
  return value.indexOf(search, position2);
}
function charat(value, index) {
  return value.charCodeAt(index) | 0;
}
function substr(value, begin, end) {
  return value.slice(begin, end);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append(value, array) {
  return array.push(value), value;
}
function combine(array, callback) {
  return array.map(callback).join("");
}
function filter(array, pattern) {
  return array.filter(function(value) {
    return !match(value, pattern);
  });
}

// node_modules/.pnpm/styled-components@6.1.19_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/stylis/src/Tokenizer.js
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node(value, root, parent, type, props, children, length2, siblings) {
  return { value, root, parent, type, props, children, line, column, length: length2, return: "", siblings };
}
function copy(root, props) {
  return assign(node("", null, null, "", null, null, 0, root.siblings), root, { length: -root.length }, props);
}
function lift(root) {
  while (root.root)
    root = copy(root.root, { children: [root] });
  append(root, root.siblings);
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(begin, end) {
  return substr(characters, begin, end);
}
function token(type) {
  switch (type) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type) {
  return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
}
function whitespace(type) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index, count) {
  while (--count && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32));
}
function delimiter(type) {
  while (next())
    switch (character) {
      case type:
        return position;
      case 34:
      case 39:
        if (type !== 34 && type !== 39)
          delimiter(character);
        break;
      case 40:
        if (type === 41)
          delimiter(type);
        break;
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type, index) {
  while (next())
    if (type + character === 47 + 10)
      break;
    else if (type + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index, position - 1) + "*" + from(type === 47 ? type : next());
}
function identifier(index) {
  while (!token(peek()))
    next();
  return slice(index, position);
}

// node_modules/.pnpm/styled-components@6.1.19_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/stylis/src/Parser.js
function compile(value) {
  return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index = 0;
  var offset = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type = "";
  var props = rules;
  var children = rulesets;
  var reference = rule;
  var characters2 = type;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f", abs(index ? points[index - 1] : 0)) != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root, parent, declarations), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset:
            if (ampersand == -1) characters2 = replace(characters2, /\f/g, "");
            if (property > 0 && strlen(characters2) - length2)
              append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1, declarations) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2, declarations), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append(reference = ruleset(characters2, root, parent, index, offset, rules, points, type, props = [], children = [], length2, rulesets), rulesets);
            if (character2 === 123)
              if (offset === 0)
                parse(characters2, root, reference, reference, props, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length2, children), children), rules, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse(characters2, reference, reference, reference, [""], children, 0, points, children);
                }
        }
        index = offset = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          case 38:
            ampersand = offset > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset = length2 = strlen(type = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root, parent, index, offset, rules, points, type, props, children, length2, siblings) {
  var post = offset - 1;
  var rule = offset === 0 ? rules : [""];
  var size = sizeof(rule);
  for (var i2 = 0, j2 = 0, k2 = 0; i2 < index; ++i2)
    for (var x2 = 0, y2 = substr(value, post + 1, post = abs(j2 = points[i2])), z2 = value; x2 < size; ++x2)
      if (z2 = trim(j2 > 0 ? rule[x2] + " " + y2 : replace(y2, /&\f/g, rule[x2])))
        props[k2++] = z2;
  return node(value, root, parent, offset === 0 ? RULESET : type, props, children, length2, siblings);
}
function comment(value, root, parent, siblings) {
  return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0, siblings);
}
function declaration(value, root, parent, length2, siblings) {
  return node(value, root, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2, siblings);
}

// node_modules/.pnpm/styled-components@6.1.19_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/stylis/src/Prefixer.js
function prefix(value, length2, children) {
  switch (hash(value, length2)) {
    case 5103:
      return WEBKIT + "print-" + value + value;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    case 4789:
      return MOZ + value + value;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    case 5936:
      switch (charat(value, length2 + 11)) {
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
    case 6828:
    case 4268:
    case 2903:
      return WEBKIT + value + MS + value + value;
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/g, "") + (!match(value, /flex-|baseline/) ? MS + "grid-row-" + replace(value, /flex-|-self/g, "") : "") + value;
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/g, "") + value;
    case 5548:
      return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
    case 5292:
      return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
    case 6060:
      return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    case 4200:
      if (!match(value, /flex-|baseline/)) return MS + "grid-column-align" + substr(value, length2) + value;
      break;
    case 2592:
    case 3360:
      return MS + replace(value, "template-", "") + value;
    case 4384:
    case 3616:
      if (children && children.some(function(element, index) {
        return length2 = index, match(element.props, /grid-\w+-end/);
      })) {
        return ~indexof(value + (children = children[length2].value), "span", 0) ? value : MS + replace(value, "-start", "") + value + MS + "grid-row-span:" + (~indexof(children, "span", 0) ? match(children, /\d+/) : +match(children, /\d+/) - +match(value, /\d+/)) + ";";
      }
      return MS + replace(value, "-start", "") + value;
    case 4896:
    case 4128:
      return children && children.some(function(element) {
        return match(element.props, /grid-\w+-start/);
      }) ? value : MS + replace(replace(value, "-end", "-span"), "span ", "") + value;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6)
        switch (charat(value, length2 + 1)) {
          case 109:
            if (charat(value, length2 + 4) !== 45)
              break;
          case 102:
            return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
          case 115:
            return ~indexof(value, "stretch", 0) ? prefix(replace(value, "stretch", "fill-available"), length2, children) + value : value;
        }
      break;
    case 5152:
    case 5920:
      return replace(value, /(.+?):(\d+)(\s*\/\s*(span)?\s*(\d+))?(.*)/, function(_2, a2, b2, c2, d, e, f2) {
        return MS + a2 + ":" + b2 + f2 + (c2 ? MS + a2 + "-span:" + (d ? e : +e - +b2) + f2 : "") + value;
      });
    case 4949:
      if (charat(value, length2 + 6) === 121)
        return replace(value, ":", ":" + WEBKIT) + value;
      break;
    case 6444:
      switch (charat(value, charat(value, 14) === 45 ? 18 : 11)) {
        case 120:
          return replace(value, /(.+:)([^;\s!]+)(;|(\s+)?!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
        case 100:
          return replace(value, ":", ":" + MS) + value;
      }
      break;
    case 5719:
    case 2647:
    case 2135:
    case 3927:
    case 2391:
      return replace(value, "scroll-", "scroll-snap-") + value;
  }
  return value;
}

// node_modules/.pnpm/styled-components@6.1.19_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/stylis/src/Serializer.js
function serialize(children, callback) {
  var output = "";
  for (var i2 = 0; i2 < children.length; i2++)
    output += callback(children[i2], i2, children, callback) || "";
  return output;
}
function stringify(element, index, children, callback) {
  switch (element.type) {
    case LAYER:
      if (element.children.length) break;
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback) + "}";
    case RULESET:
      if (!strlen(element.value = element.props.join(","))) return "";
  }
  return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}

// node_modules/.pnpm/styled-components@6.1.19_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/stylis/src/Middleware.js
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element, index, children, callback) {
    var output = "";
    for (var i2 = 0; i2 < length2; i2++)
      output += collection[i2](element, index, children, callback) || "";
    return output;
  };
}
function rulesheet(callback) {
  return function(element) {
    if (!element.root) {
      if (element = element.return)
        callback(element);
    }
  };
}
function prefixer(element, index, children, callback) {
  if (element.length > -1) {
    if (!element.return)
      switch (element.type) {
        case DECLARATION:
          element.return = prefix(element.value, element.length, children);
          return;
        case KEYFRAMES:
          return serialize([copy(element, { value: replace(element.value, "@", "@" + WEBKIT) })], callback);
        case RULESET:
          if (element.length)
            return combine(children = element.props, function(value) {
              switch (match(value, callback = /(::plac\w+|:read-\w+)/)) {
                case ":read-only":
                case ":read-write":
                  lift(copy(element, { props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")] }));
                  lift(copy(element, { props: [value] }));
                  assign(element, { props: filter(children, callback) });
                  break;
                case "::placeholder":
                  lift(copy(element, { props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")] }));
                  lift(copy(element, { props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")] }));
                  lift(copy(element, { props: [replace(value, /:(plac\w+)/, MS + "input-$1")] }));
                  lift(copy(element, { props: [value] }));
                  assign(element, { props: filter(children, callback) });
                  break;
              }
              return "";
            });
      }
  }
}

// node_modules/.pnpm/styled-components@6.1.19_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@emotion/unitless/dist/emotion-unitless.esm.js
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};

// node_modules/.pnpm/styled-components@6.1.19_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/styled-components/dist/styled-components.browser.esm.js
var f = "undefined" != typeof process && void 0 !== process.env && (process.env.REACT_APP_SC_ATTR || process.env.SC_ATTR) || "data-styled";
var m = "active";
var y = "data-styled-version";
var v = "6.1.19";
var g = "/*!sc*/\n";
var S = "undefined" != typeof window && "undefined" != typeof document;
var w = Boolean("boolean" == typeof SC_DISABLE_SPEEDY ? SC_DISABLE_SPEEDY : "undefined" != typeof process && void 0 !== process.env && void 0 !== process.env.REACT_APP_SC_DISABLE_SPEEDY && "" !== process.env.REACT_APP_SC_DISABLE_SPEEDY ? "false" !== process.env.REACT_APP_SC_DISABLE_SPEEDY && process.env.REACT_APP_SC_DISABLE_SPEEDY : "undefined" != typeof process && void 0 !== process.env && void 0 !== process.env.SC_DISABLE_SPEEDY && "" !== process.env.SC_DISABLE_SPEEDY ? "false" !== process.env.SC_DISABLE_SPEEDY && process.env.SC_DISABLE_SPEEDY : true);
var b = {};
var E = /invalid hook call/i;
var N = /* @__PURE__ */ new Set();
var P = function(t, n) {
  if (true) {
    var o2 = n ? ' with the id of "'.concat(n, '"') : "", s2 = "The component ".concat(t).concat(o2, " has been created dynamically.\n") + "You may see this warning because you've called styled inside another component.\nTo resolve this only create new StyledComponents outside of any render method and function component.\nSee https://styled-components.com/docs/basics#define-styled-components-outside-of-the-render-method for more info.\n", i2 = console.error;
    try {
      var a2 = true;
      console.error = function(t2) {
        for (var n2 = [], o3 = 1; o3 < arguments.length; o3++) n2[o3 - 1] = arguments[o3];
        E.test(t2) ? (a2 = false, N.delete(s2)) : i2.apply(void 0, __spreadArray([t2], n2, false));
      }, (0, import_react.useRef)(), a2 && !N.has(s2) && (console.warn(s2), N.add(s2));
    } catch (e) {
      E.test(e.message) && N.delete(s2);
    } finally {
      console.error = i2;
    }
  }
};
var _ = Object.freeze([]);
var C = Object.freeze({});
function I(e, t, n) {
  return void 0 === n && (n = C), e.theme !== n.theme && e.theme || t || n.theme;
}
var A = /* @__PURE__ */ new Set(["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "u", "ul", "use", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"]);
var O = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g;
var D = /(^-|-$)/g;
function R(e) {
  return e.replace(O, "-").replace(D, "");
}
var T = /(a)(d)/gi;
var k = 52;
var j = function(e) {
  return String.fromCharCode(e + (e > 25 ? 39 : 97));
};
function x(e) {
  var t, n = "";
  for (t = Math.abs(e); t > k; t = t / k | 0) n = j(t % k) + n;
  return (j(t % k) + n).replace(T, "$1-$2");
}
var V;
var F = 5381;
var M = function(e, t) {
  for (var n = t.length; n; ) e = 33 * e ^ t.charCodeAt(--n);
  return e;
};
var z = function(e) {
  return M(F, e);
};
function $(e) {
  return x(z(e) >>> 0);
}
function B(e) {
  return "string" == typeof e && e || e.displayName || e.name || "Component";
}
function L(e) {
  return "string" == typeof e && e.charAt(0) === e.charAt(0).toLowerCase();
}
var G = "function" == typeof Symbol && Symbol.for;
var Y = G ? Symbol.for("react.memo") : 60115;
var W = G ? Symbol.for("react.forward_ref") : 60112;
var q = { childContextTypes: true, contextType: true, contextTypes: true, defaultProps: true, displayName: true, getDefaultProps: true, getDerivedStateFromError: true, getDerivedStateFromProps: true, mixins: true, propTypes: true, type: true };
var H = { name: true, length: true, prototype: true, caller: true, callee: true, arguments: true, arity: true };
var U = { $$typeof: true, compare: true, defaultProps: true, displayName: true, propTypes: true, type: true };
var J = ((V = {})[W] = { $$typeof: true, render: true, defaultProps: true, displayName: true, propTypes: true }, V[Y] = U, V);
function X(e) {
  return ("type" in (t = e) && t.type.$$typeof) === Y ? U : "$$typeof" in e ? J[e.$$typeof] : q;
  var t;
}
var Z = Object.defineProperty;
var K = Object.getOwnPropertyNames;
var Q = Object.getOwnPropertySymbols;
var ee = Object.getOwnPropertyDescriptor;
var te = Object.getPrototypeOf;
var ne = Object.prototype;
function oe(e, t, n) {
  if ("string" != typeof t) {
    if (ne) {
      var o2 = te(t);
      o2 && o2 !== ne && oe(e, o2, n);
    }
    var r2 = K(t);
    Q && (r2 = r2.concat(Q(t)));
    for (var s2 = X(e), i2 = X(t), a2 = 0; a2 < r2.length; ++a2) {
      var c2 = r2[a2];
      if (!(c2 in H || n && n[c2] || i2 && c2 in i2 || s2 && c2 in s2)) {
        var l2 = ee(t, c2);
        try {
          Z(e, c2, l2);
        } catch (e2) {
        }
      }
    }
  }
  return e;
}
function re(e) {
  return "function" == typeof e;
}
function se(e) {
  return "object" == typeof e && "styledComponentId" in e;
}
function ie(e, t) {
  return e && t ? "".concat(e, " ").concat(t) : e || t || "";
}
function ae(e, t) {
  if (0 === e.length) return "";
  for (var n = e[0], o2 = 1; o2 < e.length; o2++) n += t ? t + e[o2] : e[o2];
  return n;
}
function ce(e) {
  return null !== e && "object" == typeof e && e.constructor.name === Object.name && !("props" in e && e.$$typeof);
}
function le(e, t, n) {
  if (void 0 === n && (n = false), !n && !ce(e) && !Array.isArray(e)) return t;
  if (Array.isArray(t)) for (var o2 = 0; o2 < t.length; o2++) e[o2] = le(e[o2], t[o2]);
  else if (ce(t)) for (var o2 in t) e[o2] = le(e[o2], t[o2]);
  return e;
}
function ue(e, t) {
  Object.defineProperty(e, "toString", { value: t });
}
var pe = true ? { 1: "Cannot create styled-component for component: %s.\n\n", 2: "Can't collect styles once you've consumed a `ServerStyleSheet`'s styles! `ServerStyleSheet` is a one off instance for each server-side render cycle.\n\n- Are you trying to reuse it across renders?\n- Are you accidentally calling collectStyles twice?\n\n", 3: "Streaming SSR is only supported in a Node.js environment; Please do not try to call this method in the browser.\n\n", 4: "The `StyleSheetManager` expects a valid target or sheet prop!\n\n- Does this error occur on the client and is your target falsy?\n- Does this error occur on the server and is the sheet falsy?\n\n", 5: "The clone method cannot be used on the client!\n\n- Are you running in a client-like environment on the server?\n- Are you trying to run SSR on the client?\n\n", 6: "Trying to insert a new style tag, but the given Node is unmounted!\n\n- Are you using a custom target that isn't mounted?\n- Does your document not have a valid head element?\n- Have you accidentally removed a style tag manually?\n\n", 7: 'ThemeProvider: Please return an object from your "theme" prop function, e.g.\n\n```js\ntheme={() => ({})}\n```\n\n', 8: 'ThemeProvider: Please make your "theme" prop an object.\n\n', 9: "Missing document `<head>`\n\n", 10: "Cannot find a StyleSheet instance. Usually this happens if there are multiple copies of styled-components loaded at once. Check out this issue for how to troubleshoot and fix the common cases where this situation can happen: https://github.com/styled-components/styled-components/issues/1941#issuecomment-417862021\n\n", 11: "_This error was replaced with a dev-time warning, it will be deleted for v4 final._ [createGlobalStyle] received children which will not be rendered. Please use the component without passing children elements.\n\n", 12: "It seems you are interpolating a keyframe declaration (%s) into an untagged string. This was supported in styled-components v3, but is not longer supported in v4 as keyframes are now injected on-demand. Please wrap your string in the css\\`\\` helper which ensures the styles are injected correctly. See https://www.styled-components.com/docs/api#css\n\n", 13: "%s is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.\n\n", 14: 'ThemeProvider: "theme" prop is required.\n\n', 15: "A stylis plugin has been supplied that is not named. We need a name for each plugin to be able to prevent styling collisions between different stylis configurations within the same app. Before you pass your plugin to `<StyleSheetManager stylisPlugins={[]}>`, please make sure each plugin is uniquely-named, e.g.\n\n```js\nObject.defineProperty(importedPlugin, 'name', { value: 'some-unique-name' });\n```\n\n", 16: "Reached the limit of how many styled components may be created at group %s.\nYou may only create up to 1,073,741,824 components. If you're creating components dynamically,\nas for instance in your render method then you may be running into this limitation.\n\n", 17: "CSSStyleSheet could not be found on HTMLStyleElement.\nHas styled-components' style tag been unmounted or altered by another script?\n", 18: "ThemeProvider: Please make sure your useTheme hook is within a `<ThemeProvider>`" } : {};
function de() {
  for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
  for (var n = e[0], o2 = [], r2 = 1, s2 = e.length; r2 < s2; r2 += 1) o2.push(e[r2]);
  return o2.forEach(function(e2) {
    n = n.replace(/%[a-z]/, e2);
  }), n;
}
function he(t) {
  for (var n = [], o2 = 1; o2 < arguments.length; o2++) n[o2 - 1] = arguments[o2];
  return false ? new Error("An error occurred. See https://github.com/styled-components/styled-components/blob/main/packages/styled-components/src/utils/errors.md#".concat(t, " for more information.").concat(n.length > 0 ? " Args: ".concat(n.join(", ")) : "")) : new Error(de.apply(void 0, __spreadArray([pe[t]], n, false)).trim());
}
var fe = function() {
  function e(e2) {
    this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = e2;
  }
  return e.prototype.indexOfGroup = function(e2) {
    for (var t = 0, n = 0; n < e2; n++) t += this.groupSizes[n];
    return t;
  }, e.prototype.insertRules = function(e2, t) {
    if (e2 >= this.groupSizes.length) {
      for (var n = this.groupSizes, o2 = n.length, r2 = o2; e2 >= r2; ) if ((r2 <<= 1) < 0) throw he(16, "".concat(e2));
      this.groupSizes = new Uint32Array(r2), this.groupSizes.set(n), this.length = r2;
      for (var s2 = o2; s2 < r2; s2++) this.groupSizes[s2] = 0;
    }
    for (var i2 = this.indexOfGroup(e2 + 1), a2 = (s2 = 0, t.length); s2 < a2; s2++) this.tag.insertRule(i2, t[s2]) && (this.groupSizes[e2]++, i2++);
  }, e.prototype.clearGroup = function(e2) {
    if (e2 < this.length) {
      var t = this.groupSizes[e2], n = this.indexOfGroup(e2), o2 = n + t;
      this.groupSizes[e2] = 0;
      for (var r2 = n; r2 < o2; r2++) this.tag.deleteRule(n);
    }
  }, e.prototype.getGroup = function(e2) {
    var t = "";
    if (e2 >= this.length || 0 === this.groupSizes[e2]) return t;
    for (var n = this.groupSizes[e2], o2 = this.indexOfGroup(e2), r2 = o2 + n, s2 = o2; s2 < r2; s2++) t += "".concat(this.tag.getRule(s2)).concat(g);
    return t;
  }, e;
}();
var me = 1 << 30;
var ye = /* @__PURE__ */ new Map();
var ve = /* @__PURE__ */ new Map();
var ge = 1;
var Se = function(e) {
  if (ye.has(e)) return ye.get(e);
  for (; ve.has(ge); ) ge++;
  var t = ge++;
  if ((0 | t) < 0 || t > me) throw he(16, "".concat(t));
  return ye.set(e, t), ve.set(t, e), t;
};
var we = function(e, t) {
  ge = t + 1, ye.set(e, t), ve.set(t, e);
};
var be = "style[".concat(f, "][").concat(y, '="').concat(v, '"]');
var Ee = new RegExp("^".concat(f, '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)'));
var Ne = function(e, t, n) {
  for (var o2, r2 = n.split(","), s2 = 0, i2 = r2.length; s2 < i2; s2++) (o2 = r2[s2]) && e.registerName(t, o2);
};
var Pe = function(e, t) {
  for (var n, o2 = (null !== (n = t.textContent) && void 0 !== n ? n : "").split(g), r2 = [], s2 = 0, i2 = o2.length; s2 < i2; s2++) {
    var a2 = o2[s2].trim();
    if (a2) {
      var c2 = a2.match(Ee);
      if (c2) {
        var l2 = 0 | parseInt(c2[1], 10), u2 = c2[2];
        0 !== l2 && (we(u2, l2), Ne(e, u2, c2[3]), e.getTag().insertRules(l2, r2)), r2.length = 0;
      } else r2.push(a2);
    }
  }
};
var _e = function(e) {
  for (var t = document.querySelectorAll(be), n = 0, o2 = t.length; n < o2; n++) {
    var r2 = t[n];
    r2 && r2.getAttribute(f) !== m && (Pe(e, r2), r2.parentNode && r2.parentNode.removeChild(r2));
  }
};
function Ce() {
  return "undefined" != typeof __webpack_nonce__ ? __webpack_nonce__ : null;
}
var Ie = function(e) {
  var t = document.head, n = e || t, o2 = document.createElement("style"), r2 = function(e2) {
    var t2 = Array.from(e2.querySelectorAll("style[".concat(f, "]")));
    return t2[t2.length - 1];
  }(n), s2 = void 0 !== r2 ? r2.nextSibling : null;
  o2.setAttribute(f, m), o2.setAttribute(y, v);
  var i2 = Ce();
  return i2 && o2.setAttribute("nonce", i2), n.insertBefore(o2, s2), o2;
};
var Ae = function() {
  function e(e2) {
    this.element = Ie(e2), this.element.appendChild(document.createTextNode("")), this.sheet = function(e3) {
      if (e3.sheet) return e3.sheet;
      for (var t = document.styleSheets, n = 0, o2 = t.length; n < o2; n++) {
        var r2 = t[n];
        if (r2.ownerNode === e3) return r2;
      }
      throw he(17);
    }(this.element), this.length = 0;
  }
  return e.prototype.insertRule = function(e2, t) {
    try {
      return this.sheet.insertRule(t, e2), this.length++, true;
    } catch (e3) {
      return false;
    }
  }, e.prototype.deleteRule = function(e2) {
    this.sheet.deleteRule(e2), this.length--;
  }, e.prototype.getRule = function(e2) {
    var t = this.sheet.cssRules[e2];
    return t && t.cssText ? t.cssText : "";
  }, e;
}();
var Oe = function() {
  function e(e2) {
    this.element = Ie(e2), this.nodes = this.element.childNodes, this.length = 0;
  }
  return e.prototype.insertRule = function(e2, t) {
    if (e2 <= this.length && e2 >= 0) {
      var n = document.createTextNode(t);
      return this.element.insertBefore(n, this.nodes[e2] || null), this.length++, true;
    }
    return false;
  }, e.prototype.deleteRule = function(e2) {
    this.element.removeChild(this.nodes[e2]), this.length--;
  }, e.prototype.getRule = function(e2) {
    return e2 < this.length ? this.nodes[e2].textContent : "";
  }, e;
}();
var De = function() {
  function e(e2) {
    this.rules = [], this.length = 0;
  }
  return e.prototype.insertRule = function(e2, t) {
    return e2 <= this.length && (this.rules.splice(e2, 0, t), this.length++, true);
  }, e.prototype.deleteRule = function(e2) {
    this.rules.splice(e2, 1), this.length--;
  }, e.prototype.getRule = function(e2) {
    return e2 < this.length ? this.rules[e2] : "";
  }, e;
}();
var Re = S;
var Te = { isServer: !S, useCSSOMInjection: !w };
var ke = function() {
  function e(e2, n, o2) {
    void 0 === e2 && (e2 = C), void 0 === n && (n = {});
    var r2 = this;
    this.options = __assign(__assign({}, Te), e2), this.gs = n, this.names = new Map(o2), this.server = !!e2.isServer, !this.server && S && Re && (Re = false, _e(this)), ue(this, function() {
      return function(e3) {
        for (var t = e3.getTag(), n2 = t.length, o3 = "", r3 = function(n3) {
          var r4 = function(e4) {
            return ve.get(e4);
          }(n3);
          if (void 0 === r4) return "continue";
          var s3 = e3.names.get(r4), i2 = t.getGroup(n3);
          if (void 0 === s3 || !s3.size || 0 === i2.length) return "continue";
          var a2 = "".concat(f, ".g").concat(n3, '[id="').concat(r4, '"]'), c2 = "";
          void 0 !== s3 && s3.forEach(function(e4) {
            e4.length > 0 && (c2 += "".concat(e4, ","));
          }), o3 += "".concat(i2).concat(a2, '{content:"').concat(c2, '"}').concat(g);
        }, s2 = 0; s2 < n2; s2++) r3(s2);
        return o3;
      }(r2);
    });
  }
  return e.registerId = function(e2) {
    return Se(e2);
  }, e.prototype.rehydrate = function() {
    !this.server && S && _e(this);
  }, e.prototype.reconstructWithOptions = function(n, o2) {
    return void 0 === o2 && (o2 = true), new e(__assign(__assign({}, this.options), n), this.gs, o2 && this.names || void 0);
  }, e.prototype.allocateGSInstance = function(e2) {
    return this.gs[e2] = (this.gs[e2] || 0) + 1;
  }, e.prototype.getTag = function() {
    return this.tag || (this.tag = (e2 = function(e3) {
      var t = e3.useCSSOMInjection, n = e3.target;
      return e3.isServer ? new De(n) : t ? new Ae(n) : new Oe(n);
    }(this.options), new fe(e2)));
    var e2;
  }, e.prototype.hasNameForId = function(e2, t) {
    return this.names.has(e2) && this.names.get(e2).has(t);
  }, e.prototype.registerName = function(e2, t) {
    if (Se(e2), this.names.has(e2)) this.names.get(e2).add(t);
    else {
      var n = /* @__PURE__ */ new Set();
      n.add(t), this.names.set(e2, n);
    }
  }, e.prototype.insertRules = function(e2, t, n) {
    this.registerName(e2, t), this.getTag().insertRules(Se(e2), n);
  }, e.prototype.clearNames = function(e2) {
    this.names.has(e2) && this.names.get(e2).clear();
  }, e.prototype.clearRules = function(e2) {
    this.getTag().clearGroup(Se(e2)), this.clearNames(e2);
  }, e.prototype.clearTag = function() {
    this.tag = void 0;
  }, e;
}();
var je = /&/g;
var xe = /^\s*\/\/.*$/gm;
function Ve(e, t) {
  return e.map(function(e2) {
    return "rule" === e2.type && (e2.value = "".concat(t, " ").concat(e2.value), e2.value = e2.value.replaceAll(",", ",".concat(t, " ")), e2.props = e2.props.map(function(e3) {
      return "".concat(t, " ").concat(e3);
    })), Array.isArray(e2.children) && "@keyframes" !== e2.type && (e2.children = Ve(e2.children, t)), e2;
  });
}
function Fe(e) {
  var t, n, o2, r2 = void 0 === e ? C : e, s2 = r2.options, i2 = void 0 === s2 ? C : s2, a2 = r2.plugins, c2 = void 0 === a2 ? _ : a2, l2 = function(e2, o3, r3) {
    return r3.startsWith(n) && r3.endsWith(n) && r3.replaceAll(n, "").length > 0 ? ".".concat(t) : e2;
  }, u2 = c2.slice();
  u2.push(function(e2) {
    e2.type === RULESET && e2.value.includes("&") && (e2.props[0] = e2.props[0].replace(je, n).replace(o2, l2));
  }), i2.prefix && u2.push(prefixer), u2.push(stringify);
  var p2 = function(e2, r3, s3, a3) {
    void 0 === r3 && (r3 = ""), void 0 === s3 && (s3 = ""), void 0 === a3 && (a3 = "&"), t = a3, n = r3, o2 = new RegExp("\\".concat(n, "\\b"), "g");
    var c3 = e2.replace(xe, ""), l3 = compile(s3 || r3 ? "".concat(s3, " ").concat(r3, " { ").concat(c3, " }") : c3);
    i2.namespace && (l3 = Ve(l3, i2.namespace));
    var p3 = [];
    return serialize(l3, middleware(u2.concat(rulesheet(function(e3) {
      return p3.push(e3);
    })))), p3;
  };
  return p2.hash = c2.length ? c2.reduce(function(e2, t2) {
    return t2.name || he(15), M(e2, t2.name);
  }, F).toString() : "", p2;
}
var Me = new ke();
var ze = Fe();
var $e = import_react.default.createContext({ shouldForwardProp: void 0, styleSheet: Me, stylis: ze });
var Be = $e.Consumer;
var Le = import_react.default.createContext(void 0);
function Ge() {
  return (0, import_react.useContext)($e);
}
function Ye(e) {
  var t = (0, import_react.useState)(e.stylisPlugins), n = t[0], r2 = t[1], c2 = Ge().styleSheet, l2 = (0, import_react.useMemo)(function() {
    var t2 = c2;
    return e.sheet ? t2 = e.sheet : e.target && (t2 = t2.reconstructWithOptions({ target: e.target }, false)), e.disableCSSOMInjection && (t2 = t2.reconstructWithOptions({ useCSSOMInjection: false })), t2;
  }, [e.disableCSSOMInjection, e.sheet, e.target, c2]), u2 = (0, import_react.useMemo)(function() {
    return Fe({ options: { namespace: e.namespace, prefix: e.enableVendorPrefixes }, plugins: n });
  }, [e.enableVendorPrefixes, e.namespace, n]);
  (0, import_react.useEffect)(function() {
    (0, import_shallowequal.default)(n, e.stylisPlugins) || r2(e.stylisPlugins);
  }, [e.stylisPlugins]);
  var d = (0, import_react.useMemo)(function() {
    return { shouldForwardProp: e.shouldForwardProp, styleSheet: l2, stylis: u2 };
  }, [e.shouldForwardProp, l2, u2]);
  return import_react.default.createElement($e.Provider, { value: d }, import_react.default.createElement(Le.Provider, { value: u2 }, e.children));
}
var We = function() {
  function e(e2, t) {
    var n = this;
    this.inject = function(e3, t2) {
      void 0 === t2 && (t2 = ze);
      var o2 = n.name + t2.hash;
      e3.hasNameForId(n.id, o2) || e3.insertRules(n.id, o2, t2(n.rules, o2, "@keyframes"));
    }, this.name = e2, this.id = "sc-keyframes-".concat(e2), this.rules = t, ue(this, function() {
      throw he(12, String(n.name));
    });
  }
  return e.prototype.getName = function(e2) {
    return void 0 === e2 && (e2 = ze), this.name + e2.hash;
  }, e;
}();
var qe = function(e) {
  return e >= "A" && e <= "Z";
};
function He(e) {
  for (var t = "", n = 0; n < e.length; n++) {
    var o2 = e[n];
    if (1 === n && "-" === o2 && "-" === e[0]) return e;
    qe(o2) ? t += "-" + o2.toLowerCase() : t += o2;
  }
  return t.startsWith("ms-") ? "-" + t : t;
}
var Ue = function(e) {
  return null == e || false === e || "" === e;
};
var Je = function(t) {
  var n, o2, r2 = [];
  for (var s2 in t) {
    var i2 = t[s2];
    t.hasOwnProperty(s2) && !Ue(i2) && (Array.isArray(i2) && i2.isCss || re(i2) ? r2.push("".concat(He(s2), ":"), i2, ";") : ce(i2) ? r2.push.apply(r2, __spreadArray(__spreadArray(["".concat(s2, " {")], Je(i2), false), ["}"], false)) : r2.push("".concat(He(s2), ": ").concat((n = s2, null == (o2 = i2) || "boolean" == typeof o2 || "" === o2 ? "" : "number" != typeof o2 || 0 === o2 || n in unitlessKeys || n.startsWith("--") ? String(o2).trim() : "".concat(o2, "px")), ";")));
  }
  return r2;
};
function Xe(e, t, n, o2) {
  if (Ue(e)) return [];
  if (se(e)) return [".".concat(e.styledComponentId)];
  if (re(e)) {
    if (!re(s2 = e) || s2.prototype && s2.prototype.isReactComponent || !t) return [e];
    var r2 = e(t);
    return "object" != typeof r2 || Array.isArray(r2) || r2 instanceof We || ce(r2) || null === r2 || console.error("".concat(B(e), " is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.")), Xe(r2, t, n, o2);
  }
  var s2;
  return e instanceof We ? n ? (e.inject(n, o2), [e.getName(o2)]) : [e] : ce(e) ? Je(e) : Array.isArray(e) ? Array.prototype.concat.apply(_, e.map(function(e2) {
    return Xe(e2, t, n, o2);
  })) : [e.toString()];
}
function Ze(e) {
  for (var t = 0; t < e.length; t += 1) {
    var n = e[t];
    if (re(n) && !se(n)) return false;
  }
  return true;
}
var Ke = z(v);
var Qe = function() {
  function e(e2, t, n) {
    this.rules = e2, this.staticRulesId = "", this.isStatic = false, this.componentId = t, this.baseHash = M(Ke, t), this.baseStyle = n, ke.registerId(t);
  }
  return e.prototype.generateAndInjectStyles = function(e2, t, n) {
    var o2 = this.baseStyle ? this.baseStyle.generateAndInjectStyles(e2, t, n) : "";
    if (this.isStatic && !n.hash) if (this.staticRulesId && t.hasNameForId(this.componentId, this.staticRulesId)) o2 = ie(o2, this.staticRulesId);
    else {
      var r2 = ae(Xe(this.rules, e2, t, n)), s2 = x(M(this.baseHash, r2) >>> 0);
      if (!t.hasNameForId(this.componentId, s2)) {
        var i2 = n(r2, ".".concat(s2), void 0, this.componentId);
        t.insertRules(this.componentId, s2, i2);
      }
      o2 = ie(o2, s2), this.staticRulesId = s2;
    }
    else {
      for (var a2 = M(this.baseHash, n.hash), c2 = "", l2 = 0; l2 < this.rules.length; l2++) {
        var u2 = this.rules[l2];
        if ("string" == typeof u2) c2 += u2, a2 = M(a2, u2);
        else if (u2) {
          var p2 = ae(Xe(u2, e2, t, n));
          a2 = M(a2, p2 + l2), c2 += p2;
        }
      }
      if (c2) {
        var d = x(a2 >>> 0);
        t.hasNameForId(this.componentId, d) || t.insertRules(this.componentId, d, n(c2, ".".concat(d), void 0, this.componentId)), o2 = ie(o2, d);
      }
    }
    return o2;
  }, e;
}();
var et = import_react.default.createContext(void 0);
var tt = et.Consumer;
var rt = {};
var st = /* @__PURE__ */ new Set();
function it(e, r2, s2) {
  var i2 = se(e), a2 = e, c2 = !L(e), p2 = r2.attrs, d = void 0 === p2 ? _ : p2, h = r2.componentId, f2 = void 0 === h ? function(e2, t) {
    var n = "string" != typeof e2 ? "sc" : R(e2);
    rt[n] = (rt[n] || 0) + 1;
    var o2 = "".concat(n, "-").concat($(v + n + rt[n]));
    return t ? "".concat(t, "-").concat(o2) : o2;
  }(r2.displayName, r2.parentComponentId) : h, m2 = r2.displayName, y2 = void 0 === m2 ? function(e2) {
    return L(e2) ? "styled.".concat(e2) : "Styled(".concat(B(e2), ")");
  }(e) : m2, g2 = r2.displayName && r2.componentId ? "".concat(R(r2.displayName), "-").concat(r2.componentId) : r2.componentId || f2, S2 = i2 && a2.attrs ? a2.attrs.concat(d).filter(Boolean) : d, w2 = r2.shouldForwardProp;
  if (i2 && a2.shouldForwardProp) {
    var b2 = a2.shouldForwardProp;
    if (r2.shouldForwardProp) {
      var E2 = r2.shouldForwardProp;
      w2 = function(e2, t) {
        return b2(e2, t) && E2(e2, t);
      };
    } else w2 = b2;
  }
  var N2 = new Qe(s2, g2, i2 ? a2.componentStyle : void 0);
  function O2(e2, r3) {
    return function(e3, r4, s3) {
      var i3 = e3.attrs, a3 = e3.componentStyle, c3 = e3.defaultProps, p3 = e3.foldedComponentIds, d2 = e3.styledComponentId, h2 = e3.target, f3 = import_react.default.useContext(et), m3 = Ge(), y3 = e3.shouldForwardProp || m3.shouldForwardProp;
      (0, import_react.useDebugValue)(d2);
      var v2 = I(r4, f3, c3) || C, g3 = function(e4, n, o2) {
        for (var r5, s4 = __assign(__assign({}, n), { className: void 0, theme: o2 }), i4 = 0; i4 < e4.length; i4 += 1) {
          var a4 = re(r5 = e4[i4]) ? r5(s4) : r5;
          for (var c4 in a4) s4[c4] = "className" === c4 ? ie(s4[c4], a4[c4]) : "style" === c4 ? __assign(__assign({}, s4[c4]), a4[c4]) : a4[c4];
        }
        return n.className && (s4.className = ie(s4.className, n.className)), s4;
      }(i3, r4, v2), S3 = g3.as || h2, w3 = {};
      for (var b3 in g3) void 0 === g3[b3] || "$" === b3[0] || "as" === b3 || "theme" === b3 && g3.theme === v2 || ("forwardedAs" === b3 ? w3.as = g3.forwardedAs : y3 && !y3(b3, S3) || (w3[b3] = g3[b3], y3 || false || isPropValid(b3) || st.has(b3) || !A.has(S3) || (st.add(b3), console.warn('styled-components: it looks like an unknown prop "'.concat(b3, '" is being sent through to the DOM, which will likely trigger a React console error. If you would like automatic filtering of unknown props, you can opt-into that behavior via `<StyleSheetManager shouldForwardProp={...}>` (connect an API like `@emotion/is-prop-valid`) or consider using transient props (`$` prefix for automatic filtering.)')))));
      var E3 = function(e4, t) {
        var n = Ge(), o2 = e4.generateAndInjectStyles(t, n.styleSheet, n.stylis);
        return (0, import_react.useDebugValue)(o2), o2;
      }(a3, g3);
      e3.warnTooManyClasses && e3.warnTooManyClasses(E3);
      var N3 = ie(p3, d2);
      return E3 && (N3 += " " + E3), g3.className && (N3 += " " + g3.className), w3[L(S3) && !A.has(S3) ? "class" : "className"] = N3, s3 && (w3.ref = s3), (0, import_react.createElement)(S3, w3);
    }(D2, e2, r3);
  }
  O2.displayName = y2;
  var D2 = import_react.default.forwardRef(O2);
  return D2.attrs = S2, D2.componentStyle = N2, D2.displayName = y2, D2.shouldForwardProp = w2, D2.foldedComponentIds = i2 ? ie(a2.foldedComponentIds, a2.styledComponentId) : "", D2.styledComponentId = g2, D2.target = i2 ? a2.target : e, Object.defineProperty(D2, "defaultProps", { get: function() {
    return this._foldedDefaultProps;
  }, set: function(e2) {
    this._foldedDefaultProps = i2 ? function(e3) {
      for (var t = [], n = 1; n < arguments.length; n++) t[n - 1] = arguments[n];
      for (var o2 = 0, r3 = t; o2 < r3.length; o2++) le(e3, r3[o2], true);
      return e3;
    }({}, a2.defaultProps, e2) : e2;
  } }), P(y2, g2), D2.warnTooManyClasses = /* @__PURE__ */ function(e2, t) {
    var n = {}, o2 = false;
    return function(r3) {
      if (!o2 && (n[r3] = true, Object.keys(n).length >= 200)) {
        var s3 = t ? ' with the id of "'.concat(t, '"') : "";
        console.warn("Over ".concat(200, " classes were generated for component ").concat(e2).concat(s3, ".\n") + "Consider using the attrs method, together with a style object for frequently changed styles.\nExample:\n  const Component = styled.div.attrs(props => ({\n    style: {\n      background: props.background,\n    },\n  }))`width: 100%;`\n\n  <Component />"), o2 = true, n = {};
      }
    };
  }(y2, g2), ue(D2, function() {
    return ".".concat(D2.styledComponentId);
  }), c2 && oe(D2, e, { attrs: true, componentStyle: true, displayName: true, foldedComponentIds: true, shouldForwardProp: true, styledComponentId: true, target: true }), D2;
}
function at(e, t) {
  for (var n = [e[0]], o2 = 0, r2 = t.length; o2 < r2; o2 += 1) n.push(t[o2], e[o2 + 1]);
  return n;
}
var ct = function(e) {
  return Object.assign(e, { isCss: true });
};
function lt(t) {
  for (var n = [], o2 = 1; o2 < arguments.length; o2++) n[o2 - 1] = arguments[o2];
  if (re(t) || ce(t)) return ct(Xe(at(_, __spreadArray([t], n, true))));
  var r2 = t;
  return 0 === n.length && 1 === r2.length && "string" == typeof r2[0] ? Xe(r2) : ct(Xe(at(r2, n)));
}
function ut(n, o2, r2) {
  if (void 0 === r2 && (r2 = C), !o2) throw he(1, o2);
  var s2 = function(t) {
    for (var s3 = [], i2 = 1; i2 < arguments.length; i2++) s3[i2 - 1] = arguments[i2];
    return n(o2, r2, lt.apply(void 0, __spreadArray([t], s3, false)));
  };
  return s2.attrs = function(e) {
    return ut(n, o2, __assign(__assign({}, r2), { attrs: Array.prototype.concat(r2.attrs, e).filter(Boolean) }));
  }, s2.withConfig = function(e) {
    return ut(n, o2, __assign(__assign({}, r2), e));
  }, s2;
}
var pt = function(e) {
  return ut(it, e);
};
var dt = pt;
A.forEach(function(e) {
  dt[e] = pt(e);
});
var ht = function() {
  function e(e2, t) {
    this.rules = e2, this.componentId = t, this.isStatic = Ze(e2), ke.registerId(this.componentId + 1);
  }
  return e.prototype.createStyles = function(e2, t, n, o2) {
    var r2 = o2(ae(Xe(this.rules, t, n, o2)), ""), s2 = this.componentId + e2;
    n.insertRules(s2, s2, r2);
  }, e.prototype.removeStyles = function(e2, t) {
    t.clearRules(this.componentId + e2);
  }, e.prototype.renderStyles = function(e2, t, n, o2) {
    e2 > 2 && ke.registerId(this.componentId + e2), this.removeStyles(e2, n), this.createStyles(e2, t, n, o2);
  }, e;
}();
function ft(n) {
  for (var r2 = [], s2 = 1; s2 < arguments.length; s2++) r2[s2 - 1] = arguments[s2];
  var i2 = lt.apply(void 0, __spreadArray([n], r2, false)), a2 = "sc-global-".concat($(JSON.stringify(i2))), c2 = new ht(i2, a2);
  P(a2);
  var l2 = function(e) {
    var t = Ge(), n2 = import_react.default.useContext(et), r3 = import_react.default.useRef(t.styleSheet.allocateGSInstance(a2)).current;
    return import_react.default.Children.count(e.children) && console.warn("The global style component ".concat(a2, " was given child JSX. createGlobalStyle does not render children.")), i2.some(function(e2) {
      return "string" == typeof e2 && -1 !== e2.indexOf("@import");
    }) && console.warn("Please do not use @import CSS syntax in createGlobalStyle at this time, as the CSSOM APIs we use in production do not handle it well. Instead, we recommend using a library such as react-helmet to inject a typical <link> meta tag to the stylesheet, or simply embedding it manually in your index.html <head> section for a simpler app."), t.styleSheet.server && u2(r3, e, t.styleSheet, n2, t.stylis), import_react.default.useLayoutEffect(function() {
      if (!t.styleSheet.server) return u2(r3, e, t.styleSheet, n2, t.stylis), function() {
        return c2.removeStyles(r3, t.styleSheet);
      };
    }, [r3, e, t.styleSheet, n2, t.stylis]), null;
  };
  function u2(e, n2, o2, r3, s3) {
    if (c2.isStatic) c2.renderStyles(e, b, o2, s3);
    else {
      var i3 = __assign(__assign({}, n2), { theme: I(n2, r3, l2.defaultProps) });
      c2.renderStyles(e, i3, o2, s3);
    }
  }
  return import_react.default.memo(l2);
}
function mt(t) {
  for (var n = [], o2 = 1; o2 < arguments.length; o2++) n[o2 - 1] = arguments[o2];
  "undefined" != typeof navigator && "ReactNative" === navigator.product && console.warn("`keyframes` cannot be used on ReactNative, only on the web. To do animation in ReactNative please use Animated.");
  var r2 = ae(lt.apply(void 0, __spreadArray([t], n, false))), s2 = $(r2);
  return new We(s2, r2);
}
var vt = function() {
  function e() {
    var e2 = this;
    this._emitSheetCSS = function() {
      var t = e2.instance.toString();
      if (!t) return "";
      var n = Ce(), o2 = ae([n && 'nonce="'.concat(n, '"'), "".concat(f, '="true"'), "".concat(y, '="').concat(v, '"')].filter(Boolean), " ");
      return "<style ".concat(o2, ">").concat(t, "</style>");
    }, this.getStyleTags = function() {
      if (e2.sealed) throw he(2);
      return e2._emitSheetCSS();
    }, this.getStyleElement = function() {
      var n;
      if (e2.sealed) throw he(2);
      var r2 = e2.instance.toString();
      if (!r2) return [];
      var s2 = ((n = {})[f] = "", n[y] = v, n.dangerouslySetInnerHTML = { __html: r2 }, n), i2 = Ce();
      return i2 && (s2.nonce = i2), [import_react.default.createElement("style", __assign({}, s2, { key: "sc-0-0" }))];
    }, this.seal = function() {
      e2.sealed = true;
    }, this.instance = new ke({ isServer: true }), this.sealed = false;
  }
  return e.prototype.collectStyles = function(e2) {
    if (this.sealed) throw he(2);
    return import_react.default.createElement(Ye, { sheet: this.instance }, e2);
  }, e.prototype.interleaveWithNodeStream = function(e2) {
    throw he(3);
  }, e;
}();
"undefined" != typeof navigator && "ReactNative" === navigator.product && console.warn("It looks like you've imported 'styled-components' on React Native.\nPerhaps you're looking to import 'styled-components/native'?\nRead more about this at https://www.styled-components.com/docs/basics#react-native");
var St = "__sc-".concat(f, "__");
"undefined" != typeof window && (window[St] || (window[St] = 0), 1 === window[St] && console.warn("It looks like there are several instances of 'styled-components' initialized in this application. This may cause dynamic styles to not render properly, errors during the rehydration process, a missing theme prop, and makes your application bigger without good reason.\n\nSee https://s-c.sh/2BAXzed for more info."), window[St] += 1);

// node_modules/.pnpm/@calimero-network+calimero-client@1.14.2_@near-wallet-selector+modal-ui@8.10.2_near-api_fb07a12bb53ff23f73cd2d9908f8f00e/node_modules/@calimero-network/calimero-client/lib/index.mjs
var import_react5 = __toESM(require_react(), 1);
var import_react6 = __toESM(require_react(), 1);
var import_react7 = __toESM(require_react(), 1);
var import_react8 = __toESM(require_react(), 1);
var import_react9 = __toESM(require_react(), 1);
var import_react10 = __toESM(require_react(), 1);
var import_react11 = __toESM(require_react(), 1);
var import_react12 = __toESM(require_react(), 1);
var import_react13 = __toESM(require_react(), 1);
var import_react14 = __toESM(require_react(), 1);
var import_react15 = __toESM(require_react(), 1);
var import_react16 = __toESM(require_react(), 1);
var import_react17 = __toESM(require_react(), 1);
var import_react18 = __toESM(require_react(), 1);
var import_react19 = __toESM(require_react(), 1);
var import_react20 = __toESM(require_react(), 1);
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all3) => {
  for (var name in all3)
    __defProp(target, name, { get: all3[name], enumerable: true });
};
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}
var { toString } = Object.prototype;
var { getPrototypeOf } = Object;
var { iterator, toStringTag } = Symbol;
var kindOf = /* @__PURE__ */ ((cache) => (thing) => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
var kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
var typeOfTest = (type) => (thing) => typeof thing === type;
var { isArray } = Array;
var isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
var isString = typeOfTest("string");
var isFunction = typeOfTest("function");
var isNumber = typeOfTest("number");
var isObject = (thing) => thing !== null && typeof thing === "object";
var isBoolean = (thing) => thing === true || thing === false;
var isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype3 = getPrototypeOf(val);
  return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(toStringTag in val) && !(iterator in val);
};
var isEmptyObject = (val) => {
  if (!isObject(val) || isBuffer(val)) {
    return false;
  }
  try {
    return Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;
  } catch (e) {
    return false;
  }
};
var isDate = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
var isStream = (val) => isObject(val) && isFunction(val.pipe);
var isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
var isURLSearchParams = kindOfTest("URLSearchParams");
var [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
var trim2 = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i2;
  let l2;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i2 = 0, l2 = obj.length; i2 < l2; i2++) {
      fn.call(null, obj[i2], i2, obj);
    }
  } else {
    if (isBuffer(obj)) {
      return;
    }
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i2 = 0; i2 < len; i2++) {
      key = keys[i2];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  if (isBuffer(obj)) {
    return null;
  }
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i2 = keys.length;
  let _key;
  while (i2-- > 0) {
    _key = keys[i2];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
var _global = (() => {
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
var isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
    arguments[i2] && forEach(arguments[i2], assignValue);
  }
  return result;
}
var extend = (a2, b2, thisArg, { allOwnKeys } = {}) => {
  forEach(b2, (val, key) => {
    if (thisArg && isFunction(val)) {
      a2[key] = bind(val, thisArg);
    } else {
      a2[key] = val;
    }
  }, { allOwnKeys });
  return a2;
};
var stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
var inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
var toFlatObject = (sourceObj, destObj, filter22, propFilter) => {
  let props;
  let i2;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null) return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i2 = props.length;
    while (i2-- > 0) {
      prop = props[i2];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter22 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter22 || filter22(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
var endsWith = (str, searchString, position2) => {
  str = String(str);
  if (position2 === void 0 || position2 > str.length) {
    position2 = str.length;
  }
  position2 -= searchString.length;
  const lastIndex = str.indexOf(searchString, position2);
  return lastIndex !== -1 && lastIndex === position2;
};
var toArray = (thing) => {
  if (!thing) return null;
  if (isArray(thing)) return thing;
  let i2 = thing.length;
  if (!isNumber(i2)) return null;
  const arr = new Array(i2);
  while (i2-- > 0) {
    arr[i2] = thing[i2];
  }
  return arr;
};
var isTypedArray = /* @__PURE__ */ ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
var forEachEntry = (obj, fn) => {
  const generator = obj && obj[iterator];
  const _iterator = generator.call(obj);
  let result;
  while ((result = _iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
var matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m2, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
var isRegExp = kindOfTest("RegExp");
var reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
var freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction(value)) return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
var toObjectSet = (arrayOrString, delimiter2) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter2));
  return obj;
};
var noop = () => {
};
var toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[toStringTag] === "FormData" && thing[iterator]);
}
var toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i2) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (isBuffer(source)) {
        return source;
      }
      if (!("toJSON" in source)) {
        stack[i2] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i2 + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i2] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
var isAsyncFn = kindOfTest("AsyncFunction");
var isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
var _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }
  return postMessageSupported ? ((token2, callbacks) => {
    _global.addEventListener("message", ({ source, data }) => {
      if (source === _global && data === token2) {
        callbacks.length && callbacks.shift()();
      }
    }, false);
    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token2, "*");
    };
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === "function",
  isFunction(_global.postMessage)
);
var asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
var isIterable = (thing) => thing != null && isFunction(thing[iterator]);
var utils_default = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isEmptyObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim: trim2,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap,
  isIterable
};
function AxiosError(message, code, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}
utils_default.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils_default.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
var prototype = AxiosError.prototype;
var descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype);
  utils_default.toFlatObject(error, axiosError, function filter22(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code, config, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_default = AxiosError;
var null_default = null;
function isVisitable(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
function removeBrackets(key) {
  return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token2, i2) {
    token2 = removeBrackets(token2);
    return !dots && i2 ? "[" + token2 + "]" : token2;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils_default.isArray(arr) && !arr.some(isVisitable);
}
var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter2(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils_default.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (null_default || FormData)();
  options = utils_default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils_default.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
  if (!utils_default.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null) return "";
    if (utils_default.isDate(value)) {
      return value.toISOString();
    }
    if (utils_default.isBoolean(value)) {
      return value.toString();
    }
    if (!useBlob && utils_default.isBlob(value)) {
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils_default.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index) {
          !(utils_default.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils_default.isUndefined(value)) return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils_default.forEach(value, function each(el, key) {
      const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils_default.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils_default.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
var toFormData_default = toFormData;
function encode(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match2) {
    return charMap[match2];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData_default(params, this, options);
}
var prototype2 = AxiosURLSearchParams.prototype;
prototype2.append = function append2(name, value) {
  this._pairs.push([name, value]);
};
prototype2.toString = function toString2(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode);
  } : encode;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
var AxiosURLSearchParams_default = AxiosURLSearchParams;
function encode2(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode2;
  if (utils_default.isFunction(options)) {
    options = {
      serialize: options
    };
  }
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}
var InterceptorManager = class {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils_default.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
};
var InterceptorManager_default = InterceptorManager;
var transitional_default = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
var URLSearchParams_default = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams_default;
var FormData_default = typeof FormData !== "undefined" ? FormData : null;
var Blob_default = typeof Blob !== "undefined" ? Blob : null;
var browser_default = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams_default,
    FormData: FormData_default,
    Blob: Blob_default
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
var utils_exports = {};
__export(utils_exports, {
  hasBrowserEnv: () => hasBrowserEnv,
  hasStandardBrowserEnv: () => hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv: () => hasStandardBrowserWebWorkerEnv,
  navigator: () => _navigator,
  origin: () => origin
});
var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
var _navigator = typeof navigator === "object" && navigator || void 0;
var hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
var hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
var origin = hasBrowserEnv && window.location.href || "http://localhost";
var platform_default = {
  ...utils_exports,
  ...browser_default
};
function toURLEncodedForm(data, options) {
  return toFormData_default(data, new platform_default.classes.URLSearchParams(), {
    visitor: function(value, key, path, helpers) {
      if (platform_default.isNode && utils_default.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    },
    ...options
  });
}
function parsePropPath(name) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name).map((match2) => {
    return match2[0] === "[]" ? "" : match2[1] || match2[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i2;
  const len = keys.length;
  let key;
  for (i2 = 0; i2 < len; i2++) {
    key = keys[i2];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];
    if (name === "__proto__") return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils_default.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils_default.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils_default.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path, value, target[name], index);
    if (result && utils_default.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    const obj = {};
    utils_default.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
var formDataToJSON_default = formDataToJSON;
function stringifySafely(rawValue, parser, encoder) {
  if (utils_default.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils_default.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults = {
  transitional: transitional_default,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils_default.isObject(data);
    if (isObjectPayload && utils_default.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils_default.isFormData(data);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
    }
    if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (utils_default.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils_default.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData_default(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils_default.isResponse(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw AxiosError_default.from(e, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform_default.classes.FormData,
    Blob: platform_default.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils_default.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
var defaults_default = defaults;
var ignoreDuplicateOf = utils_default.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var parseHeaders_default = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i2;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line2) {
    i2 = line2.indexOf(":");
    key = line2.substring(0, i2).trim().toLowerCase();
    val = line2.substring(i2 + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};
var $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match2;
  while (match2 = tokensRE.exec(str)) {
    tokens[match2[1]] = match2[2];
  }
  return tokens;
}
var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter22, isHeaderNameFilter) {
  if (utils_default.isFunction(filter22)) {
    return filter22.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils_default.isString(value)) return;
  if (utils_default.isString(filter22)) {
    return value.indexOf(filter22) !== -1;
  }
  if (utils_default.isRegExp(filter22)) {
    return filter22.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char2, str) => {
    return char2.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils_default.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
var AxiosHeaders = class {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils_default.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders_default(header), valueOrRewrite);
    } else if (utils_default.isObject(header) && utils_default.isIterable(header)) {
      let obj = {}, dest, key;
      for (const entry of header) {
        if (!utils_default.isArray(entry)) {
          throw TypeError("Object iterator must return a key-value pair");
        }
        obj[key = entry[0]] = (dest = obj[key]) ? utils_default.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
      }
      setHeaders(obj, valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils_default.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils_default.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils_default.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils_default.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i2 = keys.length;
    let deleted = false;
    while (i2--) {
      const key = keys[i2];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils_default.forEach(this, (value, header) => {
      const key = utils_default.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils_default.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype3 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype3, _header);
        accessors[lHeader] = true;
      }
    }
    utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils_default.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils_default.freezeMethods(AxiosHeaders);
var AxiosHeaders_default = AxiosHeaders;
function transformData(fns, response) {
  const config = this || defaults_default;
  const context = response || config;
  const headers = AxiosHeaders_default.from(context.headers);
  let data = context.data;
  utils_default.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}
function CanceledError(message, config, request) {
  AxiosError_default.call(this, message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config, request);
  this.name = "CanceledError";
}
utils_default.inherits(CanceledError, AxiosError_default, {
  __CANCEL__: true
});
var CanceledError_default = CanceledError;
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError_default(
      "Request failed with status code " + response.status,
      [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}
function parseProtocol(url) {
  const match2 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match2 && match2[1] || "";
}
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i2 = tail;
    let bytesCount = 0;
    while (i2 !== head) {
      bytesCount += bytes[i2++];
      i2 = i2 % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
var speedometer_default = speedometer;
function throttle(fn, freq) {
  let timestamp = 0;
  let threshold = 1e3 / freq;
  let lastArgs;
  let timer;
  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn(...args);
  };
  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if (passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };
  const flush = () => lastArgs && invoke(lastArgs);
  return [throttled, flush];
}
var throttle_default = throttle;
var progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer_default(50, 250);
  return throttle_default((e) => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e,
      lengthComputable: total != null,
      [isDownloadStream ? "download" : "upload"]: true
    };
    listener(data);
  }, freq);
};
var progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;
  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};
var asyncDecorator = (fn) => (...args) => utils_default.asap(() => fn(...args));
var isURLSameOrigin_default = platform_default.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url) => {
  url = new URL(url, platform_default.origin);
  return origin2.protocol === url.protocol && origin2.host === url.host && (isMSIE || origin2.port === url.port);
})(
  new URL(platform_default.origin),
  platform_default.navigator && /(msie|trident)/i.test(platform_default.navigator.userAgent)
) : () => true;
var cookies_default = platform_default.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path, domain, secure) {
      const cookie = [name + "=" + encodeURIComponent(value)];
      utils_default.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils_default.isString(path) && cookie.push("path=" + path);
      utils_default.isString(domain) && cookie.push("domain=" + domain);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
    },
    read(name) {
      const match2 = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match2 ? decodeURIComponent(match2[3]) : null;
    },
    remove(name) {
      this.write(name, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !isAbsoluteURL(requestedURL);
  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
var headersToObject = (thing) => thing instanceof AxiosHeaders_default ? { ...thing } : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, prop, caseless) {
    if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
      return utils_default.merge.call({ caseless }, target, source);
    } else if (utils_default.isPlainObject(source)) {
      return utils_default.merge({}, source);
    } else if (utils_default.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a2, b2, prop, caseless) {
    if (!utils_default.isUndefined(b2)) {
      return getMergedValue(a2, b2, prop, caseless);
    } else if (!utils_default.isUndefined(a2)) {
      return getMergedValue(void 0, a2, prop, caseless);
    }
  }
  function valueFromConfig2(a2, b2) {
    if (!utils_default.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    }
  }
  function defaultToConfig2(a2, b2) {
    if (!utils_default.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    } else if (!utils_default.isUndefined(a2)) {
      return getMergedValue(void 0, a2);
    }
  }
  function mergeDirectKeys(a2, b2, prop) {
    if (prop in config2) {
      return getMergedValue(a2, b2);
    } else if (prop in config1) {
      return getMergedValue(void 0, a2);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a2, b2, prop) => mergeDeepProperties(headersToObject(a2), headersToObject(b2), prop, true)
  };
  utils_default.forEach(Object.keys({ ...config1, ...config2 }), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils_default.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}
var resolveConfig_default = (config) => {
  const newConfig = mergeConfig({}, config);
  let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
  newConfig.headers = headers = AxiosHeaders_default.from(headers);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);
  if (auth) {
    headers.set(
      "Authorization",
      "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
    );
  }
  let contentType;
  if (utils_default.isFormData(data)) {
    if (platform_default.hasStandardBrowserEnv || platform_default.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(void 0);
    } else if ((contentType = headers.getContentType()) !== false) {
      const [type, ...tokens] = contentType ? contentType.split(";").map((token2) => token2.trim()).filter(Boolean) : [];
      headers.setContentType([type || "multipart/form-data", ...tokens].join("; "));
    }
  }
  if (platform_default.hasStandardBrowserEnv) {
    withXSRFToken && utils_default.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin_default(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies_default.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};
var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhr_default = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = resolveConfig_default(config);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders_default.from(_config.headers).normalize();
    let { responseType, onUploadProgress, onDownloadProgress } = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;
    function done() {
      flushUpload && flushUpload();
      flushDownload && flushDownload();
      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
      _config.signal && _config.signal.removeEventListener("abort", onCanceled);
    }
    let request = new XMLHttpRequest();
    request.open(_config.method.toUpperCase(), _config.url, true);
    request.timeout = _config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders_default.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config, request));
      request = null;
    };
    request.onerror = function handleError() {
      reject(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = _config.transitional || transitional_default;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError_default(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
        config,
        request
      ));
      request = null;
    };
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils_default.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = _config.responseType;
    }
    if (onDownloadProgress) {
      [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
      request.addEventListener("progress", downloadThrottled);
    }
    if (onUploadProgress && request.upload) {
      [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
      request.upload.addEventListener("progress", uploadThrottled);
      request.upload.addEventListener("loadend", flushUpload);
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError_default(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(_config.url);
    if (protocol && platform_default.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};
var composeSignals = (signals, timeout) => {
  const { length: length2 } = signals = signals ? signals.filter(Boolean) : [];
  if (timeout || length2) {
    let controller = new AbortController();
    let aborted;
    const onabort = function(reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof AxiosError_default ? err : new CanceledError_default(err instanceof Error ? err.message : err));
      }
    };
    let timer = timeout && setTimeout(() => {
      timer = null;
      onabort(new AxiosError_default(`timeout ${timeout} of ms exceeded`, AxiosError_default.ETIMEDOUT));
    }, timeout);
    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach((signal2) => {
          signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
        });
        signals = null;
      }
    };
    signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
    const { signal } = controller;
    signal.unsubscribe = () => utils_default.asap(unsubscribe);
    return signal;
  }
};
var composeSignals_default = composeSignals;
var streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end;
  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};
var readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
};
var readStream = async function* (stream) {
  if (stream[Symbol.asyncIterator]) {
    yield* stream;
    return;
  }
  const reader = stream.getReader();
  try {
    for (; ; ) {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
};
var trackStream = (stream, chunkSize, onProgress, onFinish) => {
  const iterator2 = readBytes(stream, chunkSize);
  let bytes = 0;
  let done;
  let _onFinish = (e) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e);
    }
  };
  return new ReadableStream({
    async pull(controller) {
      try {
        const { done: done2, value } = await iterator2.next();
        if (done2) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator2.return();
    }
  }, {
    highWaterMark: 2
  });
};
var isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
var isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
var encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
var test = (fn, ...args) => {
  try {
    return !!fn(...args);
  } catch (e) {
    return false;
  }
};
var supportsRequestStream = isReadableStreamSupported && test(() => {
  let duplexAccessed = false;
  const hasContentType = new Request(platform_default.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      duplexAccessed = true;
      return "half";
    }
  }).headers.has("Content-Type");
  return duplexAccessed && !hasContentType;
});
var DEFAULT_CHUNK_SIZE = 64 * 1024;
var supportsResponseStream = isReadableStreamSupported && test(() => utils_default.isReadableStream(new Response("").body));
var resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};
isFetchSupported && ((res) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
    !resolvers[type] && (resolvers[type] = utils_default.isFunction(res[type]) ? (res2) => res2[type]() : (_2, config) => {
      throw new AxiosError_default(`Response type '${type}' is not supported`, AxiosError_default.ERR_NOT_SUPPORT, config);
    });
  });
})(new Response());
var getBodyLength = async (body) => {
  if (body == null) {
    return 0;
  }
  if (utils_default.isBlob(body)) {
    return body.size;
  }
  if (utils_default.isSpecCompliantForm(body)) {
    const _request = new Request(platform_default.origin, {
      method: "POST",
      body
    });
    return (await _request.arrayBuffer()).byteLength;
  }
  if (utils_default.isArrayBufferView(body) || utils_default.isArrayBuffer(body)) {
    return body.byteLength;
  }
  if (utils_default.isURLSearchParams(body)) {
    body = body + "";
  }
  if (utils_default.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
};
var resolveBodyLength = async (headers, body) => {
  const length2 = utils_default.toFiniteNumber(headers.getContentLength());
  return length2 == null ? getBodyLength(body) : length2;
};
var fetch_default = isFetchSupported && (async (config) => {
  let {
    url,
    method,
    data,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = "same-origin",
    fetchOptions
  } = resolveConfig_default(config);
  responseType = responseType ? (responseType + "").toLowerCase() : "text";
  let composedSignal = composeSignals_default([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
  let request;
  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
    composedSignal.unsubscribe();
  });
  let requestContentLength;
  try {
    if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
      let _request = new Request(url, {
        method: "POST",
        body: data,
        duplex: "half"
      });
      let contentTypeHeader;
      if (utils_default.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
        headers.setContentType(contentTypeHeader);
      }
      if (_request.body) {
        const [onProgress, flush] = progressEventDecorator(
          requestContentLength,
          progressEventReducer(asyncDecorator(onUploadProgress))
        );
        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
      }
    }
    if (!utils_default.isString(withCredentials)) {
      withCredentials = withCredentials ? "include" : "omit";
    }
    const isCredentialsSupported = "credentials" in Request.prototype;
    request = new Request(url, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data,
      duplex: "half",
      credentials: isCredentialsSupported ? withCredentials : void 0
    });
    let response = await fetch(request, fetchOptions);
    const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
    if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
      const options = {};
      ["status", "statusText", "headers"].forEach((prop) => {
        options[prop] = response[prop];
      });
      const responseContentLength = utils_default.toFiniteNumber(response.headers.get("content-length"));
      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
        responseContentLength,
        progressEventReducer(asyncDecorator(onDownloadProgress), true)
      ) || [];
      response = new Response(
        trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
          flush && flush();
          unsubscribe && unsubscribe();
        }),
        options
      );
    }
    responseType = responseType || "text";
    let responseData = await resolvers[utils_default.findKey(resolvers, responseType) || "text"](response, config);
    !isStreamResponse && unsubscribe && unsubscribe();
    return await new Promise((resolve, reject) => {
      settle(resolve, reject, {
        data: responseData,
        headers: AxiosHeaders_default.from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config,
        request
      });
    });
  } catch (err) {
    unsubscribe && unsubscribe();
    if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
      throw Object.assign(
        new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request),
        {
          cause: err.cause || err
        }
      );
    }
    throw AxiosError_default.from(err, err && err.code, config, request);
  }
});
var knownAdapters = {
  http: null_default,
  xhr: xhr_default,
  fetch: fetch_default
};
utils_default.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
var renderReason = (reason) => `- ${reason}`;
var isResolvedHandle = (adapter) => utils_default.isFunction(adapter) || adapter === null || adapter === false;
var adapters_default = {
  getAdapter: (adapters) => {
    adapters = utils_default.isArray(adapters) ? adapters : [adapters];
    const { length: length2 } = adapters;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i2 = 0; i2 < length2; i2++) {
      nameOrAdapter = adapters[i2];
      let id;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError_default(`Unknown adapter '${id}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id || "#" + i2] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s2 = length2 ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError_default(
        `There is no suitable adapter to dispatch the request ` + s2,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  },
  adapters: knownAdapters
};
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError_default(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders_default.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters_default.getAdapter(config.adapter || defaults_default.adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders_default.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
var VERSION = "1.11.0";
var validators = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i2) => {
  validators[type] = function validator(thing) {
    return typeof thing === type || "a" + (i2 < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError_default(
        formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
        AxiosError_default.ERR_DEPRECATED
      );
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version + " and will be removed in the near future"
        )
      );
    }
    return validator ? validator(value, opt, opts) : true;
  };
};
validators.spelling = function spelling(correctSpelling) {
  return (value, opt) => {
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i2 = keys.length;
  while (i2-- > 0) {
    const opt = keys[i2];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === void 0 || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
    }
  }
}
var validator_default = {
  assertOptions,
  validators
};
var validators2 = validator_default.validators;
var Axios = class {
  constructor(instanceConfig) {
    this.defaults = instanceConfig || {};
    this.interceptors = {
      request: new InterceptorManager_default(),
      response: new InterceptorManager_default()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy = {};
        Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err.stack) {
            err.stack = stack;
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
            err.stack += "\n" + stack;
          }
        } catch (e) {
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== void 0) {
      validator_default.assertOptions(transitional2, {
        silentJSONParsing: validators2.transitional(validators2.boolean),
        forcedJSONParsing: validators2.transitional(validators2.boolean),
        clarifyTimeoutError: validators2.transitional(validators2.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils_default.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator_default.assertOptions(paramsSerializer, {
          encode: validators2.function,
          serialize: validators2.function
        }, true);
      }
    }
    if (config.allowAbsoluteUrls !== void 0) {
    } else if (this.defaults.allowAbsoluteUrls !== void 0) {
      config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
    } else {
      config.allowAbsoluteUrls = true;
    }
    validator_default.assertOptions(config, {
      baseUrl: validators2.spelling("baseURL"),
      withXsrfToken: validators2.spelling("withXSRFToken")
    }, true);
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils_default.merge(
      headers.common,
      headers[config.method]
    );
    headers && utils_default.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config.headers = AxiosHeaders_default.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i2 = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift(...requestInterceptorChain);
      chain.push(...responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i2 < len) {
        promise = promise.then(chain[i2++], chain[i2++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i2 = 0;
    while (i2 < len) {
      const onFulfilled = requestInterceptorChain[i2++];
      const onRejected = requestInterceptorChain[i2++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i2 = 0;
    len = responseInterceptorChain.length;
    while (i2 < len) {
      promise = promise.then(responseInterceptorChain[i2++], responseInterceptorChain[i2++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
};
utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_default = Axios;
var CancelToken = class _CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token2 = this;
    this.promise.then((cancel) => {
      if (!token2._listeners) return;
      let i2 = token2._listeners.length;
      while (i2-- > 0) {
        token2._listeners[i2](cancel);
      }
      token2._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token2.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token2.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request) {
      if (token2.reason) {
        return;
      }
      token2.reason = new CanceledError_default(message, config, request);
      resolvePromise(token2.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  toAbortSignal() {
    const controller = new AbortController();
    const abort = (err) => {
      controller.abort(err);
    };
    this.subscribe(abort);
    controller.signal.unsubscribe = () => this.unsubscribe(abort);
    return controller.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token2 = new _CancelToken(function executor(c2) {
      cancel = c2;
    });
    return {
      token: token2,
      cancel
    };
  }
};
var CancelToken_default = CancelToken;
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === true;
}
var HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
var HttpStatusCode_default = HttpStatusCode;
function createInstance(defaultConfig) {
  const context = new Axios_default(defaultConfig);
  const instance = bind(Axios_default.prototype.request, context);
  utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
  utils_default.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios = createInstance(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders_default;
axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters_default.getAdapter;
axios.HttpStatusCode = HttpStatusCode_default;
axios.default = axios;
var axios_default = axios;
var {
  Axios: Axios2,
  AxiosError: AxiosError2,
  CanceledError: CanceledError2,
  isCancel: isCancel2,
  CancelToken: CancelToken2,
  VERSION: VERSION2,
  all: all2,
  Cancel,
  isAxiosError: isAxiosError2,
  spread: spread2,
  toFormData: toFormData2,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode: HttpStatusCode2,
  formToJSON,
  getAdapter,
  mergeConfig: mergeConfig2
} = axios_default;
var APP_URL = "app-url";
var CONTEXT_IDENTITY = "context-identity";
var ACCESS_TOKEN = "access-token";
var CONTEXT_ID = "context-id";
var REFRESH_TOKEN = "refresh-token";
var APPLICATION_ID = "application-id";
var setAppEndpointKey = (url) => {
  localStorage.setItem(APP_URL, JSON.stringify(url));
};
var getAppEndpointKey = () => {
  try {
    if (typeof window !== "undefined" && window.localStorage) {
      const urlEndpoint = localStorage.getItem(APP_URL);
      return urlEndpoint ? JSON.parse(urlEndpoint) : null;
    }
  } catch (e) {
    console.error(e);
  }
  return null;
};
var clearAppEndpoint = () => {
  localStorage.removeItem(APP_URL);
};
var setApplicationId = (applicationId) => {
  localStorage.setItem(APPLICATION_ID, JSON.stringify(applicationId));
};
var getApplicationId = () => {
  try {
    if (typeof window !== "undefined" && window.localStorage) {
      const applicationId = localStorage.getItem(APPLICATION_ID);
      return applicationId ? JSON.parse(applicationId) : null;
    }
  } catch (e) {
    console.error(e);
  }
  return null;
};
var clearApplicationId = () => {
  localStorage.removeItem(APPLICATION_ID);
};
var setContextAndIdentityFromJWT = (accessToken) => {
  try {
    const parts = accessToken.split(".");
    if (parts.length !== 3) {
      console.error("Invalid JWT token format received:", accessToken);
      throw new Error("Invalid JWT token format");
    }
    const payloadString = atob(parts[1]);
    const jwt = JSON.parse(payloadString);
    if (jwt.permissions) {
      const contextPermission = jwt.permissions.find(
        (permission) => permission.startsWith("context[") && permission.endsWith("]")
      );
      if (contextPermission) {
        const content = contextPermission.substring(
          contextPermission.indexOf("[") + 1,
          contextPermission.lastIndexOf("]")
        );
        const [contextId, contextIdentity] = content.split(",");
        if (contextId && contextIdentity) {
          setContextId(contextId);
          setExecutorPublicKey(contextIdentity);
        } else {
          console.warn(
            "Failed to extract context_id or context_identity from permissions"
          );
        }
      } else {
        console.warn("No context permission found in JWT token");
      }
    } else {
      console.warn("JWT payload missing permissions field");
    }
  } catch (error) {
    console.error("Failed to set access token or extract JWT info:", error);
  }
};
var setAccessToken = (accessToken) => {
  localStorage.setItem(ACCESS_TOKEN, JSON.stringify(accessToken));
};
var getAccessToken = () => {
  try {
    if (typeof window !== "undefined" && window.localStorage) {
      const accessToken = localStorage.getItem(ACCESS_TOKEN);
      return accessToken ? JSON.parse(accessToken) : null;
    }
  } catch (e) {
    console.error(e);
  }
  return null;
};
var clearAccessToken = () => {
  localStorage.removeItem(ACCESS_TOKEN);
  localStorage.removeItem(REFRESH_TOKEN);
};
var setContextId = (contextId) => {
  localStorage.setItem(CONTEXT_ID, JSON.stringify(contextId));
};
var getContextId = () => {
  try {
    if (typeof window !== "undefined" && window.localStorage) {
      const contextId = localStorage.getItem(CONTEXT_ID);
      return contextId ? JSON.parse(contextId) : null;
    }
  } catch (e) {
    console.error(e);
  }
  return null;
};
var clearContextId = () => {
  localStorage.removeItem(CONTEXT_ID);
};
var setRefreshToken = (refreshToken) => {
  localStorage.setItem(REFRESH_TOKEN, JSON.stringify(refreshToken));
};
var getRefreshToken = () => {
  try {
    if (typeof window !== "undefined" && window.localStorage) {
      const refreshToken = localStorage.getItem(REFRESH_TOKEN);
      return refreshToken ? JSON.parse(refreshToken) : null;
    }
  } catch (e) {
    console.error(e);
  }
  return null;
};
var clearRefreshToken = () => {
  localStorage.removeItem(REFRESH_TOKEN);
};
var setExecutorPublicKey = (publicKey) => {
  localStorage.setItem(CONTEXT_IDENTITY, JSON.stringify(publicKey));
};
var getExecutorPublicKey = () => {
  try {
    if (typeof window !== "undefined" && window.localStorage) {
      let contextIdentity = localStorage.getItem(CONTEXT_IDENTITY);
      return contextIdentity ? JSON.parse(contextIdentity) : null;
    }
    return null;
  } catch (e) {
    console.error(e);
  }
  return null;
};
var clearExecutorPublicKey = () => {
  localStorage.removeItem(CONTEXT_IDENTITY);
};
var getJWTObject = () => {
  try {
    const token2 = getAccessToken();
    if (!token2) return null;
    const parts = token2.split(".");
    if (parts.length !== 3) {
      throw new Error("Invalid JWT token");
    }
    const payload = JSON.parse(atob(parts[1]));
    return payload;
  } catch (e) {
    console.error(e);
  }
  return null;
};
var clientLogout = () => {
  clearAccessToken();
  clearApplicationId();
  clearContextId();
  clearExecutorPublicKey();
  window.location.reload();
};
var createErrorResponse = (error) => ({
  appEndpointKey: null,
  contextId: null,
  executorPublicKey: null,
  jwtToken: null,
  error
});
var getAuthConfig = () => {
  const config = {
    appEndpointKey: getAppEndpointKey(),
    contextId: getContextId(),
    executorPublicKey: getExecutorPublicKey(),
    jwtToken: getAccessToken(),
    error: null
  };
  if (!config.appEndpointKey) {
    return createErrorResponse("Missing app endpoint key");
  }
  const hasJwtToken = !!config.jwtToken;
  const hasContextId = !!config.contextId;
  const hasExecutorPublicKey = !!config.executorPublicKey;
  if (!hasJwtToken && !(hasContextId && hasExecutorPublicKey)) {
    return createErrorResponse(
      "Missing authentication information. Either JWT token or both context ID and executor public key must be present."
    );
  }
  return config;
};
var AxiosHttpClient = class {
  constructor(axios2) {
    __publicField(this, "axios");
    __publicField(this, "isRefreshing", false);
    __publicField(this, "failedQueue", []);
    this.axios = axios2;
  }
  isRefreshRequest(config) {
    const baseUrl = getAppEndpointKey();
    return (config == null ? void 0 : config.url) === `${baseUrl}/public/refresh`;
  }
  processQueue(error, token2 = null) {
    const uniqueRequests = this.failedQueue.filter(
      (promise) => !this.isRefreshRequest(promise.config)
    );
    uniqueRequests.forEach((promise) => {
      if (error) {
        promise.reject(error);
      } else {
        if (token2) {
          promise.config.headers.Authorization = `Bearer ${token2}`;
        }
        promise.resolve(this.request(this.axios.request(promise.config)));
      }
    });
    this.failedQueue = [];
  }
  async handleTokenRefresh(originalRequest) {
    if (this.isRefreshing) {
      if (this.isRefreshRequest(originalRequest)) {
        return Promise.reject(new Error("Token refresh already in progress"));
      }
      return new Promise((resolve, reject) => {
        this.failedQueue.push({
          resolve,
          reject,
          config: originalRequest
        });
      });
    }
    try {
      this.isRefreshing = true;
      const refreshToken = getRefreshToken();
      const accessToken = getAccessToken();
      if (!refreshToken || !accessToken) {
        throw new Error("Missing tokens for refresh");
      }
      const response = await authClient.refreshToken({
        access_token: accessToken,
        refresh_token: refreshToken
      });
      if (response.error || !response.data) {
        throw new Error("Failed to refresh token");
      }
      setAccessToken(response.data.access_token);
      setRefreshToken(response.data.refresh_token);
      originalRequest.headers.Authorization = `Bearer ${response.data.access_token}`;
      this.processQueue(null, response.data.access_token);
      this.isRefreshing = false;
      return this.request(this.axios.request(originalRequest));
    } catch (error) {
      this.isRefreshing = false;
      this.processQueue(new Error("Failed to refresh token"));
      clearAccessToken();
      throw error;
    }
  }
  async request(promise, isJsonRpc = false, responseType) {
    var _a, _b, _c, _d, _e2, _f, _g, _h, _i;
    try {
      const response = await promise;
      if (((_b = (_a = response == null ? void 0 : response.config) == null ? void 0 : _a.method) == null ? void 0 : _b.toUpperCase()) === "HEAD") {
        const headers = {};
        if (response.headers) {
          Object.entries(response.headers).forEach(([key, value]) => {
            if (value !== void 0) {
              headers[key] = Array.isArray(value) ? value.join(", ") : String(value);
            }
          });
        }
        const headResponse = {
          headers,
          status: response.status
        };
        return {
          data: headResponse,
          error: null
        };
      }
      if (responseType === "arraybuffer" || responseType === "blob") {
        return {
          data: response.data,
          error: null
        };
      }
      const responseData = isJsonRpc ? response.data : response.data.data;
      return {
        data: responseData,
        error: null
      };
    } catch (e) {
      if (e instanceof AxiosError2) {
        const status = (_c = e.response) == null ? void 0 : _c.status;
        const headers = (_d = e.response) == null ? void 0 : _d.headers;
        const body = (_e2 = e.response) == null ? void 0 : _e2.data;
        if (status === 401) {
          const authError = headers == null ? void 0 : headers["x-auth-error"];
          switch (authError) {
            case "missing_token":
              return {
                data: null,
                error: {
                  code: 401,
                  message: "No access token found."
                }
              };
            case "token_expired":
              try {
                return await this.handleTokenRefresh(e.config);
              } catch (refreshError) {
                clearAccessToken();
                return {
                  data: null,
                  error: {
                    code: 401,
                    message: "Session expired. Please log in again."
                  }
                };
              }
            case "token_revoked":
              clientLogout();
              return {
                data: null,
                error: {
                  code: 401,
                  message: "Session was revoked. Please log in again."
                }
              };
            case "invalid_token":
              clientLogout();
              return {
                data: null,
                error: {
                  code: 401,
                  message: "Invalid authentication. Please log in again."
                }
              };
            default:
              return {
                data: null,
                error: {
                  code: 401,
                  message: body.error
                }
              };
          }
        }
        if (((_g = (_f = e == null ? void 0 : e.config) == null ? void 0 : _f.method) == null ? void 0 : _g.toUpperCase()) === "HEAD") {
          return {
            data: null,
            error: {
              code: e.request.status,
              message: e.message
            }
          };
        }
        const error = ((_h = e.response) == null ? void 0 : _h.data.error) ?? ((_i = e.response) == null ? void 0 : _i.data);
        if (!error) {
          return {
            data: null,
            error: {
              code: status ?? 500,
              message: e.message || "Something went wrong"
            }
          };
        }
        if (typeof error === "string") {
          return {
            data: null,
            error: {
              code: status ?? 500,
              message: error
            }
          };
        }
        return {
          data: null,
          error: {
            code: status ?? error.code ?? 500,
            message: error.message
          }
        };
      }
      return {
        data: null,
        error: GENERIC_ERROR
      };
    }
  }
  getAuthHeaders() {
    const token2 = getAccessToken();
    return token2 ? { Authorization: `Bearer ${token2}` } : {};
  }
  async get(url, headers, isJsonRpc = false, options) {
    const authHeaders = this.getAuthHeaders();
    const mergedHeaders = headers == null ? void 0 : headers.reduce(
      (acc, curr) => ({ ...acc, ...curr }),
      {}
    );
    return this.request(
      this.axios.get(url, {
        headers: { ...authHeaders, ...mergedHeaders },
        responseType: options == null ? void 0 : options.responseType
      }),
      isJsonRpc,
      options == null ? void 0 : options.responseType
    );
  }
  async post(url, body, headers, isJsonRpc = false) {
    const authHeaders = this.getAuthHeaders();
    const mergedHeaders = headers == null ? void 0 : headers.reduce(
      (acc, curr) => ({ ...acc, ...curr }),
      {}
    );
    return this.request(
      this.axios.post(url, body, {
        headers: { ...authHeaders, ...mergedHeaders }
      }),
      isJsonRpc
    );
  }
  async put(url, body, headers, isJsonRpc = false, onUploadProgress) {
    const authHeaders = this.getAuthHeaders();
    const mergedHeaders = headers == null ? void 0 : headers.reduce(
      (acc, curr) => ({ ...acc, ...curr }),
      {}
    );
    const config = {
      headers: { ...authHeaders, ...mergedHeaders }
    };
    if (onUploadProgress) {
      config.onUploadProgress = (progressEvent) => {
        if (progressEvent.lengthComputable) {
          const progress = progressEvent.loaded / progressEvent.total * 100;
          onUploadProgress(progress);
        }
      };
    }
    return this.request(this.axios.put(url, body, config), isJsonRpc);
  }
  async delete(url, headers, isJsonRpc = false) {
    const authHeaders = this.getAuthHeaders();
    const mergedHeaders = headers == null ? void 0 : headers.reduce(
      (acc, curr) => ({ ...acc, ...curr }),
      {}
    );
    return this.request(
      this.axios.delete(url, {
        headers: { ...authHeaders, ...mergedHeaders }
      }),
      isJsonRpc
    );
  }
  async patch(url, body, headers, isJsonRpc = false) {
    const authHeaders = this.getAuthHeaders();
    const mergedHeaders = headers == null ? void 0 : headers.reduce(
      (acc, curr) => ({ ...acc, ...curr }),
      {}
    );
    return this.request(
      this.axios.patch(url, body, {
        headers: { ...authHeaders, ...mergedHeaders }
      }),
      isJsonRpc
    );
  }
  async head(url, headers) {
    const authHeaders = this.getAuthHeaders();
    const mergedHeaders = headers == null ? void 0 : headers.reduce(
      (acc, curr) => ({ ...acc, ...curr }),
      {}
    );
    return this.request(
      this.axios.head(url, {
        headers: { ...authHeaders, ...mergedHeaders }
      })
    );
  }
  // Expose refresh mechanism for RPC error handling
  async refreshTokens() {
    const refreshToken = getRefreshToken();
    const accessToken = getAccessToken();
    if (!refreshToken || !accessToken) {
      return { error: { code: 401, message: "Missing tokens for refresh" } };
    }
    const response = await authClient.refreshToken({
      access_token: accessToken,
      refresh_token: refreshToken
    });
    if (response.data) {
      setAccessToken(response.data.access_token);
      setRefreshToken(response.data.refresh_token);
    }
    return response;
  }
};
var GENERIC_ERROR = {
  code: 500,
  message: "Something went wrong"
};
var NodeApiDataSource = class {
  constructor(client) {
    this.client = client;
  }
  get baseUrl() {
    return getAppEndpointKey();
  }
  async health(request) {
    return await this.client.get(
      `${request.url}/admin-api/health`
    );
  }
  async getContext(contextId) {
    try {
      return this.client.get(
        `${this.baseUrl}/admin-api/contexts/${contextId}`
      );
    } catch (error) {
      console.error("Error fetching context:", error);
      return {
        data: null,
        error: { code: 500, message: "Failed to fetch context data." }
      };
    }
  }
  async getContexts() {
    try {
      const response = await this.client.get(
        `${this.baseUrl}/admin-api/contexts`
      );
      return response;
    } catch (error) {
      console.error("Error fetching contexts:", error);
      return { error: { code: 500, message: "Failed to fetch context data." } };
    }
  }
  async createContext(applicationId, jsonParams, protocol) {
    const initializationParams = jsonParams === "" ? [] : Array.from(new TextEncoder().encode(jsonParams));
    try {
      const response = await this.client.post(
        `${this.baseUrl}/admin-api/contexts`,
        {
          applicationId,
          initializationParams,
          protocol
        }
      );
      return response;
    } catch (error) {
      console.error("Error starting contexts:", error);
      return { error: { code: 500, message: "Failed to start context." } };
    }
  }
  async deleteContext(contextId) {
    try {
      const response = await this.client.delete(
        `${this.baseUrl}/admin-api/contexts/${contextId}`
      );
      return response;
    } catch (error) {
      console.error("Error deleting context:", error);
      return { error: { code: 500, message: "Failed to delete context." } };
    }
  }
  async fetchContextIdentities(contextId) {
    try {
      const response = await this.client.get(
        `${this.baseUrl}/admin-api/contexts/${contextId}/identities-owned`
      );
      return response;
    } catch (error) {
      console.error("Error deleting context:", error);
      return { error: { code: 500, message: "Failed to delete context." } };
    }
  }
  async createNewIdentity() {
    try {
      const response = await this.client.post(
        `${this.baseUrl}/admin-api/identity/context`
      );
      return response;
    } catch (error) {
      console.error("Error creating new identity:", error);
      return {
        error: { code: 500, message: "Failed to create new identity." }
      };
    }
  }
  async contextInvite(contextId, inviterPublicKey, inviteePublicKey) {
    try {
      const response = await this.client.post(
        `${this.baseUrl}/admin-api/contexts/invite`,
        {
          contextId,
          inviterId: inviterPublicKey,
          inviteeId: inviteePublicKey
        }
      );
      return response;
    } catch (error) {
      console.error("Error inviting to context:", error);
      return { error: { code: 500, message: "Failed to invite to context." } };
    }
  }
  async joinContext(invitationPayload) {
    try {
      const response = await this.client.post(
        `${this.baseUrl}/admin-api/contexts/join`,
        {
          invitationPayload
        }
      );
      return response;
    } catch (error) {
      console.error("Error joining context:", error);
      return { error: { code: 500, message: "Failed to join context." } };
    }
  }
  // Application Management
  async getInstalledApplications() {
    try {
      const response = await this.client.get(
        `${this.baseUrl}/admin-api/applications`
      );
      return response;
    } catch (error) {
      console.error("Error fetching installed applications:", error);
      return {
        error: {
          code: 500,
          message: "Failed to fetch installed applications."
        }
      };
    }
  }
  async getInstalledApplicationDetails(appId) {
    try {
      const response = await this.client.get(
        `${this.baseUrl}/admin-api/applications/${appId}`
      );
      return response;
    } catch (error) {
      console.error("Error fetching application details:", error);
      return {
        error: { code: 500, message: "Failed to fetch application details." }
      };
    }
  }
  async installApplication(url, metadata, hash2) {
    try {
      const requestBody = {
        url,
        metadata: metadata ? Array.from(metadata) : [],
        ...hash2 ? { hash: hash2 } : {}
      };
      const response = await this.client.post(
        `${this.baseUrl}/admin-api/install-application`,
        requestBody
      );
      return response;
    } catch (error) {
      console.error("Error installing application:", error);
      return {
        error: { code: 500, message: "Failed to install application." }
      };
    }
  }
  async uninstallApplication(applicationId) {
    try {
      const response = await this.client.delete(
        `${this.baseUrl}/admin-api/applications/${applicationId}`
      );
      return response;
    } catch (error) {
      console.error("Error uninstalling application:", error);
      return {
        error: { code: 500, message: "Failed to uninstall application." }
      };
    }
  }
  // Context Management Extended
  async getContextClientKeys(contextId) {
    try {
      const response = await this.client.get(
        `${this.baseUrl}/admin-api/contexts/${contextId}/client-keys`
      );
      return response;
    } catch (error) {
      console.error("Error fetching context client keys:", error);
      return {
        error: { code: 500, message: "Failed to fetch context client keys." }
      };
    }
  }
  async getContextUsers(contextId) {
    try {
      const response = await this.client.get(
        `${this.baseUrl}/admin-api/contexts/${contextId}/identities`
      );
      return response;
    } catch (error) {
      console.error("Error fetching context users:", error);
      return {
        error: { code: 500, message: "Failed to fetch context users." }
      };
    }
  }
  async getContextStorageUsage(contextId) {
    try {
      const response = await this.client.get(
        `${this.baseUrl}/admin-api/contexts/${contextId}/storage`
      );
      return response;
    } catch (error) {
      console.error("Error fetching context storage usage:", error);
      return {
        error: { code: 500, message: "Failed to fetch context storage usage." }
      };
    }
  }
  async grantCapabilities(contextId, request) {
    try {
      const response = await this.client.post(
        `${this.baseUrl}/admin-api/contexts/${contextId}/capabilities/grant`,
        request
      );
      return response;
    } catch (error) {
      console.error("Error granting capabilities:", error);
      return { error: { code: 500, message: "Failed to grant capabilities." } };
    }
  }
  async revokeCapabilities(contextId, request) {
    try {
      const response = await this.client.post(
        `${this.baseUrl}/admin-api/contexts/${contextId}/capabilities/revoke`,
        request
      );
      return response;
    } catch (error) {
      console.error("Error revoking capabilities:", error);
      return {
        error: { code: 500, message: "Failed to revoke capabilities." }
      };
    }
  }
  async checkAuth() {
    const response = await this.client.get(
      `${this.baseUrl}/admin-api/is-authed`
    );
    return response;
  }
};
var AuthApiDataSource = class {
  constructor(client) {
    this.client = client;
  }
  get baseUrl() {
    return getAppEndpointKey();
  }
  async login(request) {
    try {
      window.location.href = `${request.url}/auth/login?callback-url=${encodeURIComponent(request.callbackUrl)}&permissions=${encodeURIComponent(request.permissions.join(","))}&${APPLICATION_ID}=${encodeURIComponent(request.applicationId)}&application-path=${encodeURIComponent(request.applicationPath)}&${APP_URL}=${encodeURIComponent(this.baseUrl)}`;
      return { data: null };
    } catch (error) {
      console.error("Error during login redirect:", error);
      return {
        error: {
          code: 500,
          message: "Login redirect failed. Please try again."
        }
      };
    }
  }
  async refreshToken(request) {
    try {
      const response = await this.client.post(
        `${this.baseUrl}/auth/refresh`,
        request
      );
      return response;
    } catch (error) {
      console.error("Error refreshing token:", error);
      return {
        error: {
          code: 500,
          message: "Token refresh failed. Please try again."
        }
      };
    }
  }
  async getProviders() {
    try {
      const response = await this.client.get(
        `${this.baseUrl}/auth/providers`
      );
      return response;
    } catch (error) {
      console.error("Error getting providers:", error);
      return { error: { code: 500, message: "Failed to get providers." } };
    }
  }
  async requestToken(requestBody) {
    try {
      const response = await this.client.post(
        `${this.baseUrl}/auth/token`,
        requestBody
      );
      return response;
    } catch (error) {
      console.error("Error requesting token:", error);
      return {
        error: {
          code: 500,
          message: "Token request failed. Please try again."
        }
      };
    }
  }
  async getChallenge() {
    try {
      const response = await this.client.get(
        `${this.baseUrl}/auth/challenge`
      );
      return response;
    } catch (error) {
      console.error("Error getting challenge:", error);
      return { error: { code: 500, message: "Failed to get challenge." } };
    }
  }
  async generateClientKey(request) {
    try {
      const response = await this.client.post(
        `${this.baseUrl}/admin/client-key`,
        request
      );
      return response;
    } catch (error) {
      console.error("Error generating client key:", error);
      return {
        error: { code: 500, message: "Failed to generate client key." }
      };
    }
  }
};
var ContractApiDataSource = class {
  constructor(client) {
    this.client = client;
  }
  get baseUrl() {
    return getAppEndpointKey();
  }
  get contextId() {
    const id = getContextId();
    if (!id) {
      throw new Error(
        "Context ID not available. Make sure you are properly authenticated."
      );
    }
    return id;
  }
  async getProposals(request) {
    try {
      return await this.client.post(
        `${this.baseUrl}/admin-api/contexts/${this.contextId}/proposals`,
        request
      );
    } catch (error) {
      return {
        data: null,
        error
      };
    }
  }
  async getProposalApprovers(proposalId) {
    try {
      return await this.client.get(
        `${this.baseUrl}/admin-api/contexts/${this.contextId}/proposals/${proposalId}/approvals/users`
      );
    } catch (error) {
      return {
        data: null,
        error
      };
    }
  }
  async getProposalApprovalCount(proposalId) {
    try {
      return await this.client.get(
        `${this.baseUrl}/admin-api/contexts/${this.contextId}/proposals/${proposalId}/approvals/count`
      );
    } catch (error) {
      return {
        data: null,
        error
      };
    }
  }
  async getNumOfProposals() {
    try {
      return await this.client.get(
        `${this.baseUrl}/admin-api/contexts/${this.contextId}/proposals/count`
      );
    } catch (error) {
      return {
        data: null,
        error
      };
    }
  }
  async getProposalDetails(proposalId) {
    try {
      return await this.client.get(
        `${this.baseUrl}/admin-api/contexts/${this.contextId}/proposals/${proposalId}`
      );
    } catch (error) {
      return {
        data: null,
        error
      };
    }
  }
  async getContextValue(key) {
    try {
      return await this.client.post(
        `${this.baseUrl}/admin-api/contexts/${this.contextId}`,
        {
          key
        }
      );
    } catch (error) {
      return {
        data: null,
        error
      };
    }
  }
  async getContextStorageEntries(offset, limit) {
    try {
      return await this.client.post(
        `${this.baseUrl}/admin-api/contexts/${this.contextId}/proposals/context-storage-entries`,
        {
          offset,
          limit
        }
      );
    } catch (error) {
      return {
        data: null,
        error
      };
    }
  }
};
var errorTypes = [
  "UnknownServerError",
  "RpcExecutionError",
  "FunctionCallError",
  "CallError",
  "MissmatchedRequestIdError",
  "InvalidRequestError",
  "ParseError"
];
var JsonRpcClient = class {
  constructor(httpClient) {
    __publicField(this, "path", "/jsonrpc");
    __publicField(this, "httpClient");
    this.httpClient = httpClient;
  }
  handleRpcError(error) {
    var _a, _b;
    if (error.code === 401) {
      const authError = (_a = error.headers) == null ? void 0 : _a["x-auth-error"];
      switch (authError) {
        case "token_expired":
          return {
            ...error,
            error: {
              name: "AuthenticationError",
              cause: {
                name: "AuthenticationError",
                info: {
                  message: "Token expired. Please try again."
                }
              }
            }
          };
        case "token_revoked":
          return {
            ...error,
            error: {
              name: "AuthenticationError",
              cause: {
                name: "AuthenticationError",
                info: {
                  message: "Your session was revoked. Please log in again."
                }
              }
            }
          };
        case "invalid_token":
          return {
            ...error,
            error: {
              name: "AuthenticationError",
              cause: {
                name: "AuthenticationError",
                info: {
                  message: "Invalid authentication. Please log in again."
                }
              }
            }
          };
        default:
          return {
            ...error,
            error: {
              name: "AuthenticationError",
              cause: {
                name: "AuthenticationError",
                info: {
                  message: "Authentication required. Please log in."
                }
              }
            }
          };
      }
    }
    const errorType = (_b = error == null ? void 0 : error.error) == null ? void 0 : _b.name;
    if (errorTypes.includes(errorType)) {
      return error;
    }
    return {
      ...error,
      error: {
        name: "UnknownServerError",
        cause: {
          name: "UnknownServerError",
          info: {
            message: "Server Error: Something went wrong. Please try again."
          }
        }
      }
    };
  }
  /**
   * @function execute
   * @description Executes a JSON RPC request - query or mutate.
   * @param {RpcQueryParams<Args>} params - The parameters for the JSON RPC request.
   * @param {RequestConfig} config - The configuration for the JSON RPC request.
   * @returns {Promise<RpcResult<RpcQueryResponse<Output>>>} The result of the JSON RPC request.
   */
  async execute(params, config) {
    return await this.request(
      "execute",
      params,
      config
    );
  }
  async request(method, params, config) {
    var _a, _b, _c, _d;
    const requestId = this.getRandomRequestId();
    const data = {
      jsonrpc: "2.0",
      id: requestId,
      method,
      params
    };
    const baseUrl = getAppEndpointKey();
    try {
      const response = await this.httpClient.post(
        `${baseUrl}${this.path}`,
        data,
        (config == null ? void 0 : config.headers) ? [config.headers] : void 0,
        true
        // Set isJsonRpc flag to true
      );
      if (!response.error) {
        const jsonRpcResponse = response.data;
        if (jsonRpcResponse.id !== requestId) {
          const error = {
            code: 400,
            id: jsonRpcResponse.id,
            jsonrpc: jsonRpcResponse.jsonrpc,
            headers: {},
            error: {
              name: "MissmatchedRequestIdError",
              cause: {
                name: "MissmatchedRequestIdError",
                info: {
                  message: `Missmatched RequestId expected ${requestId}, got ${jsonRpcResponse.id}`
                }
              }
            }
          };
          return { error: this.handleRpcError(error) };
        }
        if (jsonRpcResponse.error) {
          let messageData = jsonRpcResponse.error.data;
          let errorMessage = "";
          if (typeof messageData === "string") {
            errorMessage = messageData;
          } else {
            errorMessage = messageData.type;
          }
          const error = {
            code: 400,
            id: jsonRpcResponse.id,
            jsonrpc: jsonRpcResponse.jsonrpc,
            headers: {},
            error: {
              name: jsonRpcResponse.error.type,
              cause: {
                name: ((_a = jsonRpcResponse.error.data) == null ? void 0 : _a.type) ?? jsonRpcResponse.error.type,
                info: {
                  message: errorMessage
                }
              }
            }
          };
          return { error: this.handleRpcError(error) };
        }
        return {
          result: jsonRpcResponse.result
        };
      } else {
        const rpcError = {
          id: requestId,
          jsonrpc: "2.0",
          code: response.error.code ?? 500,
          headers: {},
          error: {
            name: "UnknownServerError",
            cause: {
              name: "UnknownServerError",
              info: {
                message: response.error.message ?? "Server Error: Something went wrong. Please try again."
              }
            }
          }
        };
        return { error: this.handleRpcError(rpcError) };
      }
    } catch (error) {
      const rpcError = {
        id: requestId,
        jsonrpc: "2.0",
        code: ((_b = error == null ? void 0 : error.response) == null ? void 0 : _b.status) ?? 500,
        headers: Object.fromEntries(
          Object.entries(((_c = error == null ? void 0 : error.response) == null ? void 0 : _c.headers) || {}).map(([key, value]) => [
            key,
            String(value)
          ])
        ),
        error: {
          name: "UnknownServerError",
          cause: {
            name: "UnknownServerError",
            info: {
              message: `${error.message ?? ((_d = error == null ? void 0 : error.response) == null ? void 0 : _d.data)}.
 Verify that the node server is running.`
            }
          }
        }
      };
      return { error: this.handleRpcError(rpcError) };
    }
  }
  getRandomRequestId() {
    return Math.floor(Math.random() * Math.pow(2, 32));
  }
};
var AdminApiDataSource = class {
  constructor(client) {
    this.client = client;
  }
  get baseUrl() {
    return getAppEndpointKey();
  }
  async getRootKeys() {
    try {
      const response = await this.client.get(
        `${this.baseUrl}/admin/keys`
      );
      return response;
    } catch (error) {
      console.error("Error fetching root keys:", error);
      return { error: { code: 500, message: "Failed to fetch root keys." } };
    }
  }
  async getClientKeys() {
    try {
      const response = await this.client.get(
        `${this.baseUrl}/admin/keys/clients`
      );
      return response;
    } catch (error) {
      console.error("Error fetching client keys:", error);
      return { error: { code: 500, message: "Failed to fetch client keys." } };
    }
  }
  async addRootKey(rootKeyRequest) {
    try {
      const response = await this.client.post(
        `${this.baseUrl}/admin/keys`,
        rootKeyRequest
      );
      return response;
    } catch (error) {
      console.error("Error adding root key:", error);
      return { error: { code: 500, message: "Failed to add root key." } };
    }
  }
  async revokeRootKey(keyId) {
    try {
      const response = await this.client.delete(
        `${this.baseUrl}/admin/keys/${keyId}`
      );
      return response;
    } catch (error) {
      console.error("Error deleting root key:", error);
      return { error: { code: 500, message: "Failed to delete root key." } };
    }
  }
  async revokeClientKey(rootKeyId, clientId) {
    try {
      const response = await this.client.delete(
        `${this.baseUrl}/admin/keys/${rootKeyId}/clients/${clientId}`
      );
      return response;
    } catch (error) {
      console.error("Error revoking client key:", error);
      return { error: { code: 500, message: "Failed to revoke client key." } };
    }
  }
  async setKeyPermissions(keyId, request) {
    try {
      const response = await this.client.put(
        `${this.baseUrl}/admin/keys/${keyId}/permissions`,
        request
      );
      return response;
    } catch (error) {
      console.error("Error updating key permissions:", error);
      return {
        error: { code: 500, message: "Failed to update key permissions." }
      };
    }
  }
};
var BlobApiDataSource = class {
  constructor(client) {
    this.client = client;
  }
  get baseUrl() {
    return getAppEndpointKey();
  }
  async uploadBlob(file, onProgress, expectedHash) {
    try {
      const fileArrayBuffer = await file.arrayBuffer();
      let url = `${this.baseUrl}/admin-api/blobs`;
      const params = new URLSearchParams();
      if (expectedHash) {
        params.append("hash", expectedHash);
      }
      if (params.toString()) {
        url += `?${params.toString()}`;
      }
      const response = await this.client.put(
        url,
        fileArrayBuffer,
        [{ "Content-Type": "application/octet-stream" }],
        false,
        onProgress
      );
      if (response.error) {
        return {
          data: null,
          error: response.error
        };
      }
      const transformedResponse = {
        blobId: response.data.blob_id,
        size: response.data.size
      };
      return {
        data: transformedResponse,
        error: null
      };
    } catch (error) {
      return {
        data: null,
        error: {
          code: 500,
          message: error instanceof Error ? error.message : "Failed to upload blob"
        }
      };
    }
  }
  async downloadBlob(blobId, contextId) {
    let url = `${this.baseUrl}/admin-api/blobs/${blobId}`;
    const params = new URLSearchParams();
    params.append("context_id", contextId);
    if (params.toString()) {
      url += `?${params.toString()}`;
    }
    const response = await this.client.get(url, void 0, false, {
      responseType: "arraybuffer"
    });
    if (response.error) {
      throw new Error(
        `Failed to download blob: ${response.error.code} ${response.error.message}`
      );
    }
    return new Blob([response.data]);
  }
  async getBlobMetadata(blobId) {
    try {
      const response = await this.client.head(
        `${this.baseUrl}/admin-api/blobs/${blobId}`
      );
      if (response.error) {
        return {
          data: null,
          error: response.error
        };
      }
      const headers = response.data.headers;
      const contentLength = headers["content-length"];
      const size = contentLength ? parseInt(contentLength, 10) : 0;
      const fileType = headers["x-blob-mime-type"] || headers["content-type"] || "unknown";
      const responseBlobId = headers["x-blob-id"];
      return {
        data: {
          blobId: responseBlobId || blobId,
          size,
          fileType
        },
        error: null
      };
    } catch (error) {
      console.error("getBlobMetadata failed:", error);
      return {
        data: null,
        error: {
          code: 500,
          message: error instanceof Error ? error.message : "An unexpected error occurred"
        }
      };
    }
  }
  async listBlobs() {
    try {
      const response = await this.client.get(
        `${this.baseUrl}/admin-api/blobs`
      );
      if (response.data) {
        const transformedData = {
          blobs: response.data.blobs.map((blob) => ({
            blobId: blob.blob_id,
            size: blob.size
          }))
        };
        return {
          data: transformedData,
          error: null
        };
      }
      return {
        data: null,
        error: response.error
      };
    } catch (error) {
      console.error("listBlobs failed:", error);
      return {
        data: null,
        error: {
          code: 500,
          message: error instanceof Error ? error.message : "An unexpected error occurred"
        }
      };
    }
  }
  async deleteBlob(blobId) {
    try {
      const response = await this.client.delete(
        `${this.baseUrl}/admin-api/blobs/${blobId}`
      );
      return response;
    } catch (error) {
      console.error("deleteBlob failed:", error);
      return {
        data: null,
        error: {
          code: 500,
          message: error instanceof Error ? error.message : "An unexpected error occurred"
        }
      };
    }
  }
};
var ApiClient = class {
  constructor(httpClient) {
    __publicField(this, "nodeApi");
    __publicField(this, "authApi");
    __publicField(this, "contractApi");
    __publicField(this, "adminApi");
    __publicField(this, "blobApi");
    __publicField(this, "jsonRpcClient");
    this.nodeApi = new NodeApiDataSource(httpClient);
    this.authApi = new AuthApiDataSource(httpClient);
    this.contractApi = new ContractApiDataSource(httpClient);
    this.adminApi = new AdminApiDataSource(httpClient);
    this.blobApi = new BlobApiDataSource(httpClient);
    this.jsonRpcClient = new JsonRpcClient(httpClient);
  }
  node() {
    return this.nodeApi;
  }
  auth() {
    return this.authApi;
  }
  contract() {
    return this.contractApi;
  }
  admin() {
    return this.adminApi;
  }
  blob() {
    return this.blobApi;
  }
  rpc() {
    return this.jsonRpcClient;
  }
};
var apiClient = new ApiClient(new AxiosHttpClient(axios_default));
var authClient = new AuthApiDataSource(new AxiosHttpClient(axios_default));
var contractClient = new ContractApiDataSource(new AxiosHttpClient(axios_default));
var adminClient = new AdminApiDataSource(new AxiosHttpClient(axios_default));
var blobClient = new BlobApiDataSource(new AxiosHttpClient(axios_default));
var rpcClient = new JsonRpcClient(new AxiosHttpClient(axios_default));
var SpinnerContainer = dt.div`
  display: flex;
  width: 100%;
  justify-content: center;
  align-items: center;
`;
var spin = mt`
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
`;
var Svg = dt.svg`
  width: 2.5rem; // equivalent to w-10
  height: 2.5rem; // equivalent to h-10
  color: #b67352;
  animation: ${spin} 1s linear infinite;
  fill: #ecb159;

  @media (prefers-color-scheme: dark) {
    color: #4b5563; // dark:text-gray-600
  }
`;
function Spinner() {
  return import_react4.default.createElement(SpinnerContainer, { role: "status" }, import_react4.default.createElement(
    Svg,
    {
      "aria-hidden": "true",
      viewBox: "0 0 100 101",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    },
    import_react4.default.createElement(
      "path",
      {
        d: "M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z",
        fill: "currentColor"
      }
    ),
    import_react4.default.createElement(
      "path",
      {
        d: "M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z",
        fill: "currentFill"
      }
    )
  ));
}
var ContextModalWrapper = dt.div`
  width: 600px;
  max-width: 100%;
  background: #1c1c1c;
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  overflow: hidden;
`;
var Tabs = dt.div`
  display: flex;
  border-bottom: 1px solid #ddd;
`;
var TabButton = dt.button`
  flex: 1;
  padding: 0.75rem;
  border: none;
  background: none;
  cursor: pointer;
  font-weight: 500;
  transition: all 0.3s;

  &.active {
    border-bottom: 2px solid #ff7a00;
  }
`;
var TabContent = dt.div`
  padding: 1.25rem;
`;
var FormGroup = dt.div`
  margin-bottom: 1rem;
`;
var FormInput = dt.input`
  width: 100%;
  padding: 0.625rem 1rem;
  border: 1px solid #ddd;
  border-radius: 0.375rem;
  font-size: 1rem;
  height: 46px;
`;
var ProtocolSelection = dt.div`
  padding: 0.625rem 1rem;
  border: 1px solid #ddd;
  border-radius: 0.375rem;
  font-size: 1rem;
  height: 46px;
`;
var ErrorMessage = dt.div`
  color: #ef4444;
  font-size: 0.875rem;
  margin-top: 0.5rem;
  padding: 0;
  margin: 0;
`;
var Button = dt.button`
  background: #ff7a00;
  color: white;
  border: none;
  padding: 0.625rem 1rem;
  cursor: pointer;
  font-size: 1rem;
  font-weight: 500;
  transition: background 0.3s;
  height: 46px;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 0.5rem;

  &.button-rounded {
    border-radius: 0.375rem;
  }

  &.button-tab:hover {
    color: #e56e00;
  }

  &:disabled {
    background-color: #6b7280;
    cursor: not-allowed;
  }

  &.button-size-md {
    width: 150px;
  }

  &.button-static {
    width: !important 177px;
  }
`;
var ScrollableList = dt.div`
  max-height: 200px;
  overflow-y: auto;
  border-radius: 4px;
  margin-top: 15px;
`;
var ListItem = dt.div`
  padding: 10px;
  border-bottom: 1px solid #eee;
  font-size: 0.875rem;
  display: flex;
  align-items: center;
  justify-content: space-between;

  &:last-child {
    border-bottom: none;
  }
`;
var Heading2 = dt.h2`
  margin-top: 0;
  margin-bottom: 10px;
  font-size: 18px;
`;
var Heading3 = dt.h3`
  margin-top: 20px;
  margin-bottom: 10px;
`;
var Paragraph = dt.p`
  margin-top: 0;
  color: #666;
  font-size: 14px;

  &.text-sm {
    font-size: 12px;
  }
`;
var FlexContainer = dt.div`
  display: flex;
  align-items: center;
  gap: 2rem;
  width: 100%;
`;
var BtnStatic = dt.div`
  width: 177px;
`;
var CursorPointer = dt.div`
  cursor: pointer;
`;
var ContextSelector = dt.div`
  display: flex;
  flex-direction: column;
  gap: 10px;
  margin-bottom: 10px;
  margin-top: 10px;
`;
var DropdownSelector = dt.select`
  padding: 0.625rem 1rem;
`;
var TextSm = dt.div`
  font-size: 12px;
`;
var IdentityContainer = dt.div`
  position: relative;
`;
var DeleteIcon = dt.div`
  position: absolute;
  right: -10px;
  top: -10px;
  cursor: pointer;
  font-size: 18px;

  &:hover {
    color: #ef4444;
  }
`;
var SuccessMessage = dt.div`
  padding-right: 10px;
  white-space: pre-wrap;
  display: flex;
  flex-direction: column;
  overflow-wrap: break-word;
  padding-bottom: 10px;
`;
var Payload = dt.div`
  font-size: 12px;
  color: #666;
`;
var JoinContext = () => {
  const [identityPrivateKey, setIdentityPrivateKey] = (0, import_react3.useState)("");
  const [joinPayload, setJoinPayload] = (0, import_react3.useState)("");
  const [joinError, setJoinError] = (0, import_react3.useState)("");
  const [isLoading, setIsLoading] = (0, import_react3.useState)(false);
  const [isSuccess, setIsSuccess] = (0, import_react3.useState)(false);
  const handleJoinSubmit = async (e) => {
    e.preventDefault();
    setIsLoading(true);
    setJoinError("");
    setIsSuccess(false);
    const response = await apiClient.node().joinContext(joinPayload);
    if (response.error) {
      setJoinError(response.error.message);
    } else {
      if (response.data.contextId && response.data.memberPublicKey) {
        setIsSuccess(true);
        setJoinError("");
      }
    }
    setIsLoading(false);
  };
  return import_react3.default.createElement("div", { className: "join-tab" }, import_react3.default.createElement(Heading2, null, "Join Existing Context"), import_react3.default.createElement(Paragraph, null, "To join context you need to have invitation payload."), import_react3.default.createElement("form", { onSubmit: handleJoinSubmit }, import_react3.default.createElement(FormGroup, null, import_react3.default.createElement(
    FormInput,
    {
      type: "text",
      value: identityPrivateKey,
      onChange: (e) => setIdentityPrivateKey(e.target.value),
      placeholder: "Enter your identity private key"
    }
  )), import_react3.default.createElement(FormGroup, null, import_react3.default.createElement(
    FormInput,
    {
      type: "text",
      value: joinPayload,
      onChange: (e) => setJoinPayload(e.target.value),
      placeholder: "Paste invitation payload"
    }
  )), joinError && import_react3.default.createElement(ErrorMessage, null, joinError), isSuccess && import_react3.default.createElement(SuccessMessage, null, "Successfully joined context"), import_react3.default.createElement(
    Button,
    {
      type: "submit",
      className: "button-rounded button-size-md",
      disabled: isLoading || !identityPrivateKey || !joinPayload
    },
    isLoading ? import_react3.default.createElement(Spinner, null) : "Join"
  )));
};
var InviteContext = () => {
  const applicationId = getApplicationId();
  const [contextId, setContextId2] = (0, import_react5.useState)("");
  const [invitatorKey, setInvitatorKey] = (0, import_react5.useState)("");
  const [inviteeKey, setInviteeKey] = (0, import_react5.useState)("");
  const [isLoading, setIsLoading] = (0, import_react5.useState)(false);
  const [error, setError] = (0, import_react5.useState)(null);
  const [invitation, setInvitation] = (0, import_react5.useState)(null);
  const [contexts, setContexts] = (0, import_react5.useState)([]);
  const [contextLoading, setContextLoading] = (0, import_react5.useState)(false);
  const fetchAvailableContexts = async () => {
    var _a;
    setContextLoading(true);
    const fetchContextsResponse = await apiClient.node().getContexts();
    const contexts2 = ((_a = fetchContextsResponse.data) == null ? void 0 : _a.contexts.filter(
      (context) => context.applicationId === applicationId
    )) ?? [];
    setContexts(contexts2);
    setContextId2(contexts2[0].id);
    setContextLoading(false);
  };
  (0, import_react5.useEffect)(() => {
    fetchAvailableContexts();
  }, [applicationId]);
  const handleInviteSubmit = async (e) => {
    e.preventDefault();
    setError(null);
    setInvitation(null);
    setIsLoading(true);
    const response = await apiClient.node().contextInvite(contextId, invitatorKey, inviteeKey);
    if (response.error) {
      setError(response.error.message);
    } else {
      if (response.data == null) {
        setError("Failed to invite to context.");
        setIsLoading(false);
        return;
      }
      setInvitation(response.data);
    }
    setIsLoading(false);
  };
  return import_react5.default.createElement("div", { className: "invite-tab" }, import_react5.default.createElement(Heading2, null, "Invite to Context"), import_react5.default.createElement(Paragraph, null, "Fill in the details to create an invitation"), import_react5.default.createElement("form", { onSubmit: handleInviteSubmit }, import_react5.default.createElement(FormGroup, null, import_react5.default.createElement(ContextSelector, null, import_react5.default.createElement("label", null, "Select Context:"), contextLoading ? import_react5.default.createElement("div", null, "Loading contexts...") : import_react5.default.createElement(
    DropdownSelector,
    {
      id: "context-select",
      value: contextId || "",
      onChange: (e) => {
        const selected = contexts == null ? void 0 : contexts.find(
          (context) => context.id === e.target.value
        );
        setContextId2(selected.id || "");
      }
    },
    contexts == null ? void 0 : contexts.map((context) => import_react5.default.createElement("option", { key: context.id, value: context.id }, context.id))
  ))), import_react5.default.createElement(FormGroup, null, import_react5.default.createElement(
    FormInput,
    {
      type: "text",
      value: invitatorKey,
      onChange: (e) => setInvitatorKey(e.target.value),
      placeholder: "Inviter Public Key"
    }
  )), import_react5.default.createElement(FormGroup, null, import_react5.default.createElement(
    FormInput,
    {
      type: "text",
      value: inviteeKey,
      onChange: (e) => setInviteeKey(e.target.value),
      placeholder: "Invitee Public Key"
    }
  )), error && import_react5.default.createElement(ErrorMessage, null, error), invitation && import_react5.default.createElement(SuccessMessage, null, import_react5.default.createElement(Paragraph, null, "Invitation created successfully"), import_react5.default.createElement("div", null, "invitation payload: ", import_react5.default.createElement("span", { className: "payload" }, invitation))), import_react5.default.createElement(
    Button,
    {
      type: "submit",
      className: "button-rounded button-size-md",
      disabled: isLoading || !invitatorKey || !inviteeKey
    },
    isLoading ? import_react5.default.createElement(Spinner, null) : "Create Invitation"
  )));
};
function DeleteIcon2({ onClick }) {
  return import_react7.default.createElement(
    "svg",
    {
      width: "18px",
      height: "18px",
      fill: "white",
      viewBox: "0 0 485 485",
      onClick,
      style: { cursor: "pointer" }
    },
    import_react7.default.createElement("g", null, import_react7.default.createElement("g", null, import_react7.default.createElement("rect", { x: "67.224", width: "350.535", height: "71.81" }), import_react7.default.createElement(
      "path",
      {
        d: "M417.776,92.829H67.237V485h350.537V92.829H417.776z M165.402,431.447h-28.362V146.383h28.362V431.447z M256.689,431.447\n        h-28.363V146.383h28.363V431.447z M347.97,431.447h-28.361V146.383h28.361V431.447z"
      }
    )))
  );
}
var CreateContext = () => {
  const applicationId = getApplicationId();
  const [contexts, setContexts] = (0, import_react6.useState)([]);
  const [selectedProtocol, setSelectedProtocol] = (0, import_react6.useState)("near");
  const [error, setError] = (0, import_react6.useState)(null);
  const [isLoading, setIsLoading] = (0, import_react6.useState)(false);
  const [isDeleting, setIsDeleting] = (0, import_react6.useState)(false);
  const fetchAvailableContexts = (0, import_react6.useCallback)(async () => {
    var _a;
    const fetchContextsResponse = await apiClient.node().getContexts();
    const contexts2 = ((_a = fetchContextsResponse.data) == null ? void 0 : _a.contexts.filter(
      (context) => context.applicationId === applicationId
    )) ?? [];
    setContexts(contexts2);
  }, [applicationId]);
  (0, import_react6.useEffect)(() => {
    fetchAvailableContexts();
  }, [applicationId, fetchAvailableContexts]);
  const handleCreateContext = async () => {
    setError(null);
    setIsLoading(true);
    const fetchData = await apiClient.node().createContext(applicationId, "", selectedProtocol);
    if (fetchData.error) {
      setError(fetchData.error.message);
    } else {
      await fetchAvailableContexts();
    }
    setIsLoading(false);
  };
  const handleDeleteContext = async (contextId) => {
    setIsDeleting(true);
    const fetchData = await apiClient.node().deleteContext(contextId);
    if (fetchData.error) {
      setError(fetchData.error.message);
    } else {
      await fetchAvailableContexts();
    }
    setIsDeleting(false);
  };
  return import_react6.default.createElement("div", { className: "create-tab" }, import_react6.default.createElement(Heading2, null, "Create Context"), import_react6.default.createElement(Paragraph, null, "Application ID: ", applicationId), import_react6.default.createElement("label", null, "Choose Protocol:"), import_react6.default.createElement(FlexContainer, null, import_react6.default.createElement("div", null, import_react6.default.createElement(
    DropdownSelector,
    {
      value: selectedProtocol,
      onChange: (e) => setSelectedProtocol(e.target.value)
    },
    import_react6.default.createElement("option", { value: "near" }, "NEAR"),
    import_react6.default.createElement("option", { value: "ethereum" }, "Ethereum"),
    import_react6.default.createElement("option", { value: "starknet" }, "Starknet"),
    import_react6.default.createElement("option", { value: "stellar" }, "Stellar"),
    import_react6.default.createElement("option", { value: "icp" }, "ICP")
  )), import_react6.default.createElement(
    Button,
    {
      disabled: isLoading,
      onClick: handleCreateContext,
      className: "button-rounded",
      style: { width: "177px" }
    },
    isLoading ? import_react6.default.createElement(Spinner, null) : "Create New Context"
  )), error && import_react6.default.createElement(ErrorMessage, null, error), import_react6.default.createElement(Heading3, null, "Existing Contexts"), import_react6.default.createElement(ScrollableList, null, contexts.map((context, index) => import_react6.default.createElement(ListItem, { key: index }, import_react6.default.createElement("span", null, index + 1, ". ", context.id), isDeleting ? import_react6.default.createElement(Spinner, null) : import_react6.default.createElement(DeleteIcon2, { onClick: () => handleDeleteContext(context.id) })))));
};
var NEW_IDENTITY_KEY = "new-identity";
var Identity = () => {
  const applicationId = getApplicationId();
  const [identities, setIdentities] = (0, import_react8.useState)([]);
  const [contexts, setContexts] = (0, import_react8.useState)([]);
  const [selectedContext, setSelectedContext] = (0, import_react8.useState)(null);
  const [contextLoading, setContextLoading] = (0, import_react8.useState)(true);
  const [identityLoading, setIdentityLoading] = (0, import_react8.useState)(true);
  const [error, setError] = (0, import_react8.useState)(null);
  const [isLoading, setIsLoading] = (0, import_react8.useState)(false);
  const [newIdentity, setNewIdentity] = (0, import_react8.useState)(null);
  const fetchAvailableContexts = async () => {
    var _a;
    setContextLoading(true);
    const fetchContextsResponse = await apiClient.node().getContexts();
    const contexts2 = ((_a = fetchContextsResponse.data) == null ? void 0 : _a.contexts.filter(
      (context) => context.applicationId === applicationId
    )) ?? [];
    setContexts(contexts2);
    setSelectedContext(contexts2[0]);
    setContextLoading(false);
  };
  (0, import_react8.useEffect)(() => {
    fetchAvailableContexts();
  }, [applicationId]);
  const fetchContextIdentities = async () => {
    if (!(selectedContext == null ? void 0 : selectedContext.id)) return;
    setIdentityLoading(true);
    const fetchContextIdentitiesResponse = await apiClient.node().fetchContextIdentities(selectedContext.id);
    if (fetchContextIdentitiesResponse.error) {
      setError(fetchContextIdentitiesResponse.error.message);
    } else {
      setIdentities(fetchContextIdentitiesResponse.data.identities);
    }
    setIdentityLoading(false);
  };
  (0, import_react8.useEffect)(() => {
    if (selectedContext) {
      fetchContextIdentities();
    }
  }, [selectedContext]);
  const handleCreateIdentity = async () => {
    setError(null);
    setIsLoading(true);
    const fetchData = await apiClient.node().createNewIdentity();
    if (fetchData.error) {
      setError(fetchData.error.message);
    } else {
      setNewIdentity(fetchData.data);
    }
    setIsLoading(false);
  };
  (0, import_react8.useEffect)(() => {
    if (newIdentity) {
      localStorage.setItem(NEW_IDENTITY_KEY, JSON.stringify(newIdentity));
    } else {
      const newIdentity2 = localStorage.getItem(NEW_IDENTITY_KEY);
      if (newIdentity2) {
        setNewIdentity(JSON.parse(newIdentity2));
      }
    }
  }, [newIdentity]);
  const deleteIdentity = () => {
    localStorage.removeItem(NEW_IDENTITY_KEY);
    setNewIdentity(null);
  };
  return import_react8.default.createElement("div", { className: "identity-tab" }, import_react8.default.createElement(FlexContainer, null, import_react8.default.createElement("div", null, import_react8.default.createElement(Heading2, null, "Identities"), import_react8.default.createElement(
    Button,
    {
      onClick: handleCreateIdentity,
      className: "button-rounded",
      disabled: isLoading
    },
    isLoading ? import_react8.default.createElement(Spinner, null) : "Create New Identity"
  )), newIdentity && import_react8.default.createElement(IdentityContainer, null, import_react8.default.createElement("label", null, "New Identity"), import_react8.default.createElement(Paragraph, { className: "text-sm" }, "Public Key: ", import_react8.default.createElement("br", null), newIdentity == null ? void 0 : newIdentity.publicKey), import_react8.default.createElement(Paragraph, { className: "text-sm" }, "Private Key: ", import_react8.default.createElement("br", null), newIdentity == null ? void 0 : newIdentity.privateKey), import_react8.default.createElement(DeleteIcon, { onClick: deleteIdentity }, "x"))), error && import_react8.default.createElement(ErrorMessage, null, error), import_react8.default.createElement(ContextSelector, null, import_react8.default.createElement("label", null, "Select Context:"), contextLoading ? import_react8.default.createElement("div", null, "Loading contexts...") : import_react8.default.createElement(
    DropdownSelector,
    {
      id: "context-select",
      className: "dropdown-selector",
      value: (selectedContext == null ? void 0 : selectedContext.id) || "",
      onChange: (e) => {
        const selected = contexts == null ? void 0 : contexts.find(
          (context) => context.id === e.target.value
        );
        setSelectedContext(selected || null);
      }
    },
    contexts == null ? void 0 : contexts.map((context) => import_react8.default.createElement("option", { key: context.id, value: context.id }, context.id))
  )), import_react8.default.createElement("label", null, "Available Identities:"), import_react8.default.createElement(ScrollableList, null, identityLoading ? import_react8.default.createElement("div", null, "Loading identities...") : identities.length > 0 && identities.map((identity, index) => import_react8.default.createElement(ListItem, { key: index }, import_react8.default.createElement("span", null, index + 1, ". ", identity)))));
};
var contextActions = [
  {
    label: "Join Context",
    id: "join"
  },
  {
    label: "Invite to Context",
    id: "invite"
  },
  {
    label: "Create Context",
    id: "create"
  },
  {
    label: "Identity",
    id: "identity"
  }
];
var ContextModal = () => {
  const [activeTab, setActiveTab] = (0, import_react2.useState)("join");
  return import_react2.default.createElement(ContextModalWrapper, null, import_react2.default.createElement(Tabs, null, contextActions.map((item, i2) => import_react2.default.createElement(
    TabButton,
    {
      key: i2,
      onClick: () => setActiveTab(item.id),
      className: activeTab === item.id ? "active" : ""
    },
    item.label
  ))), import_react2.default.createElement(TabContent, null, activeTab === "join" && import_react2.default.createElement(JoinContext, null), activeTab === "invite" && import_react2.default.createElement(InviteContext, null), activeTab === "create" && import_react2.default.createElement(CreateContext, null), activeTab === "identity" && import_react2.default.createElement(Identity, null)));
};
var CalimeroLogo = (props) => import_react11.default.createElement(
  "svg",
  {
    version: "1.0",
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 400 400",
    preserveAspectRatio: "xMidYMid meet",
    ...props
  },
  import_react11.default.createElement(
    "g",
    {
      transform: "translate(0.000000,400.000000) scale(0.100000,-0.100000)",
      fill: "currentColor",
      stroke: "none"
    },
    import_react11.default.createElement("path", { d: "M1795 3589 c-185 -9 -341 -31 -505 -71 -69 -16 -141 -34 -160 -38 -117 -26 -408 -148 -533 -223 -64 -38 -101 -75 -137 -133 -51 -85 -61 -155 -44 -332 23 -250 57 -411 145 -682 35 -110 48 -144 90 -236 11 -23 19 -44 19 -48 0 -8 106 -220 136 -271 13 -22 27 -47 31 -55 15 -33 186 -285 226 -332 114 -136 189 -219 256 -283 41 -38 82 -77 92 -87 81 -77 311 -243 449 -324 105 -62 164 -79 223 -63 101 27 147 83 147 180 0 83 -31 134 -105 175 -70 38 -107 61 -243 153 -19 13 -59 43 -89 67 -30 25 -60 49 -66 54 -45 36 -139 124 -186 174 -31 33 -63 67 -72 76 -73 77 -252 325 -282 390 -4 8 -16 29 -27 45 -18 28 -102 195 -137 275 -9 19 -20 43 -25 54 -5 10 -16 37 -23 60 -7 22 -24 73 -38 111 -76 221 -144 552 -135 663 3 41 6 45 58 72 30 15 71 35 90 43 19 8 55 24 78 36 24 11 50 21 57 21 7 0 26 7 41 15 16 8 36 15 46 15 9 0 40 9 70 19 70 25 207 56 343 78 161 26 681 26 845 0 105 -17 228 -43 321 -67 103 -28 188 5 242 92 23 37 23 139 0 176 -22 36 -84 91 -104 92 -8 0 -35 6 -60 14 -71 22 -226 54 -344 70 -96 14 -471 39 -522 35 -10 -1 -85 -5 -168 -10z" }),
    import_react11.default.createElement("path", { d: "M3345 3268 c-56 -15 -89 -41 -119 -92 -25 -44 -26 -48 -26 -233 0 -250 -25 -426 -90 -643 -34 -112 -59 -188 -76 -227 -9 -21 -24 -54 -32 -73 -35 -82 -123 -249 -160 -304 -18 -26 -32 -49 -32 -51 0 -21 -170 -235 -260 -328 l-75 -78 -40 21 c-62 31 -172 106 -207 139 -9 9 -30 27 -47 40 -44 33 -183 172 -267 266 -66 75 -240 294 -274 345 -8 12 -25 35 -37 50 -13 15 -23 31 -23 34 0 3 -16 28 -35 55 -19 26 -35 52 -35 57 0 18 -66 81 -105 99 -124 59 -275 -35 -275 -171 0 -55 15 -88 91 -202 27 -41 49 -78 49 -83 0 -5 4 -9 8 -9 5 0 24 -24 42 -52 19 -29 37 -55 40 -58 3 -3 31 -39 62 -80 49 -67 123 -157 213 -259 92 -104 290 -291 388 -366 107 -81 274 -174 359 -200 106 -31 225 -8 320 63 53 40 183 171 248 251 19 23 40 48 45 54 18 20 137 189 160 226 116 188 205 366 268 536 55 150 54 147 101 330 74 286 94 776 37 869 -37 60 -138 95 -216 74z" }),
    import_react11.default.createElement("path", { d: "M1830 3015 c-230 -18 -478 -67 -635 -125 -27 -10 -61 -22 -75 -26 -39 -11 -71 -35 -101 -78 -25 -34 -29 -48 -29 -106 0 -59 4 -72 30 -108 16 -23 48 -51 69 -62 47 -23 125 -26 173 -6 86 35 214 70 403 107 109 21 146 23 405 23 303 0 281 3 508 -56 48 -12 48 -13 27 -106 -34 -145 -98 -307 -159 -395 -14 -21 -26 -41 -26 -45 0 -4 -50 -74 -110 -157 l-109 -150 -1 -59 c0 -79 32 -136 94 -166 101 -49 187 -32 258 51 50 58 170 225 212 296 158 260 246 519 246 722 0 98 -17 153 -67 220 -64 86 -142 130 -298 169 -139 36 -186 43 -355 58 -193 16 -251 16 -460 -1z" })
  )
);
var CalimeroLogo_default = CalimeroLogo;
var fadeIn = mt`
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
`;
var slideIn = mt`
  from {
    transform: translateY(-20px);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
`;
var OverlayBackdrop = dt.div`
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.7);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
  animation: ${fadeIn} 0.3s ease-out;
`;
var OverlayContent = dt.div`
  position: relative;
  background: var(--background-color);
  padding: 40px;
  border-radius: 12px;
  text-align: center;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
  width: 90%;
  max-width: 500px;
  animation: ${slideIn} 0.4s ease-out;
  display: flex;
  flex-direction: column;
  align-items: center;
`;
var OverlayHeader = dt.div`
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 15px;
  margin-bottom: 10px;

  h1 {
    margin: 0;
    font-size: 24px;
    color: var(--text-color);
  }
`;
var StyledCalimeroLogo = dt(CalimeroLogo_default)`
  width: 40px;
  height: 40px;
  margin-bottom: 0;
  color: var(--text-color);
`;
var InfoText = dt.p`
  margin-bottom: 20px;
  color: var(--text-secondary-color);
`;
var LocalNodeInfo = dt.p`
  color: var(--text-secondary-color);
  margin: 12px 0;
`;
var ErrorMessage2 = dt.p`
  color: #ff4d4d;
  margin-bottom: 20px;
`;
var RadioGroup = dt.div`
  display: flex;
  justify-content: center;
  gap: 20px;
  margin-bottom: 20px;

  label {
    display: flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
    color: var(--text-color);
  }
`;
var InputContainer = dt.div`
  min-height: 60px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  gap: 15px;
  margin-bottom: 20px;
  width: 100%;

  input {
    padding: 12px;
    width: 100%;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    box-sizing: border-box;
    background-color: var(--background-input);
    color: var(--text-color-input);
    transition:
      border-color 0.3s,
      box-shadow 0.3s;

    &:focus {
      border-color: var(--success-color);
      box-shadow: 0 0 0 2px rgba(168, 230, 64, 0.2);
      outline: none;
    }
  }
`;
var SpinnerContainer2 = dt.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 200px;
`;
var ButtonGroup = dt.div`
  display: flex;
  gap: 10px;
  justify-content: center;
`;
var StyledButton = dt.button`
  padding: 12px 24px;
  border: 1px solid var(--primary-color);
  border-radius: 8px;
  cursor: pointer;
  font-size: 16px;
  transition:
    background-color 0.3s,
    color 0.3s;

  &.connect-button {
    background-color: var(--success-color);
    color: var(--background-color);
    border-color: var(--success-color);

    &:hover {
      background-color: var(--success-hover-color);
      border-color: var(--success-hover-color);
    }

    &:disabled {
      background-color: var(--disabled-color);
      border-color: var(--disabled-color);
      cursor: not-allowed;
    }
  }

  &.help-button {
    background-color: var(--background-color);
    color: var(--text-color);
    border-color: var(--border-color);

    &:hover {
      background-color: var(--primary-color);
      color: var(--background-color);
      border-color: var(--primary-color);
    }
  }
`;
var CloseIconButton = dt.button`
  position: absolute;
  top: 15px;
  right: 15px;
  background: none;
  border: none;
  font-size: 24px;
  color: var(--text-secondary-color);
  cursor: pointer;
  line-height: 1;

  &:hover {
    color: var(--text-color);
  }
`;
var URL_REGEX = /^(https?:\/\/)?((([a-z\d]([a-z\d-]*[a-z\d])*)\.)+[a-z]{2,}|localhost|((\d{1,3}\.){3}\d{1,3}))(:\d+)?(\/[-a-z\d%_.~+]*)*(\?[;&a-z\d%_.~+=-]*)?(#[-a-z\d_]*)?$/i;
var CalimeroLoginModal = ({
  onConnect,
  onClose
}) => {
  const [nodeType, setNodeType] = (0, import_react10.useState)("local");
  const [nodeUrl, setNodeUrl] = (0, import_react10.useState)("");
  const [isValid, setIsValid] = (0, import_react10.useState)(true);
  const [loading, setLoading] = (0, import_react10.useState)(false);
  const [error, setError] = (0, import_react10.useState)(null);
  (0, import_react10.useEffect)(() => {
    if (nodeType === "remote") {
      setIsValid(URL_REGEX.test(nodeUrl));
    } else {
      setIsValid(true);
    }
  }, [nodeUrl, nodeType]);
  const handleConnect = (0, import_react10.useCallback)(async () => {
    if (isValid) {
      setLoading(true);
      setError(null);
      const finalUrl = nodeType === "local" ? `http://localhost` : nodeUrl;
      try {
        const response = await fetch(`${finalUrl}/admin-api/is-authed`);
        if (response.ok || response.status === 401) {
          setLoading(false);
          onConnect(finalUrl);
        } else {
          throw new Error(
            `Network response was not ok: ${response.statusText}`
          );
        }
      } catch (err) {
        console.error("Connection failed:", err);
        setError("Failed to connect. Please check the URL and try again.");
        setLoading(false);
      }
    }
  }, [isValid, nodeType, nodeUrl, onConnect]);
  return import_react10.default.createElement(OverlayBackdrop, { onClick: onClose }, import_react10.default.createElement(OverlayContent, { onClick: (e) => e.stopPropagation() }, import_react10.default.createElement(CloseIconButton, { onClick: onClose }, ""), import_react10.default.createElement(OverlayHeader, null, import_react10.default.createElement(StyledCalimeroLogo, null), import_react10.default.createElement("h1", null, "Calimero Connect")), loading ? import_react10.default.createElement(SpinnerContainer2, null, import_react10.default.createElement("p", null, "Connecting to node..."), import_react10.default.createElement(Spinner, null)) : import_react10.default.createElement(import_react10.default.Fragment, null, import_react10.default.createElement(InfoText, null, "Select your Calimero node type to continue."), error && import_react10.default.createElement(ErrorMessage2, null, error), import_react10.default.createElement(RadioGroup, null, import_react10.default.createElement("label", null, import_react10.default.createElement(
    "input",
    {
      type: "radio",
      value: "local",
      checked: nodeType === "local",
      onChange: () => setNodeType("local")
    }
  ), "Local"), import_react10.default.createElement("label", null, import_react10.default.createElement(
    "input",
    {
      type: "radio",
      value: "remote",
      checked: nodeType === "remote",
      onChange: () => setNodeType("remote")
    }
  ), "Remote")), import_react10.default.createElement(InputContainer, null, nodeType === "remote" ? import_react10.default.createElement(
    "input",
    {
      type: "text",
      value: nodeUrl,
      onChange: (e) => setNodeUrl(e.target.value),
      placeholder: "https://your-node-url.calimero.network"
    }
  ) : import_react10.default.createElement(LocalNodeInfo, null, "Using default local node: http://localhost")), import_react10.default.createElement(ButtonGroup, null, import_react10.default.createElement(
    StyledButton,
    {
      onClick: handleConnect,
      disabled: !isValid || loading,
      className: "connect-button"
    },
    "Connect"
  )))));
};
var CalimeroLoginModal_default = CalimeroLoginModal;
var slideInUp = mt`
  from {
    transform: translateY(100px);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
`;
var fadeOut = mt`
  from {
    opacity: 1;
  }
  to {
    opacity: 0;
  }
`;
var ToastContainer = dt.div`
  position: fixed;
  bottom: 20px;
  right: 20px;
  background-color: ${({ toastType }) => toastType === "success" ? "var(--success-color)" : "#ff4d4d"};
  color: ${({ toastType }) => toastType === "success" ? "var(--background-color)" : "white"};
  padding: 15px 20px;
  border-radius: 8px;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
  display: flex;
  align-items: center;
  justify-content: space-between;
  z-index: 2000;
  animation:
    ${slideInUp} 0.5s ease-out,
    ${fadeOut} 0.5s ease-out 4.5s forwards;
`;
var ToastMessage = dt.div`
  margin-right: 15px;
`;
var ToastCloseButton = dt.button`
  background: none;
  border: none;
  color: inherit;
  font-size: 20px;
  cursor: pointer;
`;
var Toast = ({ message, onClose, type = "error" }) => {
  return import_react12.default.createElement(ToastContainer, { toastType: type }, import_react12.default.createElement(ToastMessage, null, message), import_react12.default.createElement(ToastCloseButton, { onClick: onClose }, ""));
};
var Toast_default = Toast;
var RECONNECT_DELAY = 5e3;
var ExperimentalWebSocket = class {
  constructor(baseUrl) {
    __publicField(this, "ws", null);
    __publicField(this, "url");
    __publicField(this, "reconnectTimeout", null);
    __publicField(this, "callbacks", /* @__PURE__ */ new Map());
    __publicField(this, "requestId", 0);
    this.url = this.buildUrl(baseUrl);
    this.connect();
  }
  buildUrl(baseUrl) {
    let wsUrl = "";
    if (baseUrl.startsWith("https://")) {
      wsUrl = baseUrl.replace("https://", "wss://");
    } else if (baseUrl.startsWith("http://")) {
      wsUrl = baseUrl.replace("http://", "ws://");
    } else {
      wsUrl = `wss://${baseUrl}`;
    }
    return `${wsUrl}/ws`;
  }
  connect() {
    const accessToken = getAccessToken();
    if (!accessToken) {
      console.warn("No access token found, WebSocket connection aborted.");
      return;
    }
    const fullUrl = `${this.url}?token=${encodeURIComponent(accessToken)}`;
    this.ws = new WebSocket(fullUrl);
    this.ws.onopen = () => {
      this.clearReconnect();
    };
    this.ws.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        if (data.result && data.result.contextId) {
          const nodeEvent = data.result;
          this.decodeEventData(nodeEvent);
          const callback = this.callbacks.get(nodeEvent.contextId);
          if (callback) {
            callback(nodeEvent);
          }
        }
      } catch (e) {
        console.error("Error parsing WebSocket message:", e);
      }
    };
    this.ws.onclose = () => {
      console.log("Experimental WebSocket disconnected.");
      this.scheduleReconnect();
    };
    this.ws.onerror = (error) => {
      var _a;
      console.error("Experimental WebSocket error:", error);
      (_a = this.ws) == null ? void 0 : _a.close();
    };
  }
  decodeEventData(nodeEvent) {
    if (nodeEvent.type === "ExecutionEvent" && nodeEvent.data && Array.isArray(nodeEvent.data.events)) {
      nodeEvent.data.events.forEach((executionEvent) => {
        if (Array.isArray(executionEvent.data) && executionEvent.data.every((item) => typeof item === "number")) {
          try {
            const decodedString = new TextDecoder().decode(
              new Uint8Array(executionEvent.data)
            );
            try {
              executionEvent.data = JSON.parse(decodedString);
            } catch (jsonError) {
              executionEvent.data = decodedString;
            }
          } catch (decodeError) {
            console.error(
              "Failed to decode event data byte array",
              decodeError
            );
          }
        }
      });
    }
  }
  scheduleReconnect() {
    this.clearReconnect();
    this.reconnectTimeout = setTimeout(() => {
      console.log("Attempting to reconnect WebSocket...");
      this.connect();
    }, RECONNECT_DELAY);
  }
  clearReconnect() {
    if (this.reconnectTimeout) {
      clearTimeout(this.reconnectTimeout);
    }
  }
  subscribe(contextIds, callback) {
    var _a;
    contextIds.forEach((contextId) => {
      this.callbacks.set(contextId, callback);
    });
    if (((_a = this.ws) == null ? void 0 : _a.readyState) === WebSocket.OPEN) {
      this.ws.send(
        JSON.stringify({
          id: this.requestId++,
          method: "subscribe",
          params: { contextIds }
        })
      );
    }
  }
  unsubscribe(contextIds) {
    var _a;
    contextIds.forEach((contextId) => {
      this.callbacks.delete(contextId);
    });
    if (((_a = this.ws) == null ? void 0 : _a.readyState) === WebSocket.OPEN) {
      this.ws.send(
        JSON.stringify({
          id: this.requestId++,
          method: "unsubscribe",
          params: { contextIds }
        })
      );
    }
  }
  close() {
    var _a;
    this.clearReconnect();
    (_a = this.ws) == null ? void 0 : _a.close();
  }
};
var Protocol = ((Protocol2) => {
  Protocol2["ETHEREUM"] = "ethereum";
  Protocol2["ICP"] = "icp";
  Protocol2["NEAR"] = "near";
  Protocol2["STARKNET"] = "starknet";
  Protocol2["STELLAR"] = "stellar";
  return Protocol2;
})(Protocol || {});
var AppMode = ((AppMode2) => {
  AppMode2["MultiContext"] = "multi-context";
  return AppMode2;
})(AppMode || {});
var CalimeroApplication = class {
  constructor(apiClient2, clientApplicationId) {
    __publicField(this, "apiClient");
    __publicField(this, "clientApplicationId");
    __publicField(this, "websocket");
    this.apiClient = apiClient2;
    this.clientApplicationId = clientApplicationId;
    const baseUrl = getAppEndpointKey();
    this.websocket = new ExperimentalWebSocket(baseUrl);
  }
  async fetchContexts() {
    const contextsResponse = await this.apiClient.node().getContexts();
    if (contextsResponse.error) {
      throw new Error(
        `Error fetching contexts: ${contextsResponse.error.message}`
      );
    }
    const filteredApiContexts = contextsResponse.data ? contextsResponse.data.contexts.filter(
      (apiContext) => apiContext.applicationId === this.clientApplicationId
    ) : [];
    const contexts = await Promise.all(
      filteredApiContexts.map(async (apiContext) => {
        const identitiesResponse = await this.apiClient.node().fetchContextIdentities(apiContext.id);
        if (identitiesResponse.error || !identitiesResponse.data) {
          throw new Error(
            `Could not fetch identity for context ${apiContext.id}, or no identities found.`
          );
        }
        return {
          contextId: apiContext.id,
          executorId: identitiesResponse.data.identities[0],
          // Assuming the first identity is the executor
          applicationId: apiContext.applicationId
        };
      })
    );
    return contexts;
  }
  async execute(context, method, params = {}) {
    var _a, _b, _c, _d;
    const response = await this.apiClient.rpc().execute({
      contextId: context.contextId,
      method,
      argsJson: params || {},
      executorPublicKey: context.executorId
    });
    if (response.error) {
      return {
        success: false,
        error: (_c = (_b = (_a = response.error.error) == null ? void 0 : _a.cause) == null ? void 0 : _b.info) == null ? void 0 : _c.message
      };
    }
    return { success: true, result: (_d = response.result) == null ? void 0 : _d.output };
  }
  async createContext(protocol = "near", initParams) {
    const response = await this.apiClient.node().createContext(
      this.clientApplicationId,
      JSON.stringify(initParams || {}),
      protocol
    );
    if (response.error) {
      throw new Error(`Error creating context: ${response.error.message}`);
    }
    return {
      contextId: response.data.contextId,
      executorId: response.data.memberPublicKey,
      applicationId: this.clientApplicationId
    };
  }
  async deleteContext(context) {
    const response = await this.apiClient.node().deleteContext(context.contextId);
    if (response.error) {
      throw new Error(`Error deleting context: ${response.error.message}`);
    }
  }
  subscribeToEvents(contextIds, callback) {
    this.websocket.subscribe(contextIds, callback);
  }
  unsubscribeFromEvents(contextIds) {
    this.websocket.unsubscribe(contextIds);
  }
  close() {
    this.websocket.close();
  }
};
var GlobalStyle = ft`
  :root {
    --background-color: #000000;
    --background-input: #ffffff;
    --text-color: #ffffff;
    --text-color-input: #000000;
    --text-secondary-color: #a0a0a0;
    --primary-color: #000000;
    --accent-color: #f97316;
    --accent-hover-color: #e85d04;
    --disabled-color: #444444;
    --success-color: #a8e640;
    --success-hover-color: #97cf2c;
    --border-color: #a0a0a0;
  }
`;
var CalimeroContext = (0, import_react9.createContext)({
  app: null,
  isAuthenticated: false,
  login: () => {
  },
  logout: () => {
  },
  appUrl: null,
  isOnline: true
});
var useCalimero = () => (0, import_react9.useContext)(CalimeroContext);
var getPermissionsForMode = (mode) => {
  switch (mode) {
    case "multi-context":
      return ["context:execute", "application"];
    default:
      throw new Error(`Unsupported application mode: ${mode}`);
  }
};
var CalimeroProvider = ({
  children,
  clientApplicationId,
  mode,
  applicationPath
}) => {
  const [isAuthenticated, setIsAuthenticated] = (0, import_react9.useState)(false);
  const [isLoginOpen, setIsLoginOpen] = (0, import_react9.useState)(false);
  const [isLoading, setIsLoading] = (0, import_react9.useState)(true);
  const [toast, setToast] = (0, import_react9.useState)(null);
  const [isOnline, setIsOnline] = (0, import_react9.useState)(true);
  const [appUrl, setAppUrl] = (0, import_react9.useState)(getAppEndpointKey());
  const performLogin = (0, import_react9.useCallback)(
    (url) => {
      const permissions = getPermissionsForMode(mode);
      apiClient.auth().login({
        url,
        callbackUrl: window.location.href,
        applicationId: clientApplicationId,
        permissions,
        applicationPath
      });
    },
    [clientApplicationId, mode, applicationPath]
  );
  const logout = (0, import_react9.useCallback)(() => {
    clientLogout();
    setIsAuthenticated(false);
    setIsOnline(true);
    setAppUrl(null);
  }, []);
  (0, import_react9.useEffect)(() => {
    const fragment = window.location.hash.substring(1);
    const fragmentParams = new URLSearchParams(fragment);
    const encodedAccessToken = fragmentParams.get("access_token");
    const encodedRefreshToken = fragmentParams.get("refresh_token");
    if (encodedAccessToken && encodedRefreshToken) {
      window.history.replaceState({}, document.title, window.location.pathname);
      const accessToken = decodeURIComponent(encodedAccessToken);
      const refreshToken = decodeURIComponent(encodedRefreshToken);
      setAccessToken(accessToken);
      setRefreshToken(refreshToken);
      const newAppUrl = getAppEndpointKey();
      setAppUrl(newAppUrl);
      if (!newAppUrl) return;
      const verify = async () => {
        const response = await apiClient.node().checkAuth();
        if (!response.error) {
          setIsAuthenticated(true);
        }
      };
      verify();
    }
  }, []);
  (0, import_react9.useEffect)(() => {
    const checkSession = async () => {
      const savedUrl = getAppEndpointKey();
      const savedToken = getAccessToken();
      if (savedUrl && savedToken) {
        try {
          const response = await apiClient.node().checkAuth();
          if (!response.error) {
            setIsAuthenticated(true);
            setIsOnline(true);
          } else if (response.error.code === 401) {
            performLogin(savedUrl);
          }
        } catch (error) {
          logout();
        }
      }
      setIsLoading(false);
    };
    checkSession();
  }, [performLogin, logout]);
  (0, import_react9.useEffect)(() => {
    const intervalId = setInterval(async () => {
      if (!isAuthenticated) return;
      const savedUrl = getAppEndpointKey();
      if (savedUrl) {
        try {
          const response = await apiClient.node().checkAuth();
          if (response.error && response.error.code === 401) {
            logout();
            setToast({
              message: "Session expired. Please connect again.",
              type: "error"
            });
            return;
          }
          if (response.error && isOnline) {
            setToast({
              message: "Connection lost. Trying to reconnect...",
              type: "error"
            });
            setIsOnline(false);
          } else if (!response.error && !isOnline) {
            setToast({ message: "Connection restored.", type: "success" });
            setIsOnline(true);
            setTimeout(() => setToast(null), 5e3);
          }
        } catch (error) {
          if (isOnline) {
            setToast({
              message: "Connection lost. Trying to reconnect...",
              type: "error"
            });
            setIsOnline(false);
          }
        }
      }
    }, 5e3);
    return () => clearInterval(intervalId);
  }, [isAuthenticated, isOnline, logout]);
  const handleConnect = (url) => {
    setAppEndpointKey(url);
    setAppUrl(url);
    performLogin(url);
  };
  const login = () => setIsLoginOpen(true);
  const app = (0, import_react9.useMemo)(
    () => isAuthenticated ? new CalimeroApplication(apiClient, clientApplicationId) : null,
    [isAuthenticated, clientApplicationId]
  );
  (0, import_react9.useEffect)(() => {
    return () => {
      app == null ? void 0 : app.close();
    };
  }, [app]);
  return import_react9.default.createElement(
    CalimeroContext.Provider,
    {
      value: { app, isAuthenticated, login, logout, appUrl, isOnline }
    },
    isLoading ? import_react9.default.createElement("div", null, "Loading...") : import_react9.default.createElement(import_react9.default.Fragment, null, import_react9.default.createElement(GlobalStyle, null), children, isLoginOpen && import_react9.default.createElement(
      CalimeroLoginModal_default,
      {
        onConnect: handleConnect,
        onClose: () => setIsLoginOpen(false)
      }
    ), toast && import_react9.default.createElement(
      Toast_default,
      {
        message: toast.message,
        type: toast.type,
        onClose: () => setToast(null)
      }
    ))
  );
};
var StyledButton2 = dt.button`
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px 20px;
  background-color: var(--background-color);
  border: 1px solid var(--accent-color);
  border-radius: 8px;
  cursor: pointer;
  font-size: 16px;
  color: var(--text-color);
  transition: background-color 0.3s;
  width: 180px;
  justify-content: center;
  box-sizing: border-box;

  .calimero-logo {
    width: 24px;
    height: 24px;
    color: var(--text-color);
  }

  &:hover:not(.connected) {
    background-color: var(--accent-hover-color);
    border-color: var(--accent-hover-color);
  }

  &.connected {
    background-color: var(--success-color);
    color: var(--background-color);
    border-color: var(--success-color);

    .calimero-logo {
      color: var(--background-color);
    }
  }

  &.reconnecting {
    background-color: var(--accent-color);
    color: var(--text-color);
    border-color: var(--accent-color);
    cursor: not-allowed;
  }
`;
var ConnectedContainer = dt.div`
  position: relative;
  display: inline-block;
`;
var DropdownMenu = dt.div`
  position: absolute;
  top: 100%;
  left: 0;
  background-color: var(--background-color);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  margin-top: 0;
  padding: 0;
  z-index: 1001;
  width: 100%;
  overflow: hidden;
  box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
`;
var DropdownItem = dt.a`
  display: block;
  width: 100%;
  padding: 10px 20px;
  background: none;
  border: none;
  color: var(--text-color);
  text-align: left;
  cursor: pointer;
  font-size: 16px;
  text-decoration: none;

  &:hover,
  &:active {
    background-color: var(--success-color);
    color: var(--background-color);
  }
`;
var DropdownInfoItem = dt.div`
  padding: 10px 20px;
  color: var(--text-secondary-color);
  font-size: 14px;
  border-bottom: 1px solid var(--border-color);
  cursor: default;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 150px;
`;
var CalimeroConnectButton = () => {
  const { isAuthenticated, login, logout, appUrl, isOnline } = useCalimero();
  const [isDropdownOpen, setIsDropdownOpen] = (0, import_react13.useState)(false);
  const dropdownRef = (0, import_react13.useRef)(null);
  (0, import_react13.useEffect)(() => {
    const handleClickOutside = (event) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target)) {
        setIsDropdownOpen(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [dropdownRef]);
  const dashboardUrl = (0, import_react13.useMemo)(() => {
    if (!isAuthenticated || !appUrl) return "#";
    const baseUrl = appUrl.endsWith("/") ? appUrl : `${appUrl}/`;
    return `${baseUrl}admin-dashboard/`;
  }, [isAuthenticated, appUrl]);
  if (isAuthenticated) {
    if (!isOnline) {
      return import_react13.default.createElement(StyledButton2, { className: "reconnecting", disabled: true }, import_react13.default.createElement(CalimeroLogo_default, { className: "calimero-logo" }), "Reconnecting...");
    }
    return import_react13.default.createElement(ConnectedContainer, { ref: dropdownRef }, import_react13.default.createElement(
      StyledButton2,
      {
        className: "connected",
        onClick: () => setIsDropdownOpen((prev2) => !prev2)
      },
      import_react13.default.createElement(CalimeroLogo_default, { className: "calimero-logo" }),
      "Connected"
    ), isDropdownOpen && import_react13.default.createElement(DropdownMenu, null, import_react13.default.createElement(DropdownInfoItem, { title: appUrl || "" }, appUrl), import_react13.default.createElement(
      DropdownItem,
      {
        href: dashboardUrl,
        target: "_blank",
        rel: "noopener noreferrer"
      },
      "Dashboard"
    ), import_react13.default.createElement(DropdownItem, { as: "button", onClick: logout }, "Log out")));
  }
  return import_react13.default.createElement(StyledButton2, { onClick: login }, import_react13.default.createElement(CalimeroLogo_default, { className: "calimero-logo" }), "Connect");
};
var CalimeroConnectButton_default = CalimeroConnectButton;
var LoginContainer = dt.div`
  display: flex;
  flex-direction: column;
  align-items: center;
`;
var LoginHeader = dt.div`
  margin-top: 1.5rem;
  display: grid;
  color: white;
  font-size: 1.25rem;
  font-weight: 500;
  text-align: center;
`;
var LoginHeaderSpan = dt.span`
  margin-bottom: 0.5rem;
  color: #fff;
`;
var LoginButton = dt.button`
  background-color: #ff7a00;
  color: white;
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 0.5rem;
  height: 46px;
  cursor: pointer;
  font-size: 1rem;
  font-weight: 500;
  border-radius: 0.375rem;
  border: none;
  outline: none;
  padding-left: 0.5rem;
  padding-right: 0.5rem;

  &:hover {
    background-color: #ff7a00;
  }

  &:disabled {
    background-color: #6b7280;
  }
`;
var ErrorMessage3 = dt.div`
  color: #ef4444;
  font-size: 1.25rem;
  text-align: center;
  margin-bottom: 2rem;
`;
var ContextModal2 = dt.div`
  display: flex;
  position: relative;
  flex-direction: column;
  justify-content: center;
  border-radius: 0.375rem;
  align-items: center;
  background-color: #17191b;
`;
var ContextTitle = dt.div`
  font-size: 1.25rem;
  font-weight: 700;
  line-height: 2rem;
  color: #fff;
  text-align: center;
`;
var ContextWrapper = dt.div`
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  margin-top: 1.25rem;
  color: #fff;
  width: 100%;
`;
var ContextSubtitle = dt.div`
  color: ${(props) => props.color || "#6b7280"};
  font-weight: 500;
  font-size: 0.875rem;
  word-break: break-all;
  display: flex;
  gap: 0.5rem;
  ${({ separator }) => separator && `
    border-bottom: 1px solid #23262d;
  `}
`;
var AppIdContainer = dt.div`
  color: #fff;
  display: flex;
  align-items: center;
  gap: 0.5rem;
`;
var ContextListContainer = dt.div`
  display: flex;
  flex-direction: column;
  max-height: 200px;
  overflow-y: auto;
`;
var NoContextWrapper = dt.div`
  margin-top: 1rem;
  display: flex;
  flex-direction: column;
  gap: 1rem;
`;
var NoContextMessage = dt.div`
  text-align: center;
  font-size: 0.875rem;
  color: #6b7280;
`;
var ModalOverlay = dt.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.7);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
`;
var ModalContent = dt.div`
  background-color: #17191b;
  padding: 2rem;
  border-radius: 8px;
  width: 90%;
  max-width: 500px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
`;
var Button2 = dt.button`
  color: white;
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 0.5rem;
  height: 46px;
  font-size: 1rem;
  font-weight: 500;
  border-radius: 0.375rem;
  border: none;
  outline: none;
  padding: 0.5rem;
  cursor: pointer;
  background-color: #6b7280;
  transition: background-color 0.2s ease;

  &:disabled {
    background-color: #6b7280;
    cursor: not-allowed;
  }
`;
var SetupModalOverlay = dt.div`
  display: flex;
  justify-content: center;
  background-color: #111111;
`;
var SetupModalContainer = dt.div`
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
`;
var SetupModalContent = dt.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  background-color: #1c1c1c;
  padding: 1rem;
  border-radius: 0.5rem;
  color: white;
`;
var SetupFormContainer = dt.div`
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  gap: 2rem;
  padding: 0 2rem;
`;
var SetupTitle = dt.h1`
  font-size: 1.5rem;
  font-weight: 500;
  margin-bottom: 1rem;
  color: white;
`;
var SetupInputGroup = dt.div`
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  width: 100%;
`;
var SetupInputField = dt.input`
  width: 400px;
  padding: 0.8rem;
  border-radius: 0.375rem;
  border: none;
  background-color: #333;
  color: white;
  font-size: 16px;

  &::placeholder {
    color: #888;
  }
`;
var SetupErrorText = dt.span`
  color: #ef4444;
  font-size: 0.875rem;
  min-height: 1.2em;
`;
var SetupSubmitButton = dt.button`
  color: white;
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 0.5rem;
  height: 46px;
  font-size: 1rem;
  font-weight: 500;
  border-radius: 0.375rem;
  border: none;
  outline: none;
  padding: 0.5rem;
  cursor: pointer;
  background-color: #ff7a00;
  transition: background-color 0.2s ease;

  &:disabled {
    background-color: #6b7280;
    cursor: not-allowed;
  }

  &:hover {
    background-color: #ff8c00;
  }
`;
var SetupSpinnerContainer = dt.div`
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 200px;
`;
var RowItem = dt.div`
  display: flex;
  width: 100%;
  align-items: center;
  gap: 1px;
  font-size: 0.875rem;
  text-align: left;
  padding-right: 1.5rem;
  border-top: 1px solid #23262d;
  ${(props) => props.$hasBorders && `border-bottom: 1px solid #23262D;`}

  .row-item {
    padding: 0.75rem 0rem;
    display: flex;
    align-items: center;
    width: 25%;
  }
  .name {
    text-align: left;
    &:hover {
      color: #4cfafc;
      cursor: pointer;
    }
  }
`;
function ListItem2({
  item,
  id,
  count,
  onRowItemClick
}) {
  return import_react16.default.createElement(RowItem, { key: id, $hasBorders: id === count }, import_react16.default.createElement(
    "div",
    {
      className: "row-item name",
      onClick: () => onRowItemClick && onRowItemClick(item)
    },
    item
  ));
}
var SelectContext = ({
  contextList,
  setSelectedContextId,
  backStep
}) => {
  const handleContextSelection = (selectedContextId) => {
    setSelectedContextId(selectedContextId);
  };
  return import_react15.default.createElement(ContextModal2, null, import_react15.default.createElement(ContextWrapper, null, import_react15.default.createElement(ContextSubtitle, { color: "#fff" }, import_react15.default.createElement("span", null, "Select a context:")), contextList.length > 0 ? import_react15.default.createElement(import_react15.default.Fragment, null, import_react15.default.createElement(ContextListContainer, null, contextList.map((context, i2) => import_react15.default.createElement(
    ListItem2,
    {
      key: context.id,
      item: context.id,
      id: i2,
      count: contextList.length,
      onRowItemClick: handleContextSelection
    }
  ))), backStep && import_react15.default.createElement(Button2, { onClick: backStep }, "Back")) : import_react15.default.createElement(NoContextWrapper, null, import_react15.default.createElement(NoContextMessage, null, "No contexts found"))));
};
var SelectContextIdentity = ({
  contextIdentities,
  selectedContextId,
  onSelectIdentity,
  backStep
}) => {
  const truncateText = (text) => {
    return `${text.substring(0, 4)}...${text.substring(
      text.length - 4,
      text.length
    )}`;
  };
  return import_react17.default.createElement(ContextModal2, null, import_react17.default.createElement(ContextTitle, null, "Select Context Identity"), import_react17.default.createElement(ContextWrapper, null, import_react17.default.createElement(ContextSubtitle, { separator: true, color: "#fff" }, import_react17.default.createElement("span", null, "Currently selected:")), import_react17.default.createElement(ContextSubtitle, null, import_react17.default.createElement("span", null, "Context ID"), import_react17.default.createElement(AppIdContainer, null, import_react17.default.createElement("span", null, truncateText(selectedContextId))))), import_react17.default.createElement(ContextWrapper, null, import_react17.default.createElement(ContextSubtitle, { color: "#fff" }, import_react17.default.createElement("span", null, "Select an identity to login:")), contextIdentities.length > 0 ? import_react17.default.createElement(ContextListContainer, null, contextIdentities.map((identity, i2) => import_react17.default.createElement(
    ListItem2,
    {
      key: i2,
      item: identity,
      id: i2,
      count: contextIdentities.length,
      onRowItemClick: () => onSelectIdentity(selectedContextId, identity)
    }
  ))) : import_react17.default.createElement(NoContextWrapper, null, import_react17.default.createElement(NoContextMessage, null, "No identities found"))), import_react17.default.createElement(ContextWrapper, null, backStep && import_react17.default.createElement(Button2, { onClick: backStep }, "Back to context selection")));
};
var initialState = {
  nodeServerUrl: "",
  applicationId: "",
  selectedContextId: "",
  contexts: [],
  contextIdentities: [],
  errorMessage: "",
  isLoading: false
};
var ClientLogin = ({
  permissions,
  authMode,
  setIsAuthenticated,
  clientApplicationId,
  clientApplicationPath,
  fetchContextApplication,
  onReset
}) => {
  const [state, setState] = (0, import_react14.useState)({
    ...initialState,
    nodeServerUrl: getAppEndpointKey() ?? "",
    applicationId: getApplicationId() ?? ""
  });
  const {
    nodeServerUrl,
    selectedContextId,
    contexts,
    contextIdentities,
    errorMessage,
    isLoading
  } = state;
  const updateState = (newState) => {
    setState((prev2) => ({ ...prev2, ...newState }));
  };
  const resetSetup = () => {
    clearAppEndpoint();
    clearAccessToken();
    clearContextId();
    clearExecutorPublicKey();
    clearApplicationId();
    onReset();
  };
  const fetchAvailableContexts = (0, import_react14.useCallback)(async () => {
    var _a;
    if (errorMessage) return;
    try {
      const response = await apiClient.node().getContexts();
      if (response.error) {
        updateState({ errorMessage: response.error.message, isLoading: false });
        return;
      }
      updateState({ contexts: (_a = response.data) == null ? void 0 : _a.contexts, isLoading: false });
    } catch (error) {
      updateState({
        errorMessage: "Failed to fetch contexts",
        isLoading: false
      });
    }
  }, [errorMessage]);
  const fetchContextIdentities = (0, import_react14.useCallback)(async () => {
    if (!selectedContextId) return;
    try {
      const response = await apiClient.node().fetchContextIdentities(selectedContextId);
      if (response.error) {
        updateState({ errorMessage: response.error.message });
        return;
      }
      updateState({ contextIdentities: response.data.identities });
    } catch (error) {
      updateState({ errorMessage: "Failed to fetch context identities" });
    }
  }, [selectedContextId]);
  const handleIdentitySelection = (contextId, identity) => {
    setContextId(contextId);
    setExecutorPublicKey(identity);
    fetchContextApplication();
  };
  const login = (0, import_react14.useCallback)(async () => {
    apiClient.auth().login({
      url: nodeServerUrl,
      callbackUrl: window.location.href,
      permissions,
      applicationId: clientApplicationId,
      applicationPath: clientApplicationPath
    });
  }, [nodeServerUrl, permissions, clientApplicationId, clientApplicationPath]);
  (0, import_react14.useEffect)(() => {
    if (authMode === false) {
      updateState({ isLoading: true });
      fetchAvailableContexts();
    }
  }, [nodeServerUrl, fetchAvailableContexts, authMode]);
  (0, import_react14.useEffect)(() => {
    if (selectedContextId) {
      fetchContextIdentities();
    }
  }, [selectedContextId, fetchContextIdentities]);
  const renderLoginContent = () => {
    if (isLoading) {
      return import_react14.default.createElement(SetupSpinnerContainer, null, import_react14.default.createElement(Spinner, null));
    }
    if (authMode === true) {
      return import_react14.default.createElement(import_react14.default.Fragment, null, import_react14.default.createElement(LoginButton, { onClick: login }, "Login"), import_react14.default.createElement(Button2, { onClick: resetSetup, style: { marginTop: "1rem" } }, "Back to Setup"));
    }
    return import_react14.default.createElement(import_react14.default.Fragment, null, import_react14.default.createElement(LoginHeader, null, import_react14.default.createElement(LoginHeaderSpan, null, "Select Context ID and Identity")), !selectedContextId ? import_react14.default.createElement(
      SelectContext,
      {
        contextList: contexts,
        setSelectedContextId: (id) => updateState({ selectedContextId: id })
      }
    ) : import_react14.default.createElement(
      SelectContextIdentity,
      {
        selectedContextId,
        contextIdentities,
        onSelectIdentity: handleIdentitySelection,
        backStep: () => updateState({ selectedContextId: "" })
      }
    ), import_react14.default.createElement(Button2, { onClick: resetSetup, style: { marginTop: "1rem" } }, "Back to Setup"));
  };
  return import_react14.default.createElement(ModalOverlay, null, import_react14.default.createElement(ModalContent, null, errorMessage && import_react14.default.createElement(import_react14.default.Fragment, null, import_react14.default.createElement(ErrorMessage3, null, errorMessage), import_react14.default.createElement(Button2, { onClick: resetSetup, style: { marginTop: "1rem" } }, "Back to Setup")), renderLoginContent()));
};
var initialState2 = {
  url: "",
  errors: {
    url: "",
    applicationId: ""
  },
  isLoading: false
};
var validateUrl = (url) => {
  try {
    new URL(url);
    return true;
  } catch {
    return false;
  }
};
var SetupModal = ({ setNodeServerUrl }) => {
  const [state, setState] = (0, import_react20.useState)(initialState2);
  const { url, errors, isLoading } = state;
  const updateState = (newState) => {
    setState((prev2) => ({ ...prev2, ...newState }));
  };
  const updateError = (field, message) => {
    setState((prev2) => ({
      ...prev2,
      errors: {
        ...prev2.errors,
        [field]: message
      }
    }));
  };
  const handleUrlChange = (value) => {
    updateState({
      url: value,
      errors: {
        ...state.errors,
        url: ""
      }
    });
  };
  const handleSubmit = (0, import_react20.useCallback)(async () => {
    if (!url) return;
    if (!validateUrl(url)) {
      updateError(
        "url",
        "Connection failed. Please check if node url is correct."
      );
      return;
    }
    updateState({ isLoading: true });
    setAppEndpointKey(url);
    setNodeServerUrl(url);
  }, [url, setNodeServerUrl]);
  const onFormSubmit = (e) => {
    e.preventDefault();
    if (!isSubmitDisabled) {
      handleSubmit();
    }
  };
  const isSubmitDisabled = !url || Boolean(errors.url);
  (0, import_react19.useEffect)(() => {
    const fragment = window.location.hash.substring(1);
    const fragmentParams = new URLSearchParams(fragment);
    const nodeUrl = fragmentParams.get("node_url");
    if (nodeUrl) {
      handleUrlChange(decodeURIComponent(nodeUrl));
      fragmentParams.delete("node_url");
      const newFragment = fragmentParams.toString();
      const newUrl = window.location.pathname + window.location.search + (newFragment ? `#${newFragment}` : "");
      window.history.replaceState({}, "", newUrl);
    }
  }, []);
  return import_react19.default.createElement(SetupModalOverlay, null, import_react19.default.createElement(SetupModalContainer, null, import_react19.default.createElement(SetupModalContent, null, import_react19.default.createElement(SetupFormContainer, null, import_react19.default.createElement(SetupTitle, null, "Connect to Calimero Node"), isLoading ? import_react19.default.createElement(SetupSpinnerContainer, null, import_react19.default.createElement(Spinner, null)) : import_react19.default.createElement("form", { onSubmit: onFormSubmit }, import_react19.default.createElement(SetupInputGroup, null, import_react19.default.createElement(
    SetupInputField,
    {
      type: "text",
      placeholder: "Node URL",
      inputMode: "url",
      value: url,
      onChange: (e) => handleUrlChange(e.target.value),
      "aria-invalid": !!errors.url,
      "aria-describedby": "urlError"
    }
  ), import_react19.default.createElement(SetupErrorText, null, errors.url), import_react19.default.createElement(SetupSubmitButton, { type: "submit", disabled: isSubmitDisabled }, import_react19.default.createElement("span", null, "Continue"))))))));
};
var ProtectedRoutesWrapper = ({
  children,
  permissions = [],
  applicationId = "",
  clientApplicationPath = ""
}) => {
  const [isAuthenticated, setIsAuthenticated] = (0, import_react18.useState)(false);
  const [isInitialized, setIsInitialized] = (0, import_react18.useState)(false);
  const [isLoading, setIsLoading] = (0, import_react18.useState)(true);
  const [authMode, setAuthMode] = (0, import_react18.useState)(null);
  const [error, setError] = (0, import_react18.useState)(null);
  const isAdminDashboardUrl = () => {
    const nodeUrl = getAppEndpointKey();
    const currentUrl = window.location.href;
    if (!nodeUrl) return false;
    return currentUrl.includes("/admin-dashboard");
  };
  const handleReset = () => {
    setAuthMode(null);
    setIsAuthenticated(false);
    setIsInitialized(false);
    setError(null);
    clearAppEndpoint();
    clearAccessToken();
    clearRefreshToken();
    clearApplicationId();
    clearContextId();
    clearExecutorPublicKey();
    checkAuth();
  };
  const initializeApplication = async (accessToken, refreshToken, appId) => {
    try {
      setIsLoading(true);
      setAccessToken(accessToken);
      setRefreshToken(refreshToken);
      setContextAndIdentityFromJWT(accessToken);
      if (appId) {
        setApplicationId(appId);
        setIsInitialized(true);
        setIsAuthenticated(true);
      } else {
        const contextId = getContextId();
        if (contextId) {
          const response = await apiClient.node().getContext(contextId);
          if (response.error) {
            setError(response.error.message);
            return;
          }
          setApplicationId(response.data.applicationId);
        }
        setIsInitialized(true);
        setIsAuthenticated(true);
      }
    } catch (error2) {
      setError("Failed to initialize application");
      setIsInitialized(false);
      setIsAuthenticated(false);
    } finally {
      setIsLoading(false);
    }
  };
  const fetchContextApplication = async () => {
    try {
      const contextId = getContextId();
      const response = await apiClient.node().getContext(contextId);
      if (response.error) {
        setError(response.error.message);
        return;
      }
      setApplicationId(response.data.applicationId);
      setAuthMode(false);
      if (getAccessToken()) {
        setAuthMode(true);
      }
      setIsInitialized(true);
      setIsAuthenticated(true);
    } catch (error2) {
      setError("Failed to fetch context application");
      setIsInitialized(false);
    }
    setIsLoading(false);
  };
  const updateState = (newState) => {
    setAppEndpointKey(newState.nodeServerUrl);
    setError(null);
    checkAuth();
  };
  const checkAuthMode = async () => {
    var _a;
    const nodeUrl = getAppEndpointKey();
    if (!nodeUrl) {
      setError("Missing node URL configuration");
      setAuthMode(null);
      setIsLoading(false);
      return;
    }
    try {
      const response = await apiClient.node().checkAuth();
      if (((_a = response.error) == null ? void 0 : _a.code) === 401) {
        setAuthMode(true);
      } else if (response.error) {
        setError(response.error.message);
      } else {
        setAuthMode(false);
      }
    } catch (error2) {
      setError("Failed to check auth mode");
    }
    setIsLoading(false);
  };
  const checkAuth = (0, import_react18.useCallback)(async () => {
    setIsLoading(true);
    const storedApplicationId = getApplicationId();
    const storedContextId = getContextId();
    const storedExecutorPublicKey = getExecutorPublicKey();
    const storedAccessToken = getAccessToken();
    const storedRefreshToken = getRefreshToken();
    if (storedAccessToken && storedRefreshToken && storedApplicationId && storedContextId && storedExecutorPublicKey) {
      setAuthMode(true);
      setIsAuthenticated(true);
      setIsInitialized(true);
      setIsLoading(false);
      return;
    }
    if (storedApplicationId && storedContextId && storedExecutorPublicKey && !storedAccessToken) {
      setAuthMode(false);
      setIsAuthenticated(true);
      setIsInitialized(true);
      setIsLoading(false);
      return;
    }
    const token2 = getAccessToken();
    const jwt = getJWTObject();
    if (token2 && jwt) {
      await checkAuthMode();
      if (!error) {
        const contextId = getContextId();
        const executorPublicKey = getExecutorPublicKey();
        console.log("contextId", contextId);
        console.log("executorPublicKey", executorPublicKey);
        if (contextId && executorPublicKey) {
          await fetchContextApplication();
        }
      }
    } else {
      await checkAuthMode();
      if (authMode === false && !error) {
        const contextId = getContextId();
        const executorPublicKey = getExecutorPublicKey();
        console.log("contextId", contextId);
        console.log("executorPublicKey", executorPublicKey);
        if (contextId && executorPublicKey) {
          await fetchContextApplication();
        }
      }
    }
    setIsLoading(false);
  }, [authMode, error]);
  (0, import_react18.useEffect)(() => {
    const fragment = window.location.hash.substring(1);
    const fragmentParams = new URLSearchParams(fragment);
    const encodedAccessToken = fragmentParams.get("access_token");
    const encodedRefreshToken = fragmentParams.get("refresh_token");
    if (encodedAccessToken && encodedRefreshToken) {
      const accessToken = decodeURIComponent(encodedAccessToken);
      const refreshToken = decodeURIComponent(encodedRefreshToken);
      setContextAndIdentityFromJWT(accessToken);
      initializeApplication(
        accessToken,
        refreshToken,
        applicationId || void 0
      );
      fragmentParams.delete("access_token");
      fragmentParams.delete("refresh_token");
      const newFragment = fragmentParams.toString();
      const newUrl = window.location.pathname + window.location.search + (newFragment ? `#${newFragment}` : "");
      window.history.replaceState({}, "", newUrl);
      setIsAuthenticated(true);
      setIsInitialized(true);
    } else {
      checkAuth();
    }
  }, [applicationId, checkAuth]);
  if (isLoading) {
    return import_react18.default.createElement(ModalOverlay, null, import_react18.default.createElement(ModalContent, null, import_react18.default.createElement(SetupSpinnerContainer, null, import_react18.default.createElement(Spinner, null))));
  }
  if (!getAppEndpointKey()) {
    return import_react18.default.createElement(ModalOverlay, null, import_react18.default.createElement(ModalContent, null, import_react18.default.createElement(
      SetupModal,
      {
        setNodeServerUrl: (url) => {
          setError(null);
          updateState({ nodeServerUrl: url });
          checkAuth();
        }
      }
    )));
  }
  if (error) {
    return import_react18.default.createElement(ModalOverlay, null, import_react18.default.createElement(ModalContent, null, import_react18.default.createElement(ErrorMessage3, null, error), import_react18.default.createElement(Button2, { onClick: handleReset }, "Reset")));
  }
  if (authMode === false && isAdminDashboardUrl()) {
    return import_react18.default.createElement(import_react18.default.Fragment, null, children);
  }
  if (authMode !== null && (!isAuthenticated || !isInitialized)) {
    return import_react18.default.createElement(
      ClientLogin,
      {
        permissions,
        authMode,
        setIsAuthenticated,
        clientApplicationId: applicationId,
        clientApplicationPath,
        fetchContextApplication,
        onReset: handleReset
      }
    );
  }
  return isAuthenticated && isInitialized ? import_react18.default.createElement(import_react18.default.Fragment, null, children) : null;
};
var DEFAULT_CONNECTION_ID = "DEFAULT";
var WsSubscriptionsClient = class {
  constructor(baseUrl, path) {
    __publicField(this, "url");
    __publicField(this, "connections");
    __publicField(this, "callbacks");
    this.url = `${baseUrl}${path}`;
    this.connections = /* @__PURE__ */ new Map();
    this.callbacks = /* @__PURE__ */ new Map();
  }
  connect(connectionId = DEFAULT_CONNECTION_ID) {
    return new Promise((resolve, reject) => {
      const websocket = new WebSocket(this.url);
      this.connections.set(connectionId, websocket);
      this.callbacks.set(connectionId, []);
      websocket.onopen = () => {
        resolve();
      };
      websocket.onerror = (error) => {
        reject(error);
      };
      websocket.onmessage = (event) => this.handleMessage(connectionId, event);
    });
  }
  disconnect(connectionId = DEFAULT_CONNECTION_ID) {
    const websocket = this.connections.get(connectionId);
    if (websocket) {
      websocket.close();
      this.connections.delete(connectionId);
      this.callbacks.delete(connectionId);
    }
  }
  subscribe(contextIds, connectionId = DEFAULT_CONNECTION_ID) {
    const websocket = this.connections.get(connectionId);
    if (websocket && websocket.readyState === websocket.OPEN) {
      const requestId = this.getRandomRequestId();
      const request = {
        id: requestId,
        method: "subscribe",
        params: {
          contextIds
        }
      };
      websocket.send(JSON.stringify(request));
    }
  }
  unsubscribe(contextIds, connectionId = DEFAULT_CONNECTION_ID) {
    const websocket = this.connections.get(connectionId);
    if (websocket && websocket.readyState === websocket.OPEN) {
      const requestId = this.getRandomRequestId();
      const request = {
        id: requestId,
        method: "unsubscribe",
        params: {
          contextIds
        }
      };
      websocket.send(JSON.stringify(request));
    }
  }
  addCallback(callback, connectionId = DEFAULT_CONNECTION_ID) {
    if (!this.callbacks.has(connectionId)) {
      this.callbacks.set(connectionId, [callback]);
    } else {
      this.callbacks.get(connectionId).push(callback);
    }
  }
  removeCallback(callback, connectionId = DEFAULT_CONNECTION_ID) {
    const callbacks = this.callbacks.get(connectionId);
    if (callbacks) {
      const index = callbacks.indexOf(callback);
      if (index !== -1) {
        callbacks.splice(index, 1);
      }
    }
  }
  handleMessage(connectionId, event) {
    const response = JSON.parse(event.data.toString());
    if (response.id !== null) {
      return;
    }
    if (response.error !== void 0) {
      return;
    }
    const callbacks = this.callbacks.get(connectionId);
    if (callbacks) {
      for (const callback of callbacks) {
        const nodeEvent = response.result;
        callback(nodeEvent);
      }
    }
  }
  getRandomRequestId() {
    return Math.floor(Math.random() * Math.pow(2, 32));
  }
};
export {
  ACCESS_TOKEN,
  APPLICATION_ID,
  APP_URL,
  AppMode,
  CONTEXT_ID,
  CONTEXT_IDENTITY,
  CalimeroConnectButton_default as CalimeroConnectButton,
  CalimeroLogo_default as CalimeroLogo,
  CalimeroProvider,
  ClientLogin,
  ContextModal,
  JsonRpcClient,
  ProtectedRoutesWrapper,
  Protocol,
  REFRESH_TOKEN,
  SelectContext,
  SelectContextIdentity,
  SetupModal,
  Toast_default as Toast,
  WsSubscriptionsClient,
  adminClient,
  apiClient,
  authClient,
  blobClient,
  clearAccessToken,
  clearAppEndpoint,
  clearApplicationId,
  clearContextId,
  clearExecutorPublicKey,
  clearRefreshToken,
  clientLogout,
  contractClient,
  getAccessToken,
  getAppEndpointKey,
  getApplicationId,
  getAuthConfig,
  getContextId,
  getExecutorPublicKey,
  getJWTObject,
  getRefreshToken,
  rpcClient,
  setAccessToken,
  setAppEndpointKey,
  setApplicationId,
  setContextAndIdentityFromJWT,
  setContextId,
  setExecutorPublicKey,
  setRefreshToken,
  useCalimero
};
//# sourceMappingURL=@calimero-network_calimero-client.js.map
